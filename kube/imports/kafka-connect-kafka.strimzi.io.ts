// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 *
 *
 * @schema KafkaConnect
 */
export class KafkaConnect extends ApiObject {
  /**
   * Returns the apiVersion and kind for "KafkaConnect"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kafka.strimzi.io/v1beta2',
    kind: 'KafkaConnect',
  }

  /**
   * Renders a Kubernetes manifest for "KafkaConnect".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: KafkaConnectProps = {}): any {
    return {
      ...KafkaConnect.GVK,
      ...toJson_KafkaConnectProps(props),
    };
  }

  /**
   * Defines a "KafkaConnect" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: KafkaConnectProps = {}) {
    super(scope, id, {
      ...KafkaConnect.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...KafkaConnect.GVK,
      ...toJson_KafkaConnectProps(resolved),
    };
  }
}

/**
 * @schema KafkaConnect
 */
export interface KafkaConnectProps {
  /**
   * @schema KafkaConnect#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * The specification of the Kafka Connect cluster.
   *
   * @schema KafkaConnect#spec
   */
  readonly spec?: KafkaConnectSpec;

}

/**
 * Converts an object of type 'KafkaConnectProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectProps(obj: KafkaConnectProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_KafkaConnectSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The specification of the Kafka Connect cluster.
 *
 * @schema KafkaConnectSpec
 */
export interface KafkaConnectSpec {
  /**
   * The Kafka Connect version. Defaults to {DefaultKafkaVersion}. Consult the user documentation to understand the process required to upgrade or downgrade the version.
   *
   * @default DefaultKafkaVersion}. Consult the user documentation to understand the process required to upgrade or downgrade the version.
   * @schema KafkaConnectSpec#version
   */
  readonly version?: string;

  /**
   * The number of pods in the Kafka Connect group. Defaults to `3`.
   *
   * @default 3`.
   * @schema KafkaConnectSpec#replicas
   */
  readonly replicas?: number;

  /**
   * The docker image for the pods.
   *
   * @schema KafkaConnectSpec#image
   */
  readonly image?: string;

  /**
   * Bootstrap servers to connect to. This should be given as a comma separated list of _<hostname>_:_<port>_ pairs.
   *
   * @schema KafkaConnectSpec#bootstrapServers
   */
  readonly bootstrapServers: string;

  /**
   * TLS configuration.
   *
   * @schema KafkaConnectSpec#tls
   */
  readonly tls?: KafkaConnectSpecTls;

  /**
   * Authentication configuration for Kafka Connect.
   *
   * @schema KafkaConnectSpec#authentication
   */
  readonly authentication?: KafkaConnectSpecAuthentication;

  /**
   * The Kafka Connect configuration. Properties with the following prefixes cannot be set: ssl., sasl., security., listeners, plugin.path, rest., bootstrap.servers, consumer.interceptor.classes, producer.interceptor.classes (with the exception of: ssl.endpoint.identification.algorithm, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols).
   *
   * @schema KafkaConnectSpec#config
   */
  readonly config?: any;

  /**
   * The maximum limits for CPU and memory resources and the requested initial resources.
   *
   * @schema KafkaConnectSpec#resources
   */
  readonly resources?: KafkaConnectSpecResources;

  /**
   * Pod liveness checking.
   *
   * @schema KafkaConnectSpec#livenessProbe
   */
  readonly livenessProbe?: KafkaConnectSpecLivenessProbe;

  /**
   * Pod readiness checking.
   *
   * @schema KafkaConnectSpec#readinessProbe
   */
  readonly readinessProbe?: KafkaConnectSpecReadinessProbe;

  /**
   * JVM Options for pods.
   *
   * @schema KafkaConnectSpec#jvmOptions
   */
  readonly jvmOptions?: KafkaConnectSpecJvmOptions;

  /**
   * JMX Options.
   *
   * @schema KafkaConnectSpec#jmxOptions
   */
  readonly jmxOptions?: KafkaConnectSpecJmxOptions;

  /**
   * Logging configuration for Kafka Connect.
   *
   * @schema KafkaConnectSpec#logging
   */
  readonly logging?: KafkaConnectSpecLogging;

  /**
   * The image of the init container used for initializing the `client.rack`.
   *
   * @schema KafkaConnectSpec#clientRackInitImage
   */
  readonly clientRackInitImage?: string;

  /**
   * Configuration of the node label which will be used as the `client.rack` consumer configuration.
   *
   * @schema KafkaConnectSpec#rack
   */
  readonly rack?: KafkaConnectSpecRack;

  /**
   * The configuration of tracing in Kafka Connect.
   *
   * @schema KafkaConnectSpec#tracing
   */
  readonly tracing?: KafkaConnectSpecTracing;

  /**
   * Template for Kafka Connect and Kafka Mirror Maker 2 resources. The template allows users to specify how the `Deployment`, `Pods` and `Service` are generated.
   *
   * @schema KafkaConnectSpec#template
   */
  readonly template?: KafkaConnectSpecTemplate;

  /**
   * Pass data from Secrets or ConfigMaps to the Kafka Connect pods and use them to configure connectors.
   *
   * @schema KafkaConnectSpec#externalConfiguration
   */
  readonly externalConfiguration?: KafkaConnectSpecExternalConfiguration;

  /**
   * Configures how the Connect container image should be built. Optional.
   *
   * @schema KafkaConnectSpec#build
   */
  readonly build?: KafkaConnectSpecBuild;

  /**
   * Metrics configuration.
   *
   * @schema KafkaConnectSpec#metricsConfig
   */
  readonly metricsConfig?: KafkaConnectSpecMetricsConfig;

}

/**
 * Converts an object of type 'KafkaConnectSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpec(obj: KafkaConnectSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'version': obj.version,
    'replicas': obj.replicas,
    'image': obj.image,
    'bootstrapServers': obj.bootstrapServers,
    'tls': toJson_KafkaConnectSpecTls(obj.tls),
    'authentication': toJson_KafkaConnectSpecAuthentication(obj.authentication),
    'config': obj.config,
    'resources': toJson_KafkaConnectSpecResources(obj.resources),
    'livenessProbe': toJson_KafkaConnectSpecLivenessProbe(obj.livenessProbe),
    'readinessProbe': toJson_KafkaConnectSpecReadinessProbe(obj.readinessProbe),
    'jvmOptions': toJson_KafkaConnectSpecJvmOptions(obj.jvmOptions),
    'jmxOptions': toJson_KafkaConnectSpecJmxOptions(obj.jmxOptions),
    'logging': toJson_KafkaConnectSpecLogging(obj.logging),
    'clientRackInitImage': obj.clientRackInitImage,
    'rack': toJson_KafkaConnectSpecRack(obj.rack),
    'tracing': toJson_KafkaConnectSpecTracing(obj.tracing),
    'template': toJson_KafkaConnectSpecTemplate(obj.template),
    'externalConfiguration': toJson_KafkaConnectSpecExternalConfiguration(obj.externalConfiguration),
    'build': toJson_KafkaConnectSpecBuild(obj.build),
    'metricsConfig': toJson_KafkaConnectSpecMetricsConfig(obj.metricsConfig),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS configuration.
 *
 * @schema KafkaConnectSpecTls
 */
export interface KafkaConnectSpecTls {
  /**
   * Trusted certificates for TLS connection.
   *
   * @schema KafkaConnectSpecTls#trustedCertificates
   */
  readonly trustedCertificates?: KafkaConnectSpecTlsTrustedCertificates[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTls(obj: KafkaConnectSpecTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'trustedCertificates': obj.trustedCertificates?.map(y => toJson_KafkaConnectSpecTlsTrustedCertificates(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authentication configuration for Kafka Connect.
 *
 * @schema KafkaConnectSpecAuthentication
 */
export interface KafkaConnectSpecAuthentication {
  /**
   * Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
   *
   * @schema KafkaConnectSpecAuthentication#accessToken
   */
  readonly accessToken?: KafkaConnectSpecAuthenticationAccessToken;

  /**
   * Configure whether access token should be treated as JWT. This should be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
   *
   * @default true`.
   * @schema KafkaConnectSpecAuthentication#accessTokenIsJwt
   */
  readonly accessTokenIsJwt?: boolean;

  /**
   * OAuth audience to use when authenticating against the authorization server. Some authorization servers require the audience to be explicitly set. The possible values depend on how the authorization server is configured. By default, `audience` is not specified when performing the token endpoint request.
   *
   * @schema KafkaConnectSpecAuthentication#audience
   */
  readonly audience?: string;

  /**
   * Reference to the `Secret` which holds the certificate and private key pair.
   *
   * @schema KafkaConnectSpecAuthentication#certificateAndKey
   */
  readonly certificateAndKey?: KafkaConnectSpecAuthenticationCertificateAndKey;

  /**
   * OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
   *
   * @schema KafkaConnectSpecAuthentication#clientId
   */
  readonly clientId?: string;

  /**
   * Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
   *
   * @schema KafkaConnectSpecAuthentication#clientSecret
   */
  readonly clientSecret?: KafkaConnectSpecAuthenticationClientSecret;

  /**
   * The connect timeout in seconds when connecting to authorization server. If not set, the effective connect timeout is 60 seconds.
   *
   * @schema KafkaConnectSpecAuthentication#connectTimeoutSeconds
   */
  readonly connectTimeoutSeconds?: number;

  /**
   * Enable or disable TLS hostname verification. Default value is `false`.
   *
   * @schema KafkaConnectSpecAuthentication#disableTlsHostnameVerification
   */
  readonly disableTlsHostnameVerification?: boolean;

  /**
   * Enable or disable OAuth metrics. Default value is `false`.
   *
   * @schema KafkaConnectSpecAuthentication#enableMetrics
   */
  readonly enableMetrics?: boolean;

  /**
   * The maximum number of retries to attempt if an initial HTTP request fails. If not set, the default is to not attempt any retries.
   *
   * @schema KafkaConnectSpecAuthentication#httpRetries
   */
  readonly httpRetries?: number;

  /**
   * The pause to take before retrying a failed HTTP request. If not set, the default is to not pause at all but to immediately repeat a request.
   *
   * @schema KafkaConnectSpecAuthentication#httpRetryPauseMs
   */
  readonly httpRetryPauseMs?: number;

  /**
   * Set or limit time-to-live of the access tokens to the specified number of seconds. This should be set if the authorization server returns opaque tokens.
   *
   * @schema KafkaConnectSpecAuthentication#maxTokenExpirySeconds
   */
  readonly maxTokenExpirySeconds?: number;

  /**
   * Reference to the `Secret` which holds the password.
   *
   * @schema KafkaConnectSpecAuthentication#passwordSecret
   */
  readonly passwordSecret?: KafkaConnectSpecAuthenticationPasswordSecret;

  /**
   * The read timeout in seconds when connecting to authorization server. If not set, the effective read timeout is 60 seconds.
   *
   * @schema KafkaConnectSpecAuthentication#readTimeoutSeconds
   */
  readonly readTimeoutSeconds?: number;

  /**
   * Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
   *
   * @schema KafkaConnectSpecAuthentication#refreshToken
   */
  readonly refreshToken?: KafkaConnectSpecAuthenticationRefreshToken;

  /**
   * OAuth scope to use when authenticating against the authorization server. Some authorization servers require this to be set. The possible values depend on how authorization server is configured. By default `scope` is not specified when doing the token endpoint request.
   *
   * @schema KafkaConnectSpecAuthentication#scope
   */
  readonly scope?: string;

  /**
   * Trusted certificates for TLS connection to the OAuth server.
   *
   * @schema KafkaConnectSpecAuthentication#tlsTrustedCertificates
   */
  readonly tlsTrustedCertificates?: KafkaConnectSpecAuthenticationTlsTrustedCertificates[];

  /**
   * Authorization server token endpoint URI.
   *
   * @schema KafkaConnectSpecAuthentication#tokenEndpointUri
   */
  readonly tokenEndpointUri?: string;

  /**
   * Authentication type. Currently the supported types are `tls`, `scram-sha-256`, `scram-sha-512`, `plain`, and 'oauth'. `scram-sha-256` and `scram-sha-512` types use SASL SCRAM-SHA-256 and SASL SCRAM-SHA-512 Authentication, respectively. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.
   *
   * @schema KafkaConnectSpecAuthentication#type
   */
  readonly type: KafkaConnectSpecAuthenticationType;

  /**
   * Username used for the authentication.
   *
   * @schema KafkaConnectSpecAuthentication#username
   */
  readonly username?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecAuthentication' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecAuthentication(obj: KafkaConnectSpecAuthentication | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessToken': toJson_KafkaConnectSpecAuthenticationAccessToken(obj.accessToken),
    'accessTokenIsJwt': obj.accessTokenIsJwt,
    'audience': obj.audience,
    'certificateAndKey': toJson_KafkaConnectSpecAuthenticationCertificateAndKey(obj.certificateAndKey),
    'clientId': obj.clientId,
    'clientSecret': toJson_KafkaConnectSpecAuthenticationClientSecret(obj.clientSecret),
    'connectTimeoutSeconds': obj.connectTimeoutSeconds,
    'disableTlsHostnameVerification': obj.disableTlsHostnameVerification,
    'enableMetrics': obj.enableMetrics,
    'httpRetries': obj.httpRetries,
    'httpRetryPauseMs': obj.httpRetryPauseMs,
    'maxTokenExpirySeconds': obj.maxTokenExpirySeconds,
    'passwordSecret': toJson_KafkaConnectSpecAuthenticationPasswordSecret(obj.passwordSecret),
    'readTimeoutSeconds': obj.readTimeoutSeconds,
    'refreshToken': toJson_KafkaConnectSpecAuthenticationRefreshToken(obj.refreshToken),
    'scope': obj.scope,
    'tlsTrustedCertificates': obj.tlsTrustedCertificates?.map(y => toJson_KafkaConnectSpecAuthenticationTlsTrustedCertificates(y)),
    'tokenEndpointUri': obj.tokenEndpointUri,
    'type': obj.type,
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The maximum limits for CPU and memory resources and the requested initial resources.
 *
 * @schema KafkaConnectSpecResources
 */
export interface KafkaConnectSpecResources {
  /**
   * @schema KafkaConnectSpecResources#claims
   */
  readonly claims?: KafkaConnectSpecResourcesClaims[];

  /**
   * @schema KafkaConnectSpecResources#limits
   */
  readonly limits?: any;

  /**
   * @schema KafkaConnectSpecResources#requests
   */
  readonly requests?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecResources(obj: KafkaConnectSpecResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_KafkaConnectSpecResourcesClaims(y)),
    'limits': obj.limits,
    'requests': obj.requests,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Pod liveness checking.
 *
 * @schema KafkaConnectSpecLivenessProbe
 */
export interface KafkaConnectSpecLivenessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaConnectSpecLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.
   *
   * @default 15 seconds. Minimum value is 0.
   * @schema KafkaConnectSpecLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaConnectSpecLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaConnectSpecLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.
   *
   * @default 5 seconds. Minimum value is 1.
   * @schema KafkaConnectSpecLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'KafkaConnectSpecLivenessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecLivenessProbe(obj: KafkaConnectSpecLivenessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failureThreshold': obj.failureThreshold,
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Pod readiness checking.
 *
 * @schema KafkaConnectSpecReadinessProbe
 */
export interface KafkaConnectSpecReadinessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaConnectSpecReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.
   *
   * @default 15 seconds. Minimum value is 0.
   * @schema KafkaConnectSpecReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaConnectSpecReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaConnectSpecReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.
   *
   * @default 5 seconds. Minimum value is 1.
   * @schema KafkaConnectSpecReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'KafkaConnectSpecReadinessProbe' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecReadinessProbe(obj: KafkaConnectSpecReadinessProbe | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failureThreshold': obj.failureThreshold,
    'initialDelaySeconds': obj.initialDelaySeconds,
    'periodSeconds': obj.periodSeconds,
    'successThreshold': obj.successThreshold,
    'timeoutSeconds': obj.timeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * JVM Options for pods.
 *
 * @schema KafkaConnectSpecJvmOptions
 */
export interface KafkaConnectSpecJvmOptions {
  /**
   * A map of -XX options to the JVM.
   *
   * @schema KafkaConnectSpecJvmOptions#-XX
   */
  readonly xx?: any;

  /**
   * -Xms option to to the JVM.
   *
   * @schema KafkaConnectSpecJvmOptions#-Xms
   */
  readonly xms?: string;

  /**
   * -Xmx option to to the JVM.
   *
   * @schema KafkaConnectSpecJvmOptions#-Xmx
   */
  readonly xmx?: string;

  /**
   * Specifies whether the Garbage Collection logging is enabled. The default is false.
   *
   * @schema KafkaConnectSpecJvmOptions#gcLoggingEnabled
   */
  readonly gcLoggingEnabled?: boolean;

  /**
   * A map of additional system properties which will be passed using the `-D` option to the JVM.
   *
   * @schema KafkaConnectSpecJvmOptions#javaSystemProperties
   */
  readonly javaSystemProperties?: KafkaConnectSpecJvmOptionsJavaSystemProperties[];

}

/**
 * Converts an object of type 'KafkaConnectSpecJvmOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecJvmOptions(obj: KafkaConnectSpecJvmOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    '-XX': obj.xx,
    '-Xms': obj.xms,
    '-Xmx': obj.xmx,
    'gcLoggingEnabled': obj.gcLoggingEnabled,
    'javaSystemProperties': obj.javaSystemProperties?.map(y => toJson_KafkaConnectSpecJvmOptionsJavaSystemProperties(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * JMX Options.
 *
 * @schema KafkaConnectSpecJmxOptions
 */
export interface KafkaConnectSpecJmxOptions {
  /**
   * Authentication configuration for connecting to the JMX port.
   *
   * @schema KafkaConnectSpecJmxOptions#authentication
   */
  readonly authentication?: KafkaConnectSpecJmxOptionsAuthentication;

}

/**
 * Converts an object of type 'KafkaConnectSpecJmxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecJmxOptions(obj: KafkaConnectSpecJmxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authentication': toJson_KafkaConnectSpecJmxOptionsAuthentication(obj.authentication),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Logging configuration for Kafka Connect.
 *
 * @schema KafkaConnectSpecLogging
 */
export interface KafkaConnectSpecLogging {
  /**
   * A Map from logger name to logger level.
   *
   * @schema KafkaConnectSpecLogging#loggers
   */
  readonly loggers?: any;

  /**
   * Logging type, must be either 'inline' or 'external'.
   *
   * @schema KafkaConnectSpecLogging#type
   */
  readonly type: KafkaConnectSpecLoggingType;

  /**
   * `ConfigMap` entry where the logging configuration is stored.
   *
   * @schema KafkaConnectSpecLogging#valueFrom
   */
  readonly valueFrom?: KafkaConnectSpecLoggingValueFrom;

}

/**
 * Converts an object of type 'KafkaConnectSpecLogging' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecLogging(obj: KafkaConnectSpecLogging | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'loggers': obj.loggers,
    'type': obj.type,
    'valueFrom': toJson_KafkaConnectSpecLoggingValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration of the node label which will be used as the `client.rack` consumer configuration.
 *
 * @schema KafkaConnectSpecRack
 */
export interface KafkaConnectSpecRack {
  /**
   * A key that matches labels assigned to the Kubernetes cluster nodes. The value of the label is used to set a broker's `broker.rack` config, and the `client.rack` config for Kafka Connect or MirrorMaker 2.
   *
   * @schema KafkaConnectSpecRack#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecRack' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecRack(obj: KafkaConnectSpecRack | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The configuration of tracing in Kafka Connect.
 *
 * @schema KafkaConnectSpecTracing
 */
export interface KafkaConnectSpecTracing {
  /**
   * Type of the tracing used. Currently the only supported types are `jaeger` for OpenTracing (Jaeger) tracing and `opentelemetry` for OpenTelemetry tracing. The OpenTracing (Jaeger) tracing is deprecated.
   *
   * @schema KafkaConnectSpecTracing#type
   */
  readonly type: KafkaConnectSpecTracingType;

}

/**
 * Converts an object of type 'KafkaConnectSpecTracing' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTracing(obj: KafkaConnectSpecTracing | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka Connect and Kafka Mirror Maker 2 resources. The template allows users to specify how the `Deployment`, `Pods` and `Service` are generated.
 *
 * @schema KafkaConnectSpecTemplate
 */
export interface KafkaConnectSpecTemplate {
  /**
   * Template for Kafka Connect `Deployment`.
   *
   * @schema KafkaConnectSpecTemplate#deployment
   */
  readonly deployment?: KafkaConnectSpecTemplateDeployment;

  /**
   * Template for Kafka Connect `StrimziPodSet` resource.
   *
   * @schema KafkaConnectSpecTemplate#podSet
   */
  readonly podSet?: KafkaConnectSpecTemplatePodSet;

  /**
   * Template for Kafka Connect `Pods`.
   *
   * @schema KafkaConnectSpecTemplate#pod
   */
  readonly pod?: KafkaConnectSpecTemplatePod;

  /**
   * Template for Kafka Connect API `Service`.
   *
   * @schema KafkaConnectSpecTemplate#apiService
   */
  readonly apiService?: KafkaConnectSpecTemplateApiService;

  /**
   * Template for Kafka Connect headless `Service`.
   *
   * @schema KafkaConnectSpecTemplate#headlessService
   */
  readonly headlessService?: KafkaConnectSpecTemplateHeadlessService;

  /**
   * Template for the Kafka Connect container.
   *
   * @schema KafkaConnectSpecTemplate#connectContainer
   */
  readonly connectContainer?: KafkaConnectSpecTemplateConnectContainer;

  /**
   * Template for the Kafka init container.
   *
   * @schema KafkaConnectSpecTemplate#initContainer
   */
  readonly initContainer?: KafkaConnectSpecTemplateInitContainer;

  /**
   * Template for Kafka Connect `PodDisruptionBudget`.
   *
   * @schema KafkaConnectSpecTemplate#podDisruptionBudget
   */
  readonly podDisruptionBudget?: KafkaConnectSpecTemplatePodDisruptionBudget;

  /**
   * Template for the Kafka Connect service account.
   *
   * @schema KafkaConnectSpecTemplate#serviceAccount
   */
  readonly serviceAccount?: KafkaConnectSpecTemplateServiceAccount;

  /**
   * Template for the Kafka Connect ClusterRoleBinding.
   *
   * @schema KafkaConnectSpecTemplate#clusterRoleBinding
   */
  readonly clusterRoleBinding?: KafkaConnectSpecTemplateClusterRoleBinding;

  /**
   * Template for Kafka Connect Build `Pods`. The build pod is used only on Kubernetes.
   *
   * @schema KafkaConnectSpecTemplate#buildPod
   */
  readonly buildPod?: KafkaConnectSpecTemplateBuildPod;

  /**
   * Template for the Kafka Connect Build container. The build container is used only on Kubernetes.
   *
   * @schema KafkaConnectSpecTemplate#buildContainer
   */
  readonly buildContainer?: KafkaConnectSpecTemplateBuildContainer;

  /**
   * Template for the Kafka Connect BuildConfig used to build new container images. The BuildConfig is used only on OpenShift.
   *
   * @schema KafkaConnectSpecTemplate#buildConfig
   */
  readonly buildConfig?: KafkaConnectSpecTemplateBuildConfig;

  /**
   * Template for the Kafka Connect Build service account.
   *
   * @schema KafkaConnectSpecTemplate#buildServiceAccount
   */
  readonly buildServiceAccount?: KafkaConnectSpecTemplateBuildServiceAccount;

  /**
   * Template for Secret of the Kafka Connect Cluster JMX authentication.
   *
   * @schema KafkaConnectSpecTemplate#jmxSecret
   */
  readonly jmxSecret?: KafkaConnectSpecTemplateJmxSecret;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplate(obj: KafkaConnectSpecTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'deployment': toJson_KafkaConnectSpecTemplateDeployment(obj.deployment),
    'podSet': toJson_KafkaConnectSpecTemplatePodSet(obj.podSet),
    'pod': toJson_KafkaConnectSpecTemplatePod(obj.pod),
    'apiService': toJson_KafkaConnectSpecTemplateApiService(obj.apiService),
    'headlessService': toJson_KafkaConnectSpecTemplateHeadlessService(obj.headlessService),
    'connectContainer': toJson_KafkaConnectSpecTemplateConnectContainer(obj.connectContainer),
    'initContainer': toJson_KafkaConnectSpecTemplateInitContainer(obj.initContainer),
    'podDisruptionBudget': toJson_KafkaConnectSpecTemplatePodDisruptionBudget(obj.podDisruptionBudget),
    'serviceAccount': toJson_KafkaConnectSpecTemplateServiceAccount(obj.serviceAccount),
    'clusterRoleBinding': toJson_KafkaConnectSpecTemplateClusterRoleBinding(obj.clusterRoleBinding),
    'buildPod': toJson_KafkaConnectSpecTemplateBuildPod(obj.buildPod),
    'buildContainer': toJson_KafkaConnectSpecTemplateBuildContainer(obj.buildContainer),
    'buildConfig': toJson_KafkaConnectSpecTemplateBuildConfig(obj.buildConfig),
    'buildServiceAccount': toJson_KafkaConnectSpecTemplateBuildServiceAccount(obj.buildServiceAccount),
    'jmxSecret': toJson_KafkaConnectSpecTemplateJmxSecret(obj.jmxSecret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Pass data from Secrets or ConfigMaps to the Kafka Connect pods and use them to configure connectors.
 *
 * @schema KafkaConnectSpecExternalConfiguration
 */
export interface KafkaConnectSpecExternalConfiguration {
  /**
   * Makes data from a Secret or ConfigMap available in the Kafka Connect pods as environment variables.
   *
   * @schema KafkaConnectSpecExternalConfiguration#env
   */
  readonly env?: KafkaConnectSpecExternalConfigurationEnv[];

  /**
   * Makes data from a Secret or ConfigMap available in the Kafka Connect pods as volumes.
   *
   * @schema KafkaConnectSpecExternalConfiguration#volumes
   */
  readonly volumes?: KafkaConnectSpecExternalConfigurationVolumes[];

}

/**
 * Converts an object of type 'KafkaConnectSpecExternalConfiguration' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecExternalConfiguration(obj: KafkaConnectSpecExternalConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'env': obj.env?.map(y => toJson_KafkaConnectSpecExternalConfigurationEnv(y)),
    'volumes': obj.volumes?.map(y => toJson_KafkaConnectSpecExternalConfigurationVolumes(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configures how the Connect container image should be built. Optional.
 *
 * @schema KafkaConnectSpecBuild
 */
export interface KafkaConnectSpecBuild {
  /**
   * Configures where should the newly built image be stored. Required.
   *
   * @schema KafkaConnectSpecBuild#output
   */
  readonly output: KafkaConnectSpecBuildOutput;

  /**
   * CPU and memory resources to reserve for the build.
   *
   * @schema KafkaConnectSpecBuild#resources
   */
  readonly resources?: KafkaConnectSpecBuildResources;

  /**
   * List of connector plugins which should be added to the Kafka Connect. Required.
   *
   * @schema KafkaConnectSpecBuild#plugins
   */
  readonly plugins: KafkaConnectSpecBuildPlugins[];

}

/**
 * Converts an object of type 'KafkaConnectSpecBuild' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecBuild(obj: KafkaConnectSpecBuild | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'output': toJson_KafkaConnectSpecBuildOutput(obj.output),
    'resources': toJson_KafkaConnectSpecBuildResources(obj.resources),
    'plugins': obj.plugins?.map(y => toJson_KafkaConnectSpecBuildPlugins(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metrics configuration.
 *
 * @schema KafkaConnectSpecMetricsConfig
 */
export interface KafkaConnectSpecMetricsConfig {
  /**
   * Metrics type. Only 'jmxPrometheusExporter' supported currently.
   *
   * @schema KafkaConnectSpecMetricsConfig#type
   */
  readonly type: KafkaConnectSpecMetricsConfigType;

  /**
   * ConfigMap entry where the Prometheus JMX Exporter configuration is stored. For details of the structure of this configuration, see the {JMXExporter}.
   *
   * @schema KafkaConnectSpecMetricsConfig#valueFrom
   */
  readonly valueFrom: KafkaConnectSpecMetricsConfigValueFrom;

}

/**
 * Converts an object of type 'KafkaConnectSpecMetricsConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecMetricsConfig(obj: KafkaConnectSpecMetricsConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
    'valueFrom': toJson_KafkaConnectSpecMetricsConfigValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTlsTrustedCertificates
 */
export interface KafkaConnectSpecTlsTrustedCertificates {
  /**
   * The name of the file certificate in the Secret.
   *
   * @schema KafkaConnectSpecTlsTrustedCertificates#certificate
   */
  readonly certificate: string;

  /**
   * The name of the Secret containing the certificate.
   *
   * @schema KafkaConnectSpecTlsTrustedCertificates#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTlsTrustedCertificates' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTlsTrustedCertificates(obj: KafkaConnectSpecTlsTrustedCertificates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificate': obj.certificate,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
 *
 * @schema KafkaConnectSpecAuthenticationAccessToken
 */
export interface KafkaConnectSpecAuthenticationAccessToken {
  /**
   * The key under which the secret value is stored in the Kubernetes Secret.
   *
   * @schema KafkaConnectSpecAuthenticationAccessToken#key
   */
  readonly key: string;

  /**
   * The name of the Kubernetes Secret containing the secret value.
   *
   * @schema KafkaConnectSpecAuthenticationAccessToken#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecAuthenticationAccessToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecAuthenticationAccessToken(obj: KafkaConnectSpecAuthenticationAccessToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to the `Secret` which holds the certificate and private key pair.
 *
 * @schema KafkaConnectSpecAuthenticationCertificateAndKey
 */
export interface KafkaConnectSpecAuthenticationCertificateAndKey {
  /**
   * The name of the file certificate in the Secret.
   *
   * @schema KafkaConnectSpecAuthenticationCertificateAndKey#certificate
   */
  readonly certificate: string;

  /**
   * The name of the private key in the Secret.
   *
   * @schema KafkaConnectSpecAuthenticationCertificateAndKey#key
   */
  readonly key: string;

  /**
   * The name of the Secret containing the certificate.
   *
   * @schema KafkaConnectSpecAuthenticationCertificateAndKey#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecAuthenticationCertificateAndKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecAuthenticationCertificateAndKey(obj: KafkaConnectSpecAuthenticationCertificateAndKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificate': obj.certificate,
    'key': obj.key,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
 *
 * @schema KafkaConnectSpecAuthenticationClientSecret
 */
export interface KafkaConnectSpecAuthenticationClientSecret {
  /**
   * The key under which the secret value is stored in the Kubernetes Secret.
   *
   * @schema KafkaConnectSpecAuthenticationClientSecret#key
   */
  readonly key: string;

  /**
   * The name of the Kubernetes Secret containing the secret value.
   *
   * @schema KafkaConnectSpecAuthenticationClientSecret#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecAuthenticationClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecAuthenticationClientSecret(obj: KafkaConnectSpecAuthenticationClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to the `Secret` which holds the password.
 *
 * @schema KafkaConnectSpecAuthenticationPasswordSecret
 */
export interface KafkaConnectSpecAuthenticationPasswordSecret {
  /**
   * The name of the key in the Secret under which the password is stored.
   *
   * @schema KafkaConnectSpecAuthenticationPasswordSecret#password
   */
  readonly password: string;

  /**
   * The name of the Secret containing the password.
   *
   * @schema KafkaConnectSpecAuthenticationPasswordSecret#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecAuthenticationPasswordSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecAuthenticationPasswordSecret(obj: KafkaConnectSpecAuthenticationPasswordSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'password': obj.password,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
 *
 * @schema KafkaConnectSpecAuthenticationRefreshToken
 */
export interface KafkaConnectSpecAuthenticationRefreshToken {
  /**
   * The key under which the secret value is stored in the Kubernetes Secret.
   *
   * @schema KafkaConnectSpecAuthenticationRefreshToken#key
   */
  readonly key: string;

  /**
   * The name of the Kubernetes Secret containing the secret value.
   *
   * @schema KafkaConnectSpecAuthenticationRefreshToken#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecAuthenticationRefreshToken' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecAuthenticationRefreshToken(obj: KafkaConnectSpecAuthenticationRefreshToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecAuthenticationTlsTrustedCertificates
 */
export interface KafkaConnectSpecAuthenticationTlsTrustedCertificates {
  /**
   * The name of the file certificate in the Secret.
   *
   * @schema KafkaConnectSpecAuthenticationTlsTrustedCertificates#certificate
   */
  readonly certificate: string;

  /**
   * The name of the Secret containing the certificate.
   *
   * @schema KafkaConnectSpecAuthenticationTlsTrustedCertificates#secretName
   */
  readonly secretName: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecAuthenticationTlsTrustedCertificates' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecAuthenticationTlsTrustedCertificates(obj: KafkaConnectSpecAuthenticationTlsTrustedCertificates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certificate': obj.certificate,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authentication type. Currently the supported types are `tls`, `scram-sha-256`, `scram-sha-512`, `plain`, and 'oauth'. `scram-sha-256` and `scram-sha-512` types use SASL SCRAM-SHA-256 and SASL SCRAM-SHA-512 Authentication, respectively. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.
 *
 * @schema KafkaConnectSpecAuthenticationType
 */
export enum KafkaConnectSpecAuthenticationType {
  /** tls */
  TLS = "tls",
  /** scram-sha-256 */
  SCRAM_SHA_256 = "scram-sha-256",
  /** scram-sha-512 */
  SCRAM_SHA_512 = "scram-sha-512",
  /** plain */
  PLAIN = "plain",
  /** oauth */
  OAUTH = "oauth",
}

/**
 * @schema KafkaConnectSpecResourcesClaims
 */
export interface KafkaConnectSpecResourcesClaims {
  /**
   * @schema KafkaConnectSpecResourcesClaims#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecResourcesClaims(obj: KafkaConnectSpecResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecJvmOptionsJavaSystemProperties
 */
export interface KafkaConnectSpecJvmOptionsJavaSystemProperties {
  /**
   * The system property name.
   *
   * @schema KafkaConnectSpecJvmOptionsJavaSystemProperties#name
   */
  readonly name?: string;

  /**
   * The system property value.
   *
   * @schema KafkaConnectSpecJvmOptionsJavaSystemProperties#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecJvmOptionsJavaSystemProperties' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecJvmOptionsJavaSystemProperties(obj: KafkaConnectSpecJvmOptionsJavaSystemProperties | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authentication configuration for connecting to the JMX port.
 *
 * @schema KafkaConnectSpecJmxOptionsAuthentication
 */
export interface KafkaConnectSpecJmxOptionsAuthentication {
  /**
   * Authentication type. Currently the only supported types are `password`.`password` type creates a username and protected port with no TLS.
   *
   * @schema KafkaConnectSpecJmxOptionsAuthentication#type
   */
  readonly type: KafkaConnectSpecJmxOptionsAuthenticationType;

}

/**
 * Converts an object of type 'KafkaConnectSpecJmxOptionsAuthentication' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecJmxOptionsAuthentication(obj: KafkaConnectSpecJmxOptionsAuthentication | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Logging type, must be either 'inline' or 'external'.
 *
 * @schema KafkaConnectSpecLoggingType
 */
export enum KafkaConnectSpecLoggingType {
  /** inline */
  INLINE = "inline",
  /** external */
  EXTERNAL = "external",
}

/**
 * `ConfigMap` entry where the logging configuration is stored.
 *
 * @schema KafkaConnectSpecLoggingValueFrom
 */
export interface KafkaConnectSpecLoggingValueFrom {
  /**
   * Reference to the key in the ConfigMap containing the configuration.
   *
   * @schema KafkaConnectSpecLoggingValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: KafkaConnectSpecLoggingValueFromConfigMapKeyRef;

}

/**
 * Converts an object of type 'KafkaConnectSpecLoggingValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecLoggingValueFrom(obj: KafkaConnectSpecLoggingValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_KafkaConnectSpecLoggingValueFromConfigMapKeyRef(obj.configMapKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Type of the tracing used. Currently the only supported types are `jaeger` for OpenTracing (Jaeger) tracing and `opentelemetry` for OpenTelemetry tracing. The OpenTracing (Jaeger) tracing is deprecated.
 *
 * @schema KafkaConnectSpecTracingType
 */
export enum KafkaConnectSpecTracingType {
  /** jaeger */
  JAEGER = "jaeger",
  /** opentelemetry */
  OPENTELEMETRY = "opentelemetry",
}

/**
 * Template for Kafka Connect `Deployment`.
 *
 * @schema KafkaConnectSpecTemplateDeployment
 */
export interface KafkaConnectSpecTemplateDeployment {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaConnectSpecTemplateDeployment#metadata
   */
  readonly metadata?: KafkaConnectSpecTemplateDeploymentMetadata;

  /**
   * Pod replacement strategy for deployment configuration changes. Valid values are `RollingUpdate` and `Recreate`. Defaults to `RollingUpdate`.
   *
   * @default RollingUpdate`.
   * @schema KafkaConnectSpecTemplateDeployment#deploymentStrategy
   */
  readonly deploymentStrategy?: KafkaConnectSpecTemplateDeploymentDeploymentStrategy;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateDeployment' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateDeployment(obj: KafkaConnectSpecTemplateDeployment | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaConnectSpecTemplateDeploymentMetadata(obj.metadata),
    'deploymentStrategy': obj.deploymentStrategy,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka Connect `StrimziPodSet` resource.
 *
 * @schema KafkaConnectSpecTemplatePodSet
 */
export interface KafkaConnectSpecTemplatePodSet {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaConnectSpecTemplatePodSet#metadata
   */
  readonly metadata?: KafkaConnectSpecTemplatePodSetMetadata;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodSet(obj: KafkaConnectSpecTemplatePodSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaConnectSpecTemplatePodSetMetadata(obj.metadata),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka Connect `Pods`.
 *
 * @schema KafkaConnectSpecTemplatePod
 */
export interface KafkaConnectSpecTemplatePod {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaConnectSpecTemplatePod#metadata
   */
  readonly metadata?: KafkaConnectSpecTemplatePodMetadata;

  /**
   * List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
   *
   * @schema KafkaConnectSpecTemplatePod#imagePullSecrets
   */
  readonly imagePullSecrets?: KafkaConnectSpecTemplatePodImagePullSecrets[];

  /**
   * Configures pod-level security attributes and common container settings.
   *
   * @schema KafkaConnectSpecTemplatePod#securityContext
   */
  readonly securityContext?: KafkaConnectSpecTemplatePodSecurityContext;

  /**
   * The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
   *
   * @default 30 seconds.
   * @schema KafkaConnectSpecTemplatePod#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * The pod's affinity rules.
   *
   * @schema KafkaConnectSpecTemplatePod#affinity
   */
  readonly affinity?: KafkaConnectSpecTemplatePodAffinity;

  /**
   * The pod's tolerations.
   *
   * @schema KafkaConnectSpecTemplatePod#tolerations
   */
  readonly tolerations?: KafkaConnectSpecTemplatePodTolerations[];

  /**
   * The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
   *
   * @schema KafkaConnectSpecTemplatePod#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
   *
   * @schema KafkaConnectSpecTemplatePod#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the Pod's hosts file if specified.
   *
   * @schema KafkaConnectSpecTemplatePod#hostAliases
   */
  readonly hostAliases?: KafkaConnectSpecTemplatePodHostAliases[];

  /**
   * Defines the total amount (for example `1Gi`) of local storage required for temporary EmptyDir volume (`/tmp`). Default value is `5Mi`.
   *
   * @schema KafkaConnectSpecTemplatePod#tmpDirSizeLimit
   */
  readonly tmpDirSizeLimit?: string;

  /**
   * Indicates whether information about services should be injected into Pod's environment variables.
   *
   * @schema KafkaConnectSpecTemplatePod#enableServiceLinks
   */
  readonly enableServiceLinks?: boolean;

  /**
   * The pod's topology spread constraints.
   *
   * @schema KafkaConnectSpecTemplatePod#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: KafkaConnectSpecTemplatePodTopologySpreadConstraints[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePod' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePod(obj: KafkaConnectSpecTemplatePod | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaConnectSpecTemplatePodMetadata(obj.metadata),
    'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_KafkaConnectSpecTemplatePodImagePullSecrets(y)),
    'securityContext': toJson_KafkaConnectSpecTemplatePodSecurityContext(obj.securityContext),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'affinity': toJson_KafkaConnectSpecTemplatePodAffinity(obj.affinity),
    'tolerations': obj.tolerations?.map(y => toJson_KafkaConnectSpecTemplatePodTolerations(y)),
    'priorityClassName': obj.priorityClassName,
    'schedulerName': obj.schedulerName,
    'hostAliases': obj.hostAliases?.map(y => toJson_KafkaConnectSpecTemplatePodHostAliases(y)),
    'tmpDirSizeLimit': obj.tmpDirSizeLimit,
    'enableServiceLinks': obj.enableServiceLinks,
    'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => toJson_KafkaConnectSpecTemplatePodTopologySpreadConstraints(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka Connect API `Service`.
 *
 * @schema KafkaConnectSpecTemplateApiService
 */
export interface KafkaConnectSpecTemplateApiService {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaConnectSpecTemplateApiService#metadata
   */
  readonly metadata?: KafkaConnectSpecTemplateApiServiceMetadata;

  /**
   * Specifies the IP Family Policy used by the service. Available options are `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a single IP family. `PreferDualStack` is for two IP families on dual-stack configured clusters or a single IP family on single-stack clusters. `RequireDualStack` fails unless there are two IP families on dual-stack configured clusters. If unspecified, Kubernetes will choose the default value based on the service type. Available on Kubernetes 1.20 and newer.
   *
   * @schema KafkaConnectSpecTemplateApiService#ipFamilyPolicy
   */
  readonly ipFamilyPolicy?: KafkaConnectSpecTemplateApiServiceIpFamilyPolicy;

  /**
   * Specifies the IP Families used by the service. Available options are `IPv4` and `IPv6. If unspecified, Kubernetes will choose the default value based on the `ipFamilyPolicy` setting. Available on Kubernetes 1.20 and newer.
   *
   * @schema KafkaConnectSpecTemplateApiService#ipFamilies
   */
  readonly ipFamilies?: KafkaConnectSpecTemplateApiServiceIpFamilies[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateApiService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateApiService(obj: KafkaConnectSpecTemplateApiService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaConnectSpecTemplateApiServiceMetadata(obj.metadata),
    'ipFamilyPolicy': obj.ipFamilyPolicy,
    'ipFamilies': obj.ipFamilies?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka Connect headless `Service`.
 *
 * @schema KafkaConnectSpecTemplateHeadlessService
 */
export interface KafkaConnectSpecTemplateHeadlessService {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaConnectSpecTemplateHeadlessService#metadata
   */
  readonly metadata?: KafkaConnectSpecTemplateHeadlessServiceMetadata;

  /**
   * Specifies the IP Family Policy used by the service. Available options are `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a single IP family. `PreferDualStack` is for two IP families on dual-stack configured clusters or a single IP family on single-stack clusters. `RequireDualStack` fails unless there are two IP families on dual-stack configured clusters. If unspecified, Kubernetes will choose the default value based on the service type. Available on Kubernetes 1.20 and newer.
   *
   * @schema KafkaConnectSpecTemplateHeadlessService#ipFamilyPolicy
   */
  readonly ipFamilyPolicy?: KafkaConnectSpecTemplateHeadlessServiceIpFamilyPolicy;

  /**
   * Specifies the IP Families used by the service. Available options are `IPv4` and `IPv6. If unspecified, Kubernetes will choose the default value based on the `ipFamilyPolicy` setting. Available on Kubernetes 1.20 and newer.
   *
   * @schema KafkaConnectSpecTemplateHeadlessService#ipFamilies
   */
  readonly ipFamilies?: KafkaConnectSpecTemplateHeadlessServiceIpFamilies[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateHeadlessService' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateHeadlessService(obj: KafkaConnectSpecTemplateHeadlessService | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaConnectSpecTemplateHeadlessServiceMetadata(obj.metadata),
    'ipFamilyPolicy': obj.ipFamilyPolicy,
    'ipFamilies': obj.ipFamilies?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for the Kafka Connect container.
 *
 * @schema KafkaConnectSpecTemplateConnectContainer
 */
export interface KafkaConnectSpecTemplateConnectContainer {
  /**
   * Environment variables which should be applied to the container.
   *
   * @schema KafkaConnectSpecTemplateConnectContainer#env
   */
  readonly env?: KafkaConnectSpecTemplateConnectContainerEnv[];

  /**
   * Security context for the container.
   *
   * @schema KafkaConnectSpecTemplateConnectContainer#securityContext
   */
  readonly securityContext?: KafkaConnectSpecTemplateConnectContainerSecurityContext;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateConnectContainer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateConnectContainer(obj: KafkaConnectSpecTemplateConnectContainer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'env': obj.env?.map(y => toJson_KafkaConnectSpecTemplateConnectContainerEnv(y)),
    'securityContext': toJson_KafkaConnectSpecTemplateConnectContainerSecurityContext(obj.securityContext),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for the Kafka init container.
 *
 * @schema KafkaConnectSpecTemplateInitContainer
 */
export interface KafkaConnectSpecTemplateInitContainer {
  /**
   * Environment variables which should be applied to the container.
   *
   * @schema KafkaConnectSpecTemplateInitContainer#env
   */
  readonly env?: KafkaConnectSpecTemplateInitContainerEnv[];

  /**
   * Security context for the container.
   *
   * @schema KafkaConnectSpecTemplateInitContainer#securityContext
   */
  readonly securityContext?: KafkaConnectSpecTemplateInitContainerSecurityContext;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateInitContainer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateInitContainer(obj: KafkaConnectSpecTemplateInitContainer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'env': obj.env?.map(y => toJson_KafkaConnectSpecTemplateInitContainerEnv(y)),
    'securityContext': toJson_KafkaConnectSpecTemplateInitContainerSecurityContext(obj.securityContext),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka Connect `PodDisruptionBudget`.
 *
 * @schema KafkaConnectSpecTemplatePodDisruptionBudget
 */
export interface KafkaConnectSpecTemplatePodDisruptionBudget {
  /**
   * Metadata to apply to the `PodDisruptionBudgetTemplate` resource.
   *
   * @schema KafkaConnectSpecTemplatePodDisruptionBudget#metadata
   */
  readonly metadata?: KafkaConnectSpecTemplatePodDisruptionBudgetMetadata;

  /**
   * Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
   *
   * @default 1.
   * @schema KafkaConnectSpecTemplatePodDisruptionBudget#maxUnavailable
   */
  readonly maxUnavailable?: number;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodDisruptionBudget' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodDisruptionBudget(obj: KafkaConnectSpecTemplatePodDisruptionBudget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaConnectSpecTemplatePodDisruptionBudgetMetadata(obj.metadata),
    'maxUnavailable': obj.maxUnavailable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for the Kafka Connect service account.
 *
 * @schema KafkaConnectSpecTemplateServiceAccount
 */
export interface KafkaConnectSpecTemplateServiceAccount {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaConnectSpecTemplateServiceAccount#metadata
   */
  readonly metadata?: KafkaConnectSpecTemplateServiceAccountMetadata;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateServiceAccount' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateServiceAccount(obj: KafkaConnectSpecTemplateServiceAccount | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaConnectSpecTemplateServiceAccountMetadata(obj.metadata),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for the Kafka Connect ClusterRoleBinding.
 *
 * @schema KafkaConnectSpecTemplateClusterRoleBinding
 */
export interface KafkaConnectSpecTemplateClusterRoleBinding {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaConnectSpecTemplateClusterRoleBinding#metadata
   */
  readonly metadata?: KafkaConnectSpecTemplateClusterRoleBindingMetadata;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateClusterRoleBinding' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateClusterRoleBinding(obj: KafkaConnectSpecTemplateClusterRoleBinding | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaConnectSpecTemplateClusterRoleBindingMetadata(obj.metadata),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka Connect Build `Pods`. The build pod is used only on Kubernetes.
 *
 * @schema KafkaConnectSpecTemplateBuildPod
 */
export interface KafkaConnectSpecTemplateBuildPod {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaConnectSpecTemplateBuildPod#metadata
   */
  readonly metadata?: KafkaConnectSpecTemplateBuildPodMetadata;

  /**
   * List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
   *
   * @schema KafkaConnectSpecTemplateBuildPod#imagePullSecrets
   */
  readonly imagePullSecrets?: KafkaConnectSpecTemplateBuildPodImagePullSecrets[];

  /**
   * Configures pod-level security attributes and common container settings.
   *
   * @schema KafkaConnectSpecTemplateBuildPod#securityContext
   */
  readonly securityContext?: KafkaConnectSpecTemplateBuildPodSecurityContext;

  /**
   * The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
   *
   * @default 30 seconds.
   * @schema KafkaConnectSpecTemplateBuildPod#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * The pod's affinity rules.
   *
   * @schema KafkaConnectSpecTemplateBuildPod#affinity
   */
  readonly affinity?: KafkaConnectSpecTemplateBuildPodAffinity;

  /**
   * The pod's tolerations.
   *
   * @schema KafkaConnectSpecTemplateBuildPod#tolerations
   */
  readonly tolerations?: KafkaConnectSpecTemplateBuildPodTolerations[];

  /**
   * The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
   *
   * @schema KafkaConnectSpecTemplateBuildPod#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
   *
   * @schema KafkaConnectSpecTemplateBuildPod#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the Pod's hosts file if specified.
   *
   * @schema KafkaConnectSpecTemplateBuildPod#hostAliases
   */
  readonly hostAliases?: KafkaConnectSpecTemplateBuildPodHostAliases[];

  /**
   * Defines the total amount (for example `1Gi`) of local storage required for temporary EmptyDir volume (`/tmp`). Default value is `5Mi`.
   *
   * @schema KafkaConnectSpecTemplateBuildPod#tmpDirSizeLimit
   */
  readonly tmpDirSizeLimit?: string;

  /**
   * Indicates whether information about services should be injected into Pod's environment variables.
   *
   * @schema KafkaConnectSpecTemplateBuildPod#enableServiceLinks
   */
  readonly enableServiceLinks?: boolean;

  /**
   * The pod's topology spread constraints.
   *
   * @schema KafkaConnectSpecTemplateBuildPod#topologySpreadConstraints
   */
  readonly topologySpreadConstraints?: KafkaConnectSpecTemplateBuildPodTopologySpreadConstraints[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPod' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPod(obj: KafkaConnectSpecTemplateBuildPod | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaConnectSpecTemplateBuildPodMetadata(obj.metadata),
    'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_KafkaConnectSpecTemplateBuildPodImagePullSecrets(y)),
    'securityContext': toJson_KafkaConnectSpecTemplateBuildPodSecurityContext(obj.securityContext),
    'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
    'affinity': toJson_KafkaConnectSpecTemplateBuildPodAffinity(obj.affinity),
    'tolerations': obj.tolerations?.map(y => toJson_KafkaConnectSpecTemplateBuildPodTolerations(y)),
    'priorityClassName': obj.priorityClassName,
    'schedulerName': obj.schedulerName,
    'hostAliases': obj.hostAliases?.map(y => toJson_KafkaConnectSpecTemplateBuildPodHostAliases(y)),
    'tmpDirSizeLimit': obj.tmpDirSizeLimit,
    'enableServiceLinks': obj.enableServiceLinks,
    'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => toJson_KafkaConnectSpecTemplateBuildPodTopologySpreadConstraints(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for the Kafka Connect Build container. The build container is used only on Kubernetes.
 *
 * @schema KafkaConnectSpecTemplateBuildContainer
 */
export interface KafkaConnectSpecTemplateBuildContainer {
  /**
   * Environment variables which should be applied to the container.
   *
   * @schema KafkaConnectSpecTemplateBuildContainer#env
   */
  readonly env?: KafkaConnectSpecTemplateBuildContainerEnv[];

  /**
   * Security context for the container.
   *
   * @schema KafkaConnectSpecTemplateBuildContainer#securityContext
   */
  readonly securityContext?: KafkaConnectSpecTemplateBuildContainerSecurityContext;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildContainer' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildContainer(obj: KafkaConnectSpecTemplateBuildContainer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'env': obj.env?.map(y => toJson_KafkaConnectSpecTemplateBuildContainerEnv(y)),
    'securityContext': toJson_KafkaConnectSpecTemplateBuildContainerSecurityContext(obj.securityContext),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for the Kafka Connect BuildConfig used to build new container images. The BuildConfig is used only on OpenShift.
 *
 * @schema KafkaConnectSpecTemplateBuildConfig
 */
export interface KafkaConnectSpecTemplateBuildConfig {
  /**
   * Metadata to apply to the `PodDisruptionBudgetTemplate` resource.
   *
   * @schema KafkaConnectSpecTemplateBuildConfig#metadata
   */
  readonly metadata?: KafkaConnectSpecTemplateBuildConfigMetadata;

  /**
   * Container Registry Secret with the credentials for pulling the base image.
   *
   * @schema KafkaConnectSpecTemplateBuildConfig#pullSecret
   */
  readonly pullSecret?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildConfig' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildConfig(obj: KafkaConnectSpecTemplateBuildConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaConnectSpecTemplateBuildConfigMetadata(obj.metadata),
    'pullSecret': obj.pullSecret,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for the Kafka Connect Build service account.
 *
 * @schema KafkaConnectSpecTemplateBuildServiceAccount
 */
export interface KafkaConnectSpecTemplateBuildServiceAccount {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaConnectSpecTemplateBuildServiceAccount#metadata
   */
  readonly metadata?: KafkaConnectSpecTemplateBuildServiceAccountMetadata;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildServiceAccount' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildServiceAccount(obj: KafkaConnectSpecTemplateBuildServiceAccount | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaConnectSpecTemplateBuildServiceAccountMetadata(obj.metadata),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Template for Secret of the Kafka Connect Cluster JMX authentication.
 *
 * @schema KafkaConnectSpecTemplateJmxSecret
 */
export interface KafkaConnectSpecTemplateJmxSecret {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaConnectSpecTemplateJmxSecret#metadata
   */
  readonly metadata?: KafkaConnectSpecTemplateJmxSecretMetadata;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateJmxSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateJmxSecret(obj: KafkaConnectSpecTemplateJmxSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': toJson_KafkaConnectSpecTemplateJmxSecretMetadata(obj.metadata),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecExternalConfigurationEnv
 */
export interface KafkaConnectSpecExternalConfigurationEnv {
  /**
   * Name of the environment variable which will be passed to the Kafka Connect pods. The name of the environment variable cannot start with `KAFKA_` or `STRIMZI_`.
   *
   * @schema KafkaConnectSpecExternalConfigurationEnv#name
   */
  readonly name: string;

  /**
   * Value of the environment variable which will be passed to the Kafka Connect pods. It can be passed either as a reference to Secret or ConfigMap field. The field has to specify exactly one Secret or ConfigMap.
   *
   * @schema KafkaConnectSpecExternalConfigurationEnv#valueFrom
   */
  readonly valueFrom: KafkaConnectSpecExternalConfigurationEnvValueFrom;

}

/**
 * Converts an object of type 'KafkaConnectSpecExternalConfigurationEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecExternalConfigurationEnv(obj: KafkaConnectSpecExternalConfigurationEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'valueFrom': toJson_KafkaConnectSpecExternalConfigurationEnvValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecExternalConfigurationVolumes
 */
export interface KafkaConnectSpecExternalConfigurationVolumes {
  /**
   * Reference to a key in a ConfigMap. Exactly one Secret or ConfigMap has to be specified.
   *
   * @schema KafkaConnectSpecExternalConfigurationVolumes#configMap
   */
  readonly configMap?: KafkaConnectSpecExternalConfigurationVolumesConfigMap;

  /**
   * Name of the volume which will be added to the Kafka Connect pods.
   *
   * @schema KafkaConnectSpecExternalConfigurationVolumes#name
   */
  readonly name: string;

  /**
   * Reference to a key in a Secret. Exactly one Secret or ConfigMap has to be specified.
   *
   * @schema KafkaConnectSpecExternalConfigurationVolumes#secret
   */
  readonly secret?: KafkaConnectSpecExternalConfigurationVolumesSecret;

}

/**
 * Converts an object of type 'KafkaConnectSpecExternalConfigurationVolumes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecExternalConfigurationVolumes(obj: KafkaConnectSpecExternalConfigurationVolumes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_KafkaConnectSpecExternalConfigurationVolumesConfigMap(obj.configMap),
    'name': obj.name,
    'secret': toJson_KafkaConnectSpecExternalConfigurationVolumesSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configures where should the newly built image be stored. Required.
 *
 * @schema KafkaConnectSpecBuildOutput
 */
export interface KafkaConnectSpecBuildOutput {
  /**
   * Configures additional options which will be passed to the Kaniko executor when building the new Connect image. Allowed options are: --customPlatform, --insecure, --insecure-pull, --insecure-registry, --log-format, --log-timestamp, --registry-mirror, --reproducible, --single-snapshot, --skip-tls-verify, --skip-tls-verify-pull, --skip-tls-verify-registry, --verbosity, --snapshotMode, --use-new-run. These options will be used only on Kubernetes where the Kaniko executor is used. They will be ignored on OpenShift. The options are described in the link:https://github.com/GoogleContainerTools/kaniko[Kaniko GitHub repository^]. Changing this field does not trigger new build of the Kafka Connect image.
   *
   * @schema KafkaConnectSpecBuildOutput#additionalKanikoOptions
   */
  readonly additionalKanikoOptions?: string[];

  /**
   * The name of the image which will be built. Required.
   *
   * @schema KafkaConnectSpecBuildOutput#image
   */
  readonly image: string;

  /**
   * Container Registry Secret with the credentials for pushing the newly built image.
   *
   * @schema KafkaConnectSpecBuildOutput#pushSecret
   */
  readonly pushSecret?: string;

  /**
   * Output type. Must be either `docker` for pushing the newly build image to Docker compatible registry or `imagestream` for pushing the image to OpenShift ImageStream. Required.
   *
   * @schema KafkaConnectSpecBuildOutput#type
   */
  readonly type: KafkaConnectSpecBuildOutputType;

}

/**
 * Converts an object of type 'KafkaConnectSpecBuildOutput' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecBuildOutput(obj: KafkaConnectSpecBuildOutput | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalKanikoOptions': obj.additionalKanikoOptions?.map(y => y),
    'image': obj.image,
    'pushSecret': obj.pushSecret,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CPU and memory resources to reserve for the build.
 *
 * @schema KafkaConnectSpecBuildResources
 */
export interface KafkaConnectSpecBuildResources {
  /**
   * @schema KafkaConnectSpecBuildResources#claims
   */
  readonly claims?: KafkaConnectSpecBuildResourcesClaims[];

  /**
   * @schema KafkaConnectSpecBuildResources#limits
   */
  readonly limits?: any;

  /**
   * @schema KafkaConnectSpecBuildResources#requests
   */
  readonly requests?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecBuildResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecBuildResources(obj: KafkaConnectSpecBuildResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'claims': obj.claims?.map(y => toJson_KafkaConnectSpecBuildResourcesClaims(y)),
    'limits': obj.limits,
    'requests': obj.requests,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecBuildPlugins
 */
export interface KafkaConnectSpecBuildPlugins {
  /**
   * The unique name of the connector plugin. Will be used to generate the path where the connector artifacts will be stored. The name has to be unique within the KafkaConnect resource. The name has to follow the following pattern: `^[a-z][-_a-z0-9]*[a-z]$`. Required.
   *
   * @schema KafkaConnectSpecBuildPlugins#name
   */
  readonly name: string;

  /**
   * List of artifacts which belong to this connector plugin. Required.
   *
   * @schema KafkaConnectSpecBuildPlugins#artifacts
   */
  readonly artifacts: KafkaConnectSpecBuildPluginsArtifacts[];

}

/**
 * Converts an object of type 'KafkaConnectSpecBuildPlugins' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecBuildPlugins(obj: KafkaConnectSpecBuildPlugins | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'artifacts': obj.artifacts?.map(y => toJson_KafkaConnectSpecBuildPluginsArtifacts(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metrics type. Only 'jmxPrometheusExporter' supported currently.
 *
 * @schema KafkaConnectSpecMetricsConfigType
 */
export enum KafkaConnectSpecMetricsConfigType {
  /** jmxPrometheusExporter */
  JMX_PROMETHEUS_EXPORTER = "jmxPrometheusExporter",
}

/**
 * ConfigMap entry where the Prometheus JMX Exporter configuration is stored. For details of the structure of this configuration, see the {JMXExporter}.
 *
 * @schema KafkaConnectSpecMetricsConfigValueFrom
 */
export interface KafkaConnectSpecMetricsConfigValueFrom {
  /**
   * Reference to the key in the ConfigMap containing the configuration.
   *
   * @schema KafkaConnectSpecMetricsConfigValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: KafkaConnectSpecMetricsConfigValueFromConfigMapKeyRef;

}

/**
 * Converts an object of type 'KafkaConnectSpecMetricsConfigValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecMetricsConfigValueFrom(obj: KafkaConnectSpecMetricsConfigValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_KafkaConnectSpecMetricsConfigValueFromConfigMapKeyRef(obj.configMapKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authentication type. Currently the only supported types are `password`.`password` type creates a username and protected port with no TLS.
 *
 * @schema KafkaConnectSpecJmxOptionsAuthenticationType
 */
export enum KafkaConnectSpecJmxOptionsAuthenticationType {
  /** password */
  PASSWORD = "password",
}

/**
 * Reference to the key in the ConfigMap containing the configuration.
 *
 * @schema KafkaConnectSpecLoggingValueFromConfigMapKeyRef
 */
export interface KafkaConnectSpecLoggingValueFromConfigMapKeyRef {
  /**
   * @schema KafkaConnectSpecLoggingValueFromConfigMapKeyRef#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecLoggingValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * @schema KafkaConnectSpecLoggingValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'KafkaConnectSpecLoggingValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecLoggingValueFromConfigMapKeyRef(obj: KafkaConnectSpecLoggingValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaConnectSpecTemplateDeploymentMetadata
 */
export interface KafkaConnectSpecTemplateDeploymentMetadata {
  /**
   * Labels added to the Kubernetes resource.
   *
   * @schema KafkaConnectSpecTemplateDeploymentMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the Kubernetes resource.
   *
   * @schema KafkaConnectSpecTemplateDeploymentMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateDeploymentMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateDeploymentMetadata(obj: KafkaConnectSpecTemplateDeploymentMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Pod replacement strategy for deployment configuration changes. Valid values are `RollingUpdate` and `Recreate`. Defaults to `RollingUpdate`.
 *
 * @default RollingUpdate`.
 * @schema KafkaConnectSpecTemplateDeploymentDeploymentStrategy
 */
export enum KafkaConnectSpecTemplateDeploymentDeploymentStrategy {
  /** RollingUpdate */
  ROLLING_UPDATE = "RollingUpdate",
  /** Recreate */
  RECREATE = "Recreate",
}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaConnectSpecTemplatePodSetMetadata
 */
export interface KafkaConnectSpecTemplatePodSetMetadata {
  /**
   * Labels added to the Kubernetes resource.
   *
   * @schema KafkaConnectSpecTemplatePodSetMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the Kubernetes resource.
   *
   * @schema KafkaConnectSpecTemplatePodSetMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodSetMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodSetMetadata(obj: KafkaConnectSpecTemplatePodSetMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaConnectSpecTemplatePodMetadata
 */
export interface KafkaConnectSpecTemplatePodMetadata {
  /**
   * Labels added to the Kubernetes resource.
   *
   * @schema KafkaConnectSpecTemplatePodMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the Kubernetes resource.
   *
   * @schema KafkaConnectSpecTemplatePodMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodMetadata(obj: KafkaConnectSpecTemplatePodMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodImagePullSecrets
 */
export interface KafkaConnectSpecTemplatePodImagePullSecrets {
  /**
   * @schema KafkaConnectSpecTemplatePodImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodImagePullSecrets(obj: KafkaConnectSpecTemplatePodImagePullSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configures pod-level security attributes and common container settings.
 *
 * @schema KafkaConnectSpecTemplatePodSecurityContext
 */
export interface KafkaConnectSpecTemplatePodSecurityContext {
  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaConnectSpecTemplatePodSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContext#seccompProfile
   */
  readonly seccompProfile?: KafkaConnectSpecTemplatePodSecurityContextSeccompProfile;

  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContext#sysctls
   */
  readonly sysctls?: KafkaConnectSpecTemplatePodSecurityContextSysctls[];

  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaConnectSpecTemplatePodSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodSecurityContext(obj: KafkaConnectSpecTemplatePodSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsGroup': obj.fsGroup,
    'fsGroupChangePolicy': obj.fsGroupChangePolicy,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_KafkaConnectSpecTemplatePodSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_KafkaConnectSpecTemplatePodSecurityContextSeccompProfile(obj.seccompProfile),
    'supplementalGroups': obj.supplementalGroups?.map(y => y),
    'sysctls': obj.sysctls?.map(y => toJson_KafkaConnectSpecTemplatePodSecurityContextSysctls(y)),
    'windowsOptions': toJson_KafkaConnectSpecTemplatePodSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The pod's affinity rules.
 *
 * @schema KafkaConnectSpecTemplatePodAffinity
 */
export interface KafkaConnectSpecTemplatePodAffinity {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinity#nodeAffinity
   */
  readonly nodeAffinity?: KafkaConnectSpecTemplatePodAffinityNodeAffinity;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinity#podAffinity
   */
  readonly podAffinity?: KafkaConnectSpecTemplatePodAffinityPodAffinity;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: KafkaConnectSpecTemplatePodAffinityPodAntiAffinity;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinity(obj: KafkaConnectSpecTemplatePodAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeAffinity': toJson_KafkaConnectSpecTemplatePodAffinityNodeAffinity(obj.nodeAffinity),
    'podAffinity': toJson_KafkaConnectSpecTemplatePodAffinityPodAffinity(obj.podAffinity),
    'podAntiAffinity': toJson_KafkaConnectSpecTemplatePodAffinityPodAntiAffinity(obj.podAntiAffinity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodTolerations
 */
export interface KafkaConnectSpecTemplatePodTolerations {
  /**
   * @schema KafkaConnectSpecTemplatePodTolerations#effect
   */
  readonly effect?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodTolerations#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodTolerations#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * @schema KafkaConnectSpecTemplatePodTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodTolerations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodTolerations(obj: KafkaConnectSpecTemplatePodTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodHostAliases
 */
export interface KafkaConnectSpecTemplatePodHostAliases {
  /**
   * @schema KafkaConnectSpecTemplatePodHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * @schema KafkaConnectSpecTemplatePodHostAliases#ip
   */
  readonly ip?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodHostAliases' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodHostAliases(obj: KafkaConnectSpecTemplatePodHostAliases | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostnames': obj.hostnames?.map(y => y),
    'ip': obj.ip,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodTopologySpreadConstraints
 */
export interface KafkaConnectSpecTemplatePodTopologySpreadConstraints {
  /**
   * @schema KafkaConnectSpecTemplatePodTopologySpreadConstraints#labelSelector
   */
  readonly labelSelector?: KafkaConnectSpecTemplatePodTopologySpreadConstraintsLabelSelector;

  /**
   * @schema KafkaConnectSpecTemplatePodTopologySpreadConstraints#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * @schema KafkaConnectSpecTemplatePodTopologySpreadConstraints#maxSkew
   */
  readonly maxSkew?: number;

  /**
   * @schema KafkaConnectSpecTemplatePodTopologySpreadConstraints#minDomains
   */
  readonly minDomains?: number;

  /**
   * @schema KafkaConnectSpecTemplatePodTopologySpreadConstraints#nodeAffinityPolicy
   */
  readonly nodeAffinityPolicy?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodTopologySpreadConstraints#nodeTaintsPolicy
   */
  readonly nodeTaintsPolicy?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodTopologySpreadConstraints#topologyKey
   */
  readonly topologyKey?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodTopologySpreadConstraints#whenUnsatisfiable
   */
  readonly whenUnsatisfiable?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodTopologySpreadConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodTopologySpreadConstraints(obj: KafkaConnectSpecTemplatePodTopologySpreadConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaConnectSpecTemplatePodTopologySpreadConstraintsLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'maxSkew': obj.maxSkew,
    'minDomains': obj.minDomains,
    'nodeAffinityPolicy': obj.nodeAffinityPolicy,
    'nodeTaintsPolicy': obj.nodeTaintsPolicy,
    'topologyKey': obj.topologyKey,
    'whenUnsatisfiable': obj.whenUnsatisfiable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaConnectSpecTemplateApiServiceMetadata
 */
export interface KafkaConnectSpecTemplateApiServiceMetadata {
  /**
   * Labels added to the Kubernetes resource.
   *
   * @schema KafkaConnectSpecTemplateApiServiceMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the Kubernetes resource.
   *
   * @schema KafkaConnectSpecTemplateApiServiceMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateApiServiceMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateApiServiceMetadata(obj: KafkaConnectSpecTemplateApiServiceMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the IP Family Policy used by the service. Available options are `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a single IP family. `PreferDualStack` is for two IP families on dual-stack configured clusters or a single IP family on single-stack clusters. `RequireDualStack` fails unless there are two IP families on dual-stack configured clusters. If unspecified, Kubernetes will choose the default value based on the service type. Available on Kubernetes 1.20 and newer.
 *
 * @schema KafkaConnectSpecTemplateApiServiceIpFamilyPolicy
 */
export enum KafkaConnectSpecTemplateApiServiceIpFamilyPolicy {
  /** SingleStack */
  SINGLE_STACK = "SingleStack",
  /** PreferDualStack */
  PREFER_DUAL_STACK = "PreferDualStack",
  /** RequireDualStack */
  REQUIRE_DUAL_STACK = "RequireDualStack",
}

/**
 * @schema KafkaConnectSpecTemplateApiServiceIpFamilies
 */
export enum KafkaConnectSpecTemplateApiServiceIpFamilies {
  /** IPv4 */
  I_PV4 = "IPv4",
  /** IPv6 */
  I_PV6 = "IPv6",
}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaConnectSpecTemplateHeadlessServiceMetadata
 */
export interface KafkaConnectSpecTemplateHeadlessServiceMetadata {
  /**
   * Labels added to the Kubernetes resource.
   *
   * @schema KafkaConnectSpecTemplateHeadlessServiceMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the Kubernetes resource.
   *
   * @schema KafkaConnectSpecTemplateHeadlessServiceMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateHeadlessServiceMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateHeadlessServiceMetadata(obj: KafkaConnectSpecTemplateHeadlessServiceMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specifies the IP Family Policy used by the service. Available options are `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a single IP family. `PreferDualStack` is for two IP families on dual-stack configured clusters or a single IP family on single-stack clusters. `RequireDualStack` fails unless there are two IP families on dual-stack configured clusters. If unspecified, Kubernetes will choose the default value based on the service type. Available on Kubernetes 1.20 and newer.
 *
 * @schema KafkaConnectSpecTemplateHeadlessServiceIpFamilyPolicy
 */
export enum KafkaConnectSpecTemplateHeadlessServiceIpFamilyPolicy {
  /** SingleStack */
  SINGLE_STACK = "SingleStack",
  /** PreferDualStack */
  PREFER_DUAL_STACK = "PreferDualStack",
  /** RequireDualStack */
  REQUIRE_DUAL_STACK = "RequireDualStack",
}

/**
 * @schema KafkaConnectSpecTemplateHeadlessServiceIpFamilies
 */
export enum KafkaConnectSpecTemplateHeadlessServiceIpFamilies {
  /** IPv4 */
  I_PV4 = "IPv4",
  /** IPv6 */
  I_PV6 = "IPv6",
}

/**
 * @schema KafkaConnectSpecTemplateConnectContainerEnv
 */
export interface KafkaConnectSpecTemplateConnectContainerEnv {
  /**
   * The environment variable key.
   *
   * @schema KafkaConnectSpecTemplateConnectContainerEnv#name
   */
  readonly name?: string;

  /**
   * The environment variable value.
   *
   * @schema KafkaConnectSpecTemplateConnectContainerEnv#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateConnectContainerEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateConnectContainerEnv(obj: KafkaConnectSpecTemplateConnectContainerEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Security context for the container.
 *
 * @schema KafkaConnectSpecTemplateConnectContainerSecurityContext
 */
export interface KafkaConnectSpecTemplateConnectContainerSecurityContext {
  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContext#capabilities
   */
  readonly capabilities?: KafkaConnectSpecTemplateConnectContainerSecurityContextCapabilities;

  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaConnectSpecTemplateConnectContainerSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContext#seccompProfile
   */
  readonly seccompProfile?: KafkaConnectSpecTemplateConnectContainerSecurityContextSeccompProfile;

  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaConnectSpecTemplateConnectContainerSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateConnectContainerSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateConnectContainerSecurityContext(obj: KafkaConnectSpecTemplateConnectContainerSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
    'capabilities': toJson_KafkaConnectSpecTemplateConnectContainerSecurityContextCapabilities(obj.capabilities),
    'privileged': obj.privileged,
    'procMount': obj.procMount,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_KafkaConnectSpecTemplateConnectContainerSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_KafkaConnectSpecTemplateConnectContainerSecurityContextSeccompProfile(obj.seccompProfile),
    'windowsOptions': toJson_KafkaConnectSpecTemplateConnectContainerSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateInitContainerEnv
 */
export interface KafkaConnectSpecTemplateInitContainerEnv {
  /**
   * The environment variable key.
   *
   * @schema KafkaConnectSpecTemplateInitContainerEnv#name
   */
  readonly name?: string;

  /**
   * The environment variable value.
   *
   * @schema KafkaConnectSpecTemplateInitContainerEnv#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateInitContainerEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateInitContainerEnv(obj: KafkaConnectSpecTemplateInitContainerEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Security context for the container.
 *
 * @schema KafkaConnectSpecTemplateInitContainerSecurityContext
 */
export interface KafkaConnectSpecTemplateInitContainerSecurityContext {
  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContext#capabilities
   */
  readonly capabilities?: KafkaConnectSpecTemplateInitContainerSecurityContextCapabilities;

  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaConnectSpecTemplateInitContainerSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContext#seccompProfile
   */
  readonly seccompProfile?: KafkaConnectSpecTemplateInitContainerSecurityContextSeccompProfile;

  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaConnectSpecTemplateInitContainerSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateInitContainerSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateInitContainerSecurityContext(obj: KafkaConnectSpecTemplateInitContainerSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
    'capabilities': toJson_KafkaConnectSpecTemplateInitContainerSecurityContextCapabilities(obj.capabilities),
    'privileged': obj.privileged,
    'procMount': obj.procMount,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_KafkaConnectSpecTemplateInitContainerSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_KafkaConnectSpecTemplateInitContainerSecurityContextSeccompProfile(obj.seccompProfile),
    'windowsOptions': toJson_KafkaConnectSpecTemplateInitContainerSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata to apply to the `PodDisruptionBudgetTemplate` resource.
 *
 * @schema KafkaConnectSpecTemplatePodDisruptionBudgetMetadata
 */
export interface KafkaConnectSpecTemplatePodDisruptionBudgetMetadata {
  /**
   * Labels added to the Kubernetes resource.
   *
   * @schema KafkaConnectSpecTemplatePodDisruptionBudgetMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the Kubernetes resource.
   *
   * @schema KafkaConnectSpecTemplatePodDisruptionBudgetMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodDisruptionBudgetMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodDisruptionBudgetMetadata(obj: KafkaConnectSpecTemplatePodDisruptionBudgetMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaConnectSpecTemplateServiceAccountMetadata
 */
export interface KafkaConnectSpecTemplateServiceAccountMetadata {
  /**
   * Labels added to the Kubernetes resource.
   *
   * @schema KafkaConnectSpecTemplateServiceAccountMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the Kubernetes resource.
   *
   * @schema KafkaConnectSpecTemplateServiceAccountMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateServiceAccountMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateServiceAccountMetadata(obj: KafkaConnectSpecTemplateServiceAccountMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaConnectSpecTemplateClusterRoleBindingMetadata
 */
export interface KafkaConnectSpecTemplateClusterRoleBindingMetadata {
  /**
   * Labels added to the Kubernetes resource.
   *
   * @schema KafkaConnectSpecTemplateClusterRoleBindingMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the Kubernetes resource.
   *
   * @schema KafkaConnectSpecTemplateClusterRoleBindingMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateClusterRoleBindingMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateClusterRoleBindingMetadata(obj: KafkaConnectSpecTemplateClusterRoleBindingMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaConnectSpecTemplateBuildPodMetadata
 */
export interface KafkaConnectSpecTemplateBuildPodMetadata {
  /**
   * Labels added to the Kubernetes resource.
   *
   * @schema KafkaConnectSpecTemplateBuildPodMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the Kubernetes resource.
   *
   * @schema KafkaConnectSpecTemplateBuildPodMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodMetadata(obj: KafkaConnectSpecTemplateBuildPodMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodImagePullSecrets
 */
export interface KafkaConnectSpecTemplateBuildPodImagePullSecrets {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodImagePullSecrets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodImagePullSecrets(obj: KafkaConnectSpecTemplateBuildPodImagePullSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configures pod-level security attributes and common container settings.
 *
 * @schema KafkaConnectSpecTemplateBuildPodSecurityContext
 */
export interface KafkaConnectSpecTemplateBuildPodSecurityContext {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaConnectSpecTemplateBuildPodSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodSecurityContext#seccompProfile
   */
  readonly seccompProfile?: KafkaConnectSpecTemplateBuildPodSecurityContextSeccompProfile;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * @schema KafkaConnectSpecTemplateBuildPodSecurityContext#sysctls
   */
  readonly sysctls?: KafkaConnectSpecTemplateBuildPodSecurityContextSysctls[];

  /**
   * @schema KafkaConnectSpecTemplateBuildPodSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaConnectSpecTemplateBuildPodSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodSecurityContext(obj: KafkaConnectSpecTemplateBuildPodSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fsGroup': obj.fsGroup,
    'fsGroupChangePolicy': obj.fsGroupChangePolicy,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_KafkaConnectSpecTemplateBuildPodSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_KafkaConnectSpecTemplateBuildPodSecurityContextSeccompProfile(obj.seccompProfile),
    'supplementalGroups': obj.supplementalGroups?.map(y => y),
    'sysctls': obj.sysctls?.map(y => toJson_KafkaConnectSpecTemplateBuildPodSecurityContextSysctls(y)),
    'windowsOptions': toJson_KafkaConnectSpecTemplateBuildPodSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The pod's affinity rules.
 *
 * @schema KafkaConnectSpecTemplateBuildPodAffinity
 */
export interface KafkaConnectSpecTemplateBuildPodAffinity {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinity#nodeAffinity
   */
  readonly nodeAffinity?: KafkaConnectSpecTemplateBuildPodAffinityNodeAffinity;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinity#podAffinity
   */
  readonly podAffinity?: KafkaConnectSpecTemplateBuildPodAffinityPodAffinity;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinity;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinity(obj: KafkaConnectSpecTemplateBuildPodAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeAffinity': toJson_KafkaConnectSpecTemplateBuildPodAffinityNodeAffinity(obj.nodeAffinity),
    'podAffinity': toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAffinity(obj.podAffinity),
    'podAntiAffinity': toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinity(obj.podAntiAffinity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodTolerations
 */
export interface KafkaConnectSpecTemplateBuildPodTolerations {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodTolerations#effect
   */
  readonly effect?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodTolerations#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodTolerations#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodTolerations#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodTolerations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodTolerations(obj: KafkaConnectSpecTemplateBuildPodTolerations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'effect': obj.effect,
    'key': obj.key,
    'operator': obj.operator,
    'tolerationSeconds': obj.tolerationSeconds,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodHostAliases
 */
export interface KafkaConnectSpecTemplateBuildPodHostAliases {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * @schema KafkaConnectSpecTemplateBuildPodHostAliases#ip
   */
  readonly ip?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodHostAliases' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodHostAliases(obj: KafkaConnectSpecTemplateBuildPodHostAliases | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'hostnames': obj.hostnames?.map(y => y),
    'ip': obj.ip,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodTopologySpreadConstraints
 */
export interface KafkaConnectSpecTemplateBuildPodTopologySpreadConstraints {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodTopologySpreadConstraints#labelSelector
   */
  readonly labelSelector?: KafkaConnectSpecTemplateBuildPodTopologySpreadConstraintsLabelSelector;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodTopologySpreadConstraints#matchLabelKeys
   */
  readonly matchLabelKeys?: string[];

  /**
   * @schema KafkaConnectSpecTemplateBuildPodTopologySpreadConstraints#maxSkew
   */
  readonly maxSkew?: number;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodTopologySpreadConstraints#minDomains
   */
  readonly minDomains?: number;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodTopologySpreadConstraints#nodeAffinityPolicy
   */
  readonly nodeAffinityPolicy?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodTopologySpreadConstraints#nodeTaintsPolicy
   */
  readonly nodeTaintsPolicy?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodTopologySpreadConstraints#topologyKey
   */
  readonly topologyKey?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodTopologySpreadConstraints#whenUnsatisfiable
   */
  readonly whenUnsatisfiable?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodTopologySpreadConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodTopologySpreadConstraints(obj: KafkaConnectSpecTemplateBuildPodTopologySpreadConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaConnectSpecTemplateBuildPodTopologySpreadConstraintsLabelSelector(obj.labelSelector),
    'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
    'maxSkew': obj.maxSkew,
    'minDomains': obj.minDomains,
    'nodeAffinityPolicy': obj.nodeAffinityPolicy,
    'nodeTaintsPolicy': obj.nodeTaintsPolicy,
    'topologyKey': obj.topologyKey,
    'whenUnsatisfiable': obj.whenUnsatisfiable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildContainerEnv
 */
export interface KafkaConnectSpecTemplateBuildContainerEnv {
  /**
   * The environment variable key.
   *
   * @schema KafkaConnectSpecTemplateBuildContainerEnv#name
   */
  readonly name?: string;

  /**
   * The environment variable value.
   *
   * @schema KafkaConnectSpecTemplateBuildContainerEnv#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildContainerEnv' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildContainerEnv(obj: KafkaConnectSpecTemplateBuildContainerEnv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Security context for the container.
 *
 * @schema KafkaConnectSpecTemplateBuildContainerSecurityContext
 */
export interface KafkaConnectSpecTemplateBuildContainerSecurityContext {
  /**
   * @schema KafkaConnectSpecTemplateBuildContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * @schema KafkaConnectSpecTemplateBuildContainerSecurityContext#capabilities
   */
  readonly capabilities?: KafkaConnectSpecTemplateBuildContainerSecurityContextCapabilities;

  /**
   * @schema KafkaConnectSpecTemplateBuildContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * @schema KafkaConnectSpecTemplateBuildContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * @schema KafkaConnectSpecTemplateBuildContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaConnectSpecTemplateBuildContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaConnectSpecTemplateBuildContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaConnectSpecTemplateBuildContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaConnectSpecTemplateBuildContainerSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaConnectSpecTemplateBuildContainerSecurityContext#seccompProfile
   */
  readonly seccompProfile?: KafkaConnectSpecTemplateBuildContainerSecurityContextSeccompProfile;

  /**
   * @schema KafkaConnectSpecTemplateBuildContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaConnectSpecTemplateBuildContainerSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildContainerSecurityContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildContainerSecurityContext(obj: KafkaConnectSpecTemplateBuildContainerSecurityContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
    'capabilities': toJson_KafkaConnectSpecTemplateBuildContainerSecurityContextCapabilities(obj.capabilities),
    'privileged': obj.privileged,
    'procMount': obj.procMount,
    'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
    'runAsGroup': obj.runAsGroup,
    'runAsNonRoot': obj.runAsNonRoot,
    'runAsUser': obj.runAsUser,
    'seLinuxOptions': toJson_KafkaConnectSpecTemplateBuildContainerSecurityContextSeLinuxOptions(obj.seLinuxOptions),
    'seccompProfile': toJson_KafkaConnectSpecTemplateBuildContainerSecurityContextSeccompProfile(obj.seccompProfile),
    'windowsOptions': toJson_KafkaConnectSpecTemplateBuildContainerSecurityContextWindowsOptions(obj.windowsOptions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata to apply to the `PodDisruptionBudgetTemplate` resource.
 *
 * @schema KafkaConnectSpecTemplateBuildConfigMetadata
 */
export interface KafkaConnectSpecTemplateBuildConfigMetadata {
  /**
   * Labels added to the Kubernetes resource.
   *
   * @schema KafkaConnectSpecTemplateBuildConfigMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the Kubernetes resource.
   *
   * @schema KafkaConnectSpecTemplateBuildConfigMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildConfigMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildConfigMetadata(obj: KafkaConnectSpecTemplateBuildConfigMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaConnectSpecTemplateBuildServiceAccountMetadata
 */
export interface KafkaConnectSpecTemplateBuildServiceAccountMetadata {
  /**
   * Labels added to the Kubernetes resource.
   *
   * @schema KafkaConnectSpecTemplateBuildServiceAccountMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the Kubernetes resource.
   *
   * @schema KafkaConnectSpecTemplateBuildServiceAccountMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildServiceAccountMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildServiceAccountMetadata(obj: KafkaConnectSpecTemplateBuildServiceAccountMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaConnectSpecTemplateJmxSecretMetadata
 */
export interface KafkaConnectSpecTemplateJmxSecretMetadata {
  /**
   * Labels added to the Kubernetes resource.
   *
   * @schema KafkaConnectSpecTemplateJmxSecretMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the Kubernetes resource.
   *
   * @schema KafkaConnectSpecTemplateJmxSecretMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateJmxSecretMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateJmxSecretMetadata(obj: KafkaConnectSpecTemplateJmxSecretMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labels': obj.labels,
    'annotations': obj.annotations,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Value of the environment variable which will be passed to the Kafka Connect pods. It can be passed either as a reference to Secret or ConfigMap field. The field has to specify exactly one Secret or ConfigMap.
 *
 * @schema KafkaConnectSpecExternalConfigurationEnvValueFrom
 */
export interface KafkaConnectSpecExternalConfigurationEnvValueFrom {
  /**
   * Reference to a key in a ConfigMap.
   *
   * @schema KafkaConnectSpecExternalConfigurationEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: KafkaConnectSpecExternalConfigurationEnvValueFromConfigMapKeyRef;

  /**
   * Reference to a key in a Secret.
   *
   * @schema KafkaConnectSpecExternalConfigurationEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: KafkaConnectSpecExternalConfigurationEnvValueFromSecretKeyRef;

}

/**
 * Converts an object of type 'KafkaConnectSpecExternalConfigurationEnvValueFrom' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecExternalConfigurationEnvValueFrom(obj: KafkaConnectSpecExternalConfigurationEnvValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMapKeyRef': toJson_KafkaConnectSpecExternalConfigurationEnvValueFromConfigMapKeyRef(obj.configMapKeyRef),
    'secretKeyRef': toJson_KafkaConnectSpecExternalConfigurationEnvValueFromSecretKeyRef(obj.secretKeyRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a key in a ConfigMap. Exactly one Secret or ConfigMap has to be specified.
 *
 * @schema KafkaConnectSpecExternalConfigurationVolumesConfigMap
 */
export interface KafkaConnectSpecExternalConfigurationVolumesConfigMap {
  /**
   * @schema KafkaConnectSpecExternalConfigurationVolumesConfigMap#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * @schema KafkaConnectSpecExternalConfigurationVolumesConfigMap#items
   */
  readonly items?: KafkaConnectSpecExternalConfigurationVolumesConfigMapItems[];

  /**
   * @schema KafkaConnectSpecExternalConfigurationVolumesConfigMap#name
   */
  readonly name?: string;

  /**
   * @schema KafkaConnectSpecExternalConfigurationVolumesConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'KafkaConnectSpecExternalConfigurationVolumesConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecExternalConfigurationVolumesConfigMap(obj: KafkaConnectSpecExternalConfigurationVolumesConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_KafkaConnectSpecExternalConfigurationVolumesConfigMapItems(y)),
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a key in a Secret. Exactly one Secret or ConfigMap has to be specified.
 *
 * @schema KafkaConnectSpecExternalConfigurationVolumesSecret
 */
export interface KafkaConnectSpecExternalConfigurationVolumesSecret {
  /**
   * @schema KafkaConnectSpecExternalConfigurationVolumesSecret#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * @schema KafkaConnectSpecExternalConfigurationVolumesSecret#items
   */
  readonly items?: KafkaConnectSpecExternalConfigurationVolumesSecretItems[];

  /**
   * @schema KafkaConnectSpecExternalConfigurationVolumesSecret#optional
   */
  readonly optional?: boolean;

  /**
   * @schema KafkaConnectSpecExternalConfigurationVolumesSecret#secretName
   */
  readonly secretName?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecExternalConfigurationVolumesSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecExternalConfigurationVolumesSecret(obj: KafkaConnectSpecExternalConfigurationVolumesSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultMode': obj.defaultMode,
    'items': obj.items?.map(y => toJson_KafkaConnectSpecExternalConfigurationVolumesSecretItems(y)),
    'optional': obj.optional,
    'secretName': obj.secretName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Output type. Must be either `docker` for pushing the newly build image to Docker compatible registry or `imagestream` for pushing the image to OpenShift ImageStream. Required.
 *
 * @schema KafkaConnectSpecBuildOutputType
 */
export enum KafkaConnectSpecBuildOutputType {
  /** docker */
  DOCKER = "docker",
  /** imagestream */
  IMAGESTREAM = "imagestream",
}

/**
 * @schema KafkaConnectSpecBuildResourcesClaims
 */
export interface KafkaConnectSpecBuildResourcesClaims {
  /**
   * @schema KafkaConnectSpecBuildResourcesClaims#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecBuildResourcesClaims' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecBuildResourcesClaims(obj: KafkaConnectSpecBuildResourcesClaims | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecBuildPluginsArtifacts
 */
export interface KafkaConnectSpecBuildPluginsArtifacts {
  /**
   * Maven artifact id. Applicable to the `maven` artifact type only.
   *
   * @schema KafkaConnectSpecBuildPluginsArtifacts#artifact
   */
  readonly artifact?: string;

  /**
   * Name under which the artifact will be stored.
   *
   * @schema KafkaConnectSpecBuildPluginsArtifacts#fileName
   */
  readonly fileName?: string;

  /**
   * Maven group id. Applicable to the `maven` artifact type only.
   *
   * @schema KafkaConnectSpecBuildPluginsArtifacts#group
   */
  readonly group?: string;

  /**
   * By default, connections using TLS are verified to check they are secure. The server certificate used must be valid, trusted, and contain the server name. By setting this option to `true`, all TLS verification is disabled and the artifact will be downloaded, even when the server is considered insecure.
   *
   * @schema KafkaConnectSpecBuildPluginsArtifacts#insecure
   */
  readonly insecure?: boolean;

  /**
   * Maven repository to download the artifact from. Applicable to the `maven` artifact type only.
   *
   * @schema KafkaConnectSpecBuildPluginsArtifacts#repository
   */
  readonly repository?: string;

  /**
   * SHA512 checksum of the artifact. Optional. If specified, the checksum will be verified while building the new container. If not specified, the downloaded artifact will not be verified. Not applicable to the `maven` artifact type.
   *
   * @schema KafkaConnectSpecBuildPluginsArtifacts#sha512sum
   */
  readonly sha512Sum?: string;

  /**
   * Artifact type. Currently, the supported artifact types are `tgz`, `jar`, `zip`, `other` and `maven`.
   *
   * @schema KafkaConnectSpecBuildPluginsArtifacts#type
   */
  readonly type: KafkaConnectSpecBuildPluginsArtifactsType;

  /**
   * URL of the artifact which will be downloaded. Strimzi does not do any security scanning of the downloaded artifacts. For security reasons, you should first verify the artifacts manually and configure the checksum verification to make sure the same artifact is used in the automated build. Required for `jar`, `zip`, `tgz` and `other` artifacts. Not applicable to the `maven` artifact type.
   *
   * @schema KafkaConnectSpecBuildPluginsArtifacts#url
   */
  readonly url?: string;

  /**
   * Maven version number. Applicable to the `maven` artifact type only.
   *
   * @schema KafkaConnectSpecBuildPluginsArtifacts#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecBuildPluginsArtifacts' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecBuildPluginsArtifacts(obj: KafkaConnectSpecBuildPluginsArtifacts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'artifact': obj.artifact,
    'fileName': obj.fileName,
    'group': obj.group,
    'insecure': obj.insecure,
    'repository': obj.repository,
    'sha512sum': obj.sha512Sum,
    'type': obj.type,
    'url': obj.url,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to the key in the ConfigMap containing the configuration.
 *
 * @schema KafkaConnectSpecMetricsConfigValueFromConfigMapKeyRef
 */
export interface KafkaConnectSpecMetricsConfigValueFromConfigMapKeyRef {
  /**
   * @schema KafkaConnectSpecMetricsConfigValueFromConfigMapKeyRef#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecMetricsConfigValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * @schema KafkaConnectSpecMetricsConfigValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'KafkaConnectSpecMetricsConfigValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecMetricsConfigValueFromConfigMapKeyRef(obj: KafkaConnectSpecMetricsConfigValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodSecurityContextSeLinuxOptions
 */
export interface KafkaConnectSpecTemplatePodSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodSecurityContextSeLinuxOptions(obj: KafkaConnectSpecTemplatePodSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodSecurityContextSeccompProfile
 */
export interface KafkaConnectSpecTemplatePodSecurityContextSeccompProfile {
  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContextSeccompProfile#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodSecurityContextSeccompProfile(obj: KafkaConnectSpecTemplatePodSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodSecurityContextSysctls
 */
export interface KafkaConnectSpecTemplatePodSecurityContextSysctls {
  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContextSysctls#name
   */
  readonly name?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContextSysctls#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodSecurityContextSysctls(obj: KafkaConnectSpecTemplatePodSecurityContextSysctls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodSecurityContextWindowsOptions
 */
export interface KafkaConnectSpecTemplatePodSecurityContextWindowsOptions {
  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodSecurityContextWindowsOptions(obj: KafkaConnectSpecTemplatePodSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinity
 */
export interface KafkaConnectSpecTemplatePodAffinityNodeAffinity {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityNodeAffinity(obj: KafkaConnectSpecTemplatePodAffinityNodeAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': toJson_KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj.requiredDuringSchedulingIgnoredDuringExecution),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAffinity
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAffinity {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityPodAffinity(obj: KafkaConnectSpecTemplatePodAffinityPodAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinity
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAntiAffinity {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityPodAntiAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityPodAntiAffinity(obj: KafkaConnectSpecTemplatePodAffinityPodAntiAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodTopologySpreadConstraintsLabelSelector
 */
export interface KafkaConnectSpecTemplatePodTopologySpreadConstraintsLabelSelector {
  /**
   * @schema KafkaConnectSpecTemplatePodTopologySpreadConstraintsLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectSpecTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaConnectSpecTemplatePodTopologySpreadConstraintsLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodTopologySpreadConstraintsLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodTopologySpreadConstraintsLabelSelector(obj: KafkaConnectSpecTemplatePodTopologySpreadConstraintsLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaConnectSpecTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateConnectContainerSecurityContextCapabilities
 */
export interface KafkaConnectSpecTemplateConnectContainerSecurityContextCapabilities {
  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateConnectContainerSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateConnectContainerSecurityContextCapabilities(obj: KafkaConnectSpecTemplateConnectContainerSecurityContextCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateConnectContainerSecurityContextSeLinuxOptions
 */
export interface KafkaConnectSpecTemplateConnectContainerSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateConnectContainerSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateConnectContainerSecurityContextSeLinuxOptions(obj: KafkaConnectSpecTemplateConnectContainerSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateConnectContainerSecurityContextSeccompProfile
 */
export interface KafkaConnectSpecTemplateConnectContainerSecurityContextSeccompProfile {
  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContextSeccompProfile#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateConnectContainerSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateConnectContainerSecurityContextSeccompProfile(obj: KafkaConnectSpecTemplateConnectContainerSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateConnectContainerSecurityContextWindowsOptions
 */
export interface KafkaConnectSpecTemplateConnectContainerSecurityContextWindowsOptions {
  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateConnectContainerSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateConnectContainerSecurityContextWindowsOptions(obj: KafkaConnectSpecTemplateConnectContainerSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateInitContainerSecurityContextCapabilities
 */
export interface KafkaConnectSpecTemplateInitContainerSecurityContextCapabilities {
  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateInitContainerSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateInitContainerSecurityContextCapabilities(obj: KafkaConnectSpecTemplateInitContainerSecurityContextCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateInitContainerSecurityContextSeLinuxOptions
 */
export interface KafkaConnectSpecTemplateInitContainerSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateInitContainerSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateInitContainerSecurityContextSeLinuxOptions(obj: KafkaConnectSpecTemplateInitContainerSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateInitContainerSecurityContextSeccompProfile
 */
export interface KafkaConnectSpecTemplateInitContainerSecurityContextSeccompProfile {
  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContextSeccompProfile#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateInitContainerSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateInitContainerSecurityContextSeccompProfile(obj: KafkaConnectSpecTemplateInitContainerSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateInitContainerSecurityContextWindowsOptions
 */
export interface KafkaConnectSpecTemplateInitContainerSecurityContextWindowsOptions {
  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateInitContainerSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateInitContainerSecurityContextWindowsOptions(obj: KafkaConnectSpecTemplateInitContainerSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodSecurityContextSeLinuxOptions
 */
export interface KafkaConnectSpecTemplateBuildPodSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodSecurityContextSeLinuxOptions(obj: KafkaConnectSpecTemplateBuildPodSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodSecurityContextSeccompProfile
 */
export interface KafkaConnectSpecTemplateBuildPodSecurityContextSeccompProfile {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodSecurityContextSeccompProfile#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodSecurityContextSeccompProfile(obj: KafkaConnectSpecTemplateBuildPodSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodSecurityContextSysctls
 */
export interface KafkaConnectSpecTemplateBuildPodSecurityContextSysctls {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodSecurityContextSysctls#name
   */
  readonly name?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodSecurityContextSysctls#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodSecurityContextSysctls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodSecurityContextSysctls(obj: KafkaConnectSpecTemplateBuildPodSecurityContextSysctls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodSecurityContextWindowsOptions
 */
export interface KafkaConnectSpecTemplateBuildPodSecurityContextWindowsOptions {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodSecurityContextWindowsOptions(obj: KafkaConnectSpecTemplateBuildPodSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinity
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityNodeAffinity {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityNodeAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityNodeAffinity(obj: KafkaConnectSpecTemplateBuildPodAffinityNodeAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': toJson_KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj.requiredDuringSchedulingIgnoredDuringExecution),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinity
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityPodAffinity {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityPodAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAffinity(obj: KafkaConnectSpecTemplateBuildPodAffinityPodAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinity
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinity {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinity(obj: KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
    'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodTopologySpreadConstraintsLabelSelector
 */
export interface KafkaConnectSpecTemplateBuildPodTopologySpreadConstraintsLabelSelector {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodTopologySpreadConstraintsLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectSpecTemplateBuildPodTopologySpreadConstraintsLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaConnectSpecTemplateBuildPodTopologySpreadConstraintsLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodTopologySpreadConstraintsLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodTopologySpreadConstraintsLabelSelector(obj: KafkaConnectSpecTemplateBuildPodTopologySpreadConstraintsLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaConnectSpecTemplateBuildPodTopologySpreadConstraintsLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildContainerSecurityContextCapabilities
 */
export interface KafkaConnectSpecTemplateBuildContainerSecurityContextCapabilities {
  /**
   * @schema KafkaConnectSpecTemplateBuildContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * @schema KafkaConnectSpecTemplateBuildContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildContainerSecurityContextCapabilities' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildContainerSecurityContextCapabilities(obj: KafkaConnectSpecTemplateBuildContainerSecurityContextCapabilities | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => y),
    'drop': obj.drop?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildContainerSecurityContextSeLinuxOptions
 */
export interface KafkaConnectSpecTemplateBuildContainerSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaConnectSpecTemplateBuildContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildContainerSecurityContextSeLinuxOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildContainerSecurityContextSeLinuxOptions(obj: KafkaConnectSpecTemplateBuildContainerSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'level': obj.level,
    'role': obj.role,
    'type': obj.type,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildContainerSecurityContextSeccompProfile
 */
export interface KafkaConnectSpecTemplateBuildContainerSecurityContextSeccompProfile {
  /**
   * @schema KafkaConnectSpecTemplateBuildContainerSecurityContextSeccompProfile#localhostProfile
   */
  readonly localhostProfile?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildContainerSecurityContextSeccompProfile#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildContainerSecurityContextSeccompProfile' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildContainerSecurityContextSeccompProfile(obj: KafkaConnectSpecTemplateBuildContainerSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'localhostProfile': obj.localhostProfile,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildContainerSecurityContextWindowsOptions
 */
export interface KafkaConnectSpecTemplateBuildContainerSecurityContextWindowsOptions {
  /**
   * @schema KafkaConnectSpecTemplateBuildContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildContainerSecurityContextWindowsOptions#hostProcess
   */
  readonly hostProcess?: boolean;

  /**
   * @schema KafkaConnectSpecTemplateBuildContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildContainerSecurityContextWindowsOptions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildContainerSecurityContextWindowsOptions(obj: KafkaConnectSpecTemplateBuildContainerSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gmsaCredentialSpec': obj.gmsaCredentialSpec,
    'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
    'hostProcess': obj.hostProcess,
    'runAsUserName': obj.runAsUserName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a key in a ConfigMap.
 *
 * @schema KafkaConnectSpecExternalConfigurationEnvValueFromConfigMapKeyRef
 */
export interface KafkaConnectSpecExternalConfigurationEnvValueFromConfigMapKeyRef {
  /**
   * @schema KafkaConnectSpecExternalConfigurationEnvValueFromConfigMapKeyRef#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecExternalConfigurationEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * @schema KafkaConnectSpecExternalConfigurationEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'KafkaConnectSpecExternalConfigurationEnvValueFromConfigMapKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecExternalConfigurationEnvValueFromConfigMapKeyRef(obj: KafkaConnectSpecExternalConfigurationEnvValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to a key in a Secret.
 *
 * @schema KafkaConnectSpecExternalConfigurationEnvValueFromSecretKeyRef
 */
export interface KafkaConnectSpecExternalConfigurationEnvValueFromSecretKeyRef {
  /**
   * @schema KafkaConnectSpecExternalConfigurationEnvValueFromSecretKeyRef#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecExternalConfigurationEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * @schema KafkaConnectSpecExternalConfigurationEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Converts an object of type 'KafkaConnectSpecExternalConfigurationEnvValueFromSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecExternalConfigurationEnvValueFromSecretKeyRef(obj: KafkaConnectSpecExternalConfigurationEnvValueFromSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'optional': obj.optional,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecExternalConfigurationVolumesConfigMapItems
 */
export interface KafkaConnectSpecExternalConfigurationVolumesConfigMapItems {
  /**
   * @schema KafkaConnectSpecExternalConfigurationVolumesConfigMapItems#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecExternalConfigurationVolumesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * @schema KafkaConnectSpecExternalConfigurationVolumesConfigMapItems#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecExternalConfigurationVolumesConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecExternalConfigurationVolumesConfigMapItems(obj: KafkaConnectSpecExternalConfigurationVolumesConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecExternalConfigurationVolumesSecretItems
 */
export interface KafkaConnectSpecExternalConfigurationVolumesSecretItems {
  /**
   * @schema KafkaConnectSpecExternalConfigurationVolumesSecretItems#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecExternalConfigurationVolumesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * @schema KafkaConnectSpecExternalConfigurationVolumesSecretItems#path
   */
  readonly path?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecExternalConfigurationVolumesSecretItems' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecExternalConfigurationVolumesSecretItems(obj: KafkaConnectSpecExternalConfigurationVolumesSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'mode': obj.mode,
    'path': obj.path,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Artifact type. Currently, the supported artifact types are `tgz`, `jar`, `zip`, `other` and `maven`.
 *
 * @schema KafkaConnectSpecBuildPluginsArtifactsType
 */
export enum KafkaConnectSpecBuildPluginsArtifactsType {
  /** jar */
  JAR = "jar",
  /** tgz */
  TGZ = "tgz",
  /** zip */
  ZIP = "zip",
  /** maven */
  MAVEN = "maven",
  /** other */
  OTHER = "other",
}

/**
 * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference?: KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preference': toJson_KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj.preference),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms?: KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeSelectorTerms': obj.nodeSelectorTerms?.map(y => toJson_KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions
 */
export interface KafkaConnectSpecTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions {
  /**
   * @schema KafkaConnectSpecTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions(obj: KafkaConnectSpecTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference?: KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'preference': toJson_KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj.preference),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms?: KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'nodeSelectorTerms': obj.nodeSelectorTerms?.map(y => toJson_KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'podAffinityTerm': toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
   */
  readonly namespaceSelector?: KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodTopologySpreadConstraintsLabelSelectorMatchExpressions
 */
export interface KafkaConnectSpecTemplateBuildPodTopologySpreadConstraintsLabelSelectorMatchExpressions {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodTopologySpreadConstraintsLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodTopologySpreadConstraintsLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodTopologySpreadConstraintsLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodTopologySpreadConstraintsLabelSelectorMatchExpressions(obj: KafkaConnectSpecTemplateBuildPodTopologySpreadConstraintsLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj: KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(obj: KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj: KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(obj: KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(y)),
    'matchFields': obj.matchFields?.map(y => toJson_KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
   */
  readonly namespaceSelector?: KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'labelSelector': toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
    'namespaceSelector': toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'topologyKey': obj.topologyKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(obj: KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(obj: KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(obj: KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(obj: KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(obj: KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(obj: KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(obj: KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(obj: KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
    'matchLabels': obj.matchLabels,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

