// generated by cdk8s
import {ApiObject, ApiObjectMetadata, GroupVersionKind} from 'cdk8s';
import {Construct} from 'constructs';


/**
 *
 *
 * @schema Kafka
 */
export class Kafka extends ApiObject {
    /**
     * Returns the apiVersion and kind for "Kafka"
     */
    public static readonly GVK: GroupVersionKind = {
        apiVersion: 'kafka.strimzi.io/v1beta2',
        kind: 'Kafka',
    }

    /**
     * Renders a Kubernetes manifest for "Kafka".
     *
     * This can be used to inline resource manifests inside other objects (e.g. as templates).
     *
     * @param props initialization props
     */
    public static manifest(props: KafkaProps = {}): any {
        return {
            ...Kafka.GVK,
            ...toJson_KafkaProps(props),
        };
    }

    /**
     * Defines a "Kafka" API object
     * @param scope the scope in which to define this object
     * @param id a scope-local name for the object
     * @param props initialization props
     */
    public constructor(scope: Construct, id: string, props: KafkaProps = {}) {
        super(scope, id, {
            ...Kafka.GVK,
            ...props,
        });
    }

    /**
     * Renders the object to Kubernetes JSON.
     */
    public toJson(): any {
        const resolved = super.toJson();

        return {
            ...Kafka.GVK,
            ...toJson_KafkaProps(resolved),
        };
    }
}

/**
 * @schema Kafka
 */
export interface KafkaProps {
    /**
     * @schema Kafka#metadata
     */
    readonly metadata?: ApiObjectMetadata;

    /**
     * The specification of the Kafka and ZooKeeper clusters, and Topic Operator.
     *
     * @schema Kafka#spec
     */
    readonly spec?: KafkaSpec;

}

/**
 * Converts an object of type 'KafkaProps' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaProps(obj: KafkaProps | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': obj.metadata,
        'spec': toJson_KafkaSpec(obj.spec),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * The specification of the Kafka and ZooKeeper clusters, and Topic Operator.
 *
 * @schema KafkaSpec
 */
export interface KafkaSpec {
    /**
     * Configuration of the Kafka cluster.
     *
     * @schema KafkaSpec#kafka
     */
    readonly kafka: KafkaSpecKafka;

    /**
     * Configuration of the ZooKeeper cluster.
     *
     * @schema KafkaSpec#zookeeper
     */
    readonly zookeeper: KafkaSpecZookeeper;

    /**
     * Configuration of the Entity Operator.
     *
     * @schema KafkaSpec#entityOperator
     */
    readonly entityOperator?: KafkaSpecEntityOperator;

    /**
     * Configuration of the cluster certificate authority.
     *
     * @schema KafkaSpec#clusterCa
     */
    readonly clusterCa?: KafkaSpecClusterCa;

    /**
     * Configuration of the clients certificate authority.
     *
     * @schema KafkaSpec#clientsCa
     */
    readonly clientsCa?: KafkaSpecClientsCa;

    /**
     * Configuration for Cruise Control deployment. Deploys a Cruise Control instance when specified.
     *
     * @schema KafkaSpec#cruiseControl
     */
    readonly cruiseControl?: KafkaSpecCruiseControl;

    /**
     * As of Strimzi 0.35.0, JMXTrans is not supported anymore and this option is ignored.
     *
     * @schema KafkaSpec#jmxTrans
     */
    readonly jmxTrans?: KafkaSpecJmxTrans;

    /**
     * Configuration of the Kafka Exporter. Kafka Exporter can provide additional metrics, for example lag of consumer group at topic/partition.
     *
     * @schema KafkaSpec#kafkaExporter
     */
    readonly kafkaExporter?: KafkaSpecKafkaExporter;

    /**
     * A list of time windows for maintenance tasks (that is, certificates renewal). Each time window is defined by a cron expression.
     *
     * @schema KafkaSpec#maintenanceTimeWindows
     */
    readonly maintenanceTimeWindows?: string[];

}

/**
 * Converts an object of type 'KafkaSpec' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpec(obj: KafkaSpec | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'kafka': toJson_KafkaSpecKafka(obj.kafka),
        'zookeeper': toJson_KafkaSpecZookeeper(obj.zookeeper),
        'entityOperator': toJson_KafkaSpecEntityOperator(obj.entityOperator),
        'clusterCa': toJson_KafkaSpecClusterCa(obj.clusterCa),
        'clientsCa': toJson_KafkaSpecClientsCa(obj.clientsCa),
        'cruiseControl': toJson_KafkaSpecCruiseControl(obj.cruiseControl),
        'jmxTrans': toJson_KafkaSpecJmxTrans(obj.jmxTrans),
        'kafkaExporter': toJson_KafkaSpecKafkaExporter(obj.kafkaExporter),
        'maintenanceTimeWindows': obj.maintenanceTimeWindows?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Configuration of the Kafka cluster.
 *
 * @schema KafkaSpecKafka
 */
export interface KafkaSpecKafka {
    /**
     * The kafka broker version. Defaults to {DefaultKafkaVersion}. Consult the user documentation to understand the process required to upgrade or downgrade the version.
     *
     * @default DefaultKafkaVersion}. Consult the user documentation to understand the process required to upgrade or downgrade the version.
     * @schema KafkaSpecKafka#version
     */
    readonly version?: string;

    /**
     * The number of pods in the cluster.
     *
     * @schema KafkaSpecKafka#replicas
     */
    readonly replicas: number;

    /**
     * The docker image for the pods. The default value depends on the configured `Kafka.spec.kafka.version`.
     *
     * @schema KafkaSpecKafka#image
     */
    readonly image?: string;

    /**
     * Configures listeners of Kafka brokers.
     *
     * @schema KafkaSpecKafka#listeners
     */
    readonly listeners: KafkaSpecKafkaListeners[];

    /**
     * Kafka broker config properties with the following prefixes cannot be set: listeners, advertised., broker., listener., host.name, port, inter.broker.listener.name, sasl., ssl., security., password., log.dir, zookeeper.connect, zookeeper.set.acl, zookeeper.ssl, zookeeper.clientCnxnSocket, authorizer., super.user, cruise.control.metrics.topic, cruise.control.metrics.reporter.bootstrap.servers,node.id, process.roles, controller. (with the exception of: zookeeper.connection.timeout.ms, sasl.server.max.receive.size,ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols, ssl.secure.random.implementation,cruise.control.metrics.topic.num.partitions, cruise.control.metrics.topic.replication.factor, cruise.control.metrics.topic.retention.ms,cruise.control.metrics.topic.auto.create.retries, cruise.control.metrics.topic.auto.create.timeout.ms,cruise.control.metrics.topic.min.insync.replicas,controller.quorum.election.backoff.max.ms, controller.quorum.election.timeout.ms, controller.quorum.fetch.timeout.ms).
     *
     * @schema KafkaSpecKafka#config
     */
    readonly config?: any;

    /**
     * Storage configuration (disk). Cannot be updated.
     *
     * @schema KafkaSpecKafka#storage
     */
    readonly storage: KafkaSpecKafkaStorage;

    /**
     * Authorization configuration for Kafka brokers.
     *
     * @schema KafkaSpecKafka#authorization
     */
    readonly authorization?: KafkaSpecKafkaAuthorization;

    /**
     * Configuration of the `broker.rack` broker config.
     *
     * @schema KafkaSpecKafka#rack
     */
    readonly rack?: KafkaSpecKafkaRack;

    /**
     * The image of the init container used for initializing the `broker.rack`.
     *
     * @schema KafkaSpecKafka#brokerRackInitImage
     */
    readonly brokerRackInitImage?: string;

    /**
     * Pod liveness checking.
     *
     * @schema KafkaSpecKafka#livenessProbe
     */
    readonly livenessProbe?: KafkaSpecKafkaLivenessProbe;

    /**
     * Pod readiness checking.
     *
     * @schema KafkaSpecKafka#readinessProbe
     */
    readonly readinessProbe?: KafkaSpecKafkaReadinessProbe;

    /**
     * JVM Options for pods.
     *
     * @schema KafkaSpecKafka#jvmOptions
     */
    readonly jvmOptions?: KafkaSpecKafkaJvmOptions;

    /**
     * JMX Options for Kafka brokers.
     *
     * @schema KafkaSpecKafka#jmxOptions
     */
    readonly jmxOptions?: KafkaSpecKafkaJmxOptions;

    /**
     * CPU and memory resources to reserve.
     *
     * @schema KafkaSpecKafka#resources
     */
    readonly resources?: KafkaSpecKafkaResources;

    /**
     * Metrics configuration.
     *
     * @schema KafkaSpecKafka#metricsConfig
     */
    readonly metricsConfig?: KafkaSpecKafkaMetricsConfig;

    /**
     * Logging configuration for Kafka.
     *
     * @schema KafkaSpecKafka#logging
     */
    readonly logging?: KafkaSpecKafkaLogging;

    /**
     * Template for Kafka cluster resources. The template allows users to specify how the Kubernetes resources are generated.
     *
     * @schema KafkaSpecKafka#template
     */
    readonly template?: KafkaSpecKafkaTemplate;

}

/**
 * Converts an object of type 'KafkaSpecKafka' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafka(obj: KafkaSpecKafka | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'version': obj.version,
        'replicas': obj.replicas,
        'image': obj.image,
        'listeners': obj.listeners?.map(y => toJson_KafkaSpecKafkaListeners(y)),
        'config': obj.config,
        'storage': toJson_KafkaSpecKafkaStorage(obj.storage),
        'authorization': toJson_KafkaSpecKafkaAuthorization(obj.authorization),
        'rack': toJson_KafkaSpecKafkaRack(obj.rack),
        'brokerRackInitImage': obj.brokerRackInitImage,
        'livenessProbe': toJson_KafkaSpecKafkaLivenessProbe(obj.livenessProbe),
        'readinessProbe': toJson_KafkaSpecKafkaReadinessProbe(obj.readinessProbe),
        'jvmOptions': toJson_KafkaSpecKafkaJvmOptions(obj.jvmOptions),
        'jmxOptions': toJson_KafkaSpecKafkaJmxOptions(obj.jmxOptions),
        'resources': toJson_KafkaSpecKafkaResources(obj.resources),
        'metricsConfig': toJson_KafkaSpecKafkaMetricsConfig(obj.metricsConfig),
        'logging': toJson_KafkaSpecKafkaLogging(obj.logging),
        'template': toJson_KafkaSpecKafkaTemplate(obj.template),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Configuration of the ZooKeeper cluster.
 *
 * @schema KafkaSpecZookeeper
 */
export interface KafkaSpecZookeeper {
    /**
     * The number of pods in the cluster.
     *
     * @schema KafkaSpecZookeeper#replicas
     */
    readonly replicas: number;

    /**
     * The docker image for the pods.
     *
     * @schema KafkaSpecZookeeper#image
     */
    readonly image?: string;

    /**
     * Storage configuration (disk). Cannot be updated.
     *
     * @schema KafkaSpecZookeeper#storage
     */
    readonly storage: KafkaSpecZookeeperStorage;

    /**
     * The ZooKeeper broker config. Properties with the following prefixes cannot be set: server., dataDir, dataLogDir, clientPort, authProvider, quorum.auth, requireClientAuthScheme, snapshot.trust.empty, standaloneEnabled, reconfigEnabled, 4lw.commands.whitelist, secureClientPort, ssl., serverCnxnFactory, sslQuorum (with the exception of: ssl.protocol, ssl.quorum.protocol, ssl.enabledProtocols, ssl.quorum.enabledProtocols, ssl.ciphersuites, ssl.quorum.ciphersuites, ssl.hostnameVerification, ssl.quorum.hostnameVerification).
     *
     * @schema KafkaSpecZookeeper#config
     */
    readonly config?: any;

    /**
     * Pod liveness checking.
     *
     * @schema KafkaSpecZookeeper#livenessProbe
     */
    readonly livenessProbe?: KafkaSpecZookeeperLivenessProbe;

    /**
     * Pod readiness checking.
     *
     * @schema KafkaSpecZookeeper#readinessProbe
     */
    readonly readinessProbe?: KafkaSpecZookeeperReadinessProbe;

    /**
     * JVM Options for pods.
     *
     * @schema KafkaSpecZookeeper#jvmOptions
     */
    readonly jvmOptions?: KafkaSpecZookeeperJvmOptions;

    /**
     * JMX Options for Zookeeper nodes.
     *
     * @schema KafkaSpecZookeeper#jmxOptions
     */
    readonly jmxOptions?: KafkaSpecZookeeperJmxOptions;

    /**
     * CPU and memory resources to reserve.
     *
     * @schema KafkaSpecZookeeper#resources
     */
    readonly resources?: KafkaSpecZookeeperResources;

    /**
     * Metrics configuration.
     *
     * @schema KafkaSpecZookeeper#metricsConfig
     */
    readonly metricsConfig?: KafkaSpecZookeeperMetricsConfig;

    /**
     * Logging configuration for ZooKeeper.
     *
     * @schema KafkaSpecZookeeper#logging
     */
    readonly logging?: KafkaSpecZookeeperLogging;

    /**
     * Template for ZooKeeper cluster resources. The template allows users to specify how the Kubernetes resources are generated.
     *
     * @schema KafkaSpecZookeeper#template
     */
    readonly template?: KafkaSpecZookeeperTemplate;

}

/**
 * Converts an object of type 'KafkaSpecZookeeper' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeper(obj: KafkaSpecZookeeper | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'replicas': obj.replicas,
        'image': obj.image,
        'storage': toJson_KafkaSpecZookeeperStorage(obj.storage),
        'config': obj.config,
        'livenessProbe': toJson_KafkaSpecZookeeperLivenessProbe(obj.livenessProbe),
        'readinessProbe': toJson_KafkaSpecZookeeperReadinessProbe(obj.readinessProbe),
        'jvmOptions': toJson_KafkaSpecZookeeperJvmOptions(obj.jvmOptions),
        'jmxOptions': toJson_KafkaSpecZookeeperJmxOptions(obj.jmxOptions),
        'resources': toJson_KafkaSpecZookeeperResources(obj.resources),
        'metricsConfig': toJson_KafkaSpecZookeeperMetricsConfig(obj.metricsConfig),
        'logging': toJson_KafkaSpecZookeeperLogging(obj.logging),
        'template': toJson_KafkaSpecZookeeperTemplate(obj.template),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Configuration of the Entity Operator.
 *
 * @schema KafkaSpecEntityOperator
 */
export interface KafkaSpecEntityOperator {
    /**
     * Configuration of the Topic Operator.
     *
     * @schema KafkaSpecEntityOperator#topicOperator
     */
    readonly topicOperator?: KafkaSpecEntityOperatorTopicOperator;

    /**
     * Configuration of the User Operator.
     *
     * @schema KafkaSpecEntityOperator#userOperator
     */
    readonly userOperator?: KafkaSpecEntityOperatorUserOperator;

    /**
     * TLS sidecar configuration.
     *
     * @schema KafkaSpecEntityOperator#tlsSidecar
     */
    readonly tlsSidecar?: KafkaSpecEntityOperatorTlsSidecar;

    /**
     * Template for Entity Operator resources. The template allows users to specify how a `Deployment` and `Pod` is generated.
     *
     * @schema KafkaSpecEntityOperator#template
     */
    readonly template?: KafkaSpecEntityOperatorTemplate;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperator' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperator(obj: KafkaSpecEntityOperator | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'topicOperator': toJson_KafkaSpecEntityOperatorTopicOperator(obj.topicOperator),
        'userOperator': toJson_KafkaSpecEntityOperatorUserOperator(obj.userOperator),
        'tlsSidecar': toJson_KafkaSpecEntityOperatorTlsSidecar(obj.tlsSidecar),
        'template': toJson_KafkaSpecEntityOperatorTemplate(obj.template),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Configuration of the cluster certificate authority.
 *
 * @schema KafkaSpecClusterCa
 */
export interface KafkaSpecClusterCa {
    /**
     * If true then Certificate Authority certificates will be generated automatically. Otherwise the user will need to provide a Secret with the CA certificate. Default is true.
     *
     * @default true.
     * @schema KafkaSpecClusterCa#generateCertificateAuthority
     */
    readonly generateCertificateAuthority?: boolean;

    /**
     * If `true`, the Cluster and Client CA Secrets are configured with the `ownerReference` set to the `Kafka` resource. If the `Kafka` resource is deleted when `true`, the CA Secrets are also deleted. If `false`, the `ownerReference` is disabled. If the `Kafka` resource is deleted when `false`, the CA Secrets are retained and available for reuse. Default is `true`.
     *
     * @default true`.
     * @schema KafkaSpecClusterCa#generateSecretOwnerReference
     */
    readonly generateSecretOwnerReference?: boolean;

    /**
     * The number of days generated certificates should be valid for. The default is 365.
     *
     * @schema KafkaSpecClusterCa#validityDays
     */
    readonly validityDays?: number;

    /**
     * The number of days in the certificate renewal period. This is the number of days before the a certificate expires during which renewal actions may be performed. When `generateCertificateAuthority` is true, this will cause the generation of a new certificate. When `generateCertificateAuthority` is true, this will cause extra logging at WARN level about the pending certificate expiry. Default is 30.
     *
     * @default 30.
     * @schema KafkaSpecClusterCa#renewalDays
     */
    readonly renewalDays?: number;

    /**
     * How should CA certificate expiration be handled when `generateCertificateAuthority=true`. The default is for a new CA certificate to be generated reusing the existing private key.
     *
     * @schema KafkaSpecClusterCa#certificateExpirationPolicy
     */
    readonly certificateExpirationPolicy?: KafkaSpecClusterCaCertificateExpirationPolicy;

}

/**
 * Converts an object of type 'KafkaSpecClusterCa' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecClusterCa(obj: KafkaSpecClusterCa | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'generateCertificateAuthority': obj.generateCertificateAuthority,
        'generateSecretOwnerReference': obj.generateSecretOwnerReference,
        'validityDays': obj.validityDays,
        'renewalDays': obj.renewalDays,
        'certificateExpirationPolicy': obj.certificateExpirationPolicy,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Configuration of the clients certificate authority.
 *
 * @schema KafkaSpecClientsCa
 */
export interface KafkaSpecClientsCa {
    /**
     * If true then Certificate Authority certificates will be generated automatically. Otherwise the user will need to provide a Secret with the CA certificate. Default is true.
     *
     * @default true.
     * @schema KafkaSpecClientsCa#generateCertificateAuthority
     */
    readonly generateCertificateAuthority?: boolean;

    /**
     * If `true`, the Cluster and Client CA Secrets are configured with the `ownerReference` set to the `Kafka` resource. If the `Kafka` resource is deleted when `true`, the CA Secrets are also deleted. If `false`, the `ownerReference` is disabled. If the `Kafka` resource is deleted when `false`, the CA Secrets are retained and available for reuse. Default is `true`.
     *
     * @default true`.
     * @schema KafkaSpecClientsCa#generateSecretOwnerReference
     */
    readonly generateSecretOwnerReference?: boolean;

    /**
     * The number of days generated certificates should be valid for. The default is 365.
     *
     * @schema KafkaSpecClientsCa#validityDays
     */
    readonly validityDays?: number;

    /**
     * The number of days in the certificate renewal period. This is the number of days before the a certificate expires during which renewal actions may be performed. When `generateCertificateAuthority` is true, this will cause the generation of a new certificate. When `generateCertificateAuthority` is true, this will cause extra logging at WARN level about the pending certificate expiry. Default is 30.
     *
     * @default 30.
     * @schema KafkaSpecClientsCa#renewalDays
     */
    readonly renewalDays?: number;

    /**
     * How should CA certificate expiration be handled when `generateCertificateAuthority=true`. The default is for a new CA certificate to be generated reusing the existing private key.
     *
     * @schema KafkaSpecClientsCa#certificateExpirationPolicy
     */
    readonly certificateExpirationPolicy?: KafkaSpecClientsCaCertificateExpirationPolicy;

}

/**
 * Converts an object of type 'KafkaSpecClientsCa' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecClientsCa(obj: KafkaSpecClientsCa | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'generateCertificateAuthority': obj.generateCertificateAuthority,
        'generateSecretOwnerReference': obj.generateSecretOwnerReference,
        'validityDays': obj.validityDays,
        'renewalDays': obj.renewalDays,
        'certificateExpirationPolicy': obj.certificateExpirationPolicy,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Configuration for Cruise Control deployment. Deploys a Cruise Control instance when specified.
 *
 * @schema KafkaSpecCruiseControl
 */
export interface KafkaSpecCruiseControl {
    /**
     * The docker image for the pods.
     *
     * @schema KafkaSpecCruiseControl#image
     */
    readonly image?: string;

    /**
     * TLS sidecar configuration.
     *
     * @schema KafkaSpecCruiseControl#tlsSidecar
     */
    readonly tlsSidecar?: KafkaSpecCruiseControlTlsSidecar;

    /**
     * CPU and memory resources to reserve for the Cruise Control container.
     *
     * @schema KafkaSpecCruiseControl#resources
     */
    readonly resources?: KafkaSpecCruiseControlResources;

    /**
     * Pod liveness checking for the Cruise Control container.
     *
     * @schema KafkaSpecCruiseControl#livenessProbe
     */
    readonly livenessProbe?: KafkaSpecCruiseControlLivenessProbe;

    /**
     * Pod readiness checking for the Cruise Control container.
     *
     * @schema KafkaSpecCruiseControl#readinessProbe
     */
    readonly readinessProbe?: KafkaSpecCruiseControlReadinessProbe;

    /**
     * JVM Options for the Cruise Control container.
     *
     * @schema KafkaSpecCruiseControl#jvmOptions
     */
    readonly jvmOptions?: KafkaSpecCruiseControlJvmOptions;

    /**
     * Logging configuration (Log4j 2) for Cruise Control.
     *
     * @schema KafkaSpecCruiseControl#logging
     */
    readonly logging?: KafkaSpecCruiseControlLogging;

    /**
     * Template to specify how Cruise Control resources, `Deployments` and `Pods`, are generated.
     *
     * @schema KafkaSpecCruiseControl#template
     */
    readonly template?: KafkaSpecCruiseControlTemplate;

    /**
     * The Cruise Control `brokerCapacity` configuration.
     *
     * @schema KafkaSpecCruiseControl#brokerCapacity
     */
    readonly brokerCapacity?: KafkaSpecCruiseControlBrokerCapacity;

    /**
     * The Cruise Control configuration. For a full list of configuration options refer to https://github.com/linkedin/cruise-control/wiki/Configurations. Note that properties with the following prefixes cannot be set: bootstrap.servers, client.id, zookeeper., network., security., failed.brokers.zk.path,webserver.http., webserver.api.urlprefix, webserver.session.path, webserver.accesslog., two.step., request.reason.required,metric.reporter.sampler.bootstrap.servers, capacity.config.file, self.healing., ssl., kafka.broker.failure.detection.enable, topic.config.provider.class (with the exception of: ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols, webserver.http.cors.enabled, webserver.http.cors.origin, webserver.http.cors.exposeheaders, webserver.security.enable, webserver.ssl.enable).
     *
     * @schema KafkaSpecCruiseControl#config
     */
    readonly config?: any;

    /**
     * Metrics configuration.
     *
     * @schema KafkaSpecCruiseControl#metricsConfig
     */
    readonly metricsConfig?: KafkaSpecCruiseControlMetricsConfig;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControl' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControl(obj: KafkaSpecCruiseControl | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'image': obj.image,
        'tlsSidecar': toJson_KafkaSpecCruiseControlTlsSidecar(obj.tlsSidecar),
        'resources': toJson_KafkaSpecCruiseControlResources(obj.resources),
        'livenessProbe': toJson_KafkaSpecCruiseControlLivenessProbe(obj.livenessProbe),
        'readinessProbe': toJson_KafkaSpecCruiseControlReadinessProbe(obj.readinessProbe),
        'jvmOptions': toJson_KafkaSpecCruiseControlJvmOptions(obj.jvmOptions),
        'logging': toJson_KafkaSpecCruiseControlLogging(obj.logging),
        'template': toJson_KafkaSpecCruiseControlTemplate(obj.template),
        'brokerCapacity': toJson_KafkaSpecCruiseControlBrokerCapacity(obj.brokerCapacity),
        'config': obj.config,
        'metricsConfig': toJson_KafkaSpecCruiseControlMetricsConfig(obj.metricsConfig),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * As of Strimzi 0.35.0, JMXTrans is not supported anymore and this option is ignored.
 *
 * @schema KafkaSpecJmxTrans
 */
export interface KafkaSpecJmxTrans {
    /**
     * The image to use for the JmxTrans.
     *
     * @schema KafkaSpecJmxTrans#image
     */
    readonly image?: string;

    /**
     * Defines the output hosts that will be referenced later on. For more information on these properties see, xref:type-JmxTransOutputDefinitionTemplate-reference[`JmxTransOutputDefinitionTemplate` schema reference].
     *
     * @schema KafkaSpecJmxTrans#outputDefinitions
     */
    readonly outputDefinitions: KafkaSpecJmxTransOutputDefinitions[];

    /**
     * Sets the logging level of the JmxTrans deployment.For more information see, https://github.com/jmxtrans/jmxtrans-agent/wiki/Troubleshooting[JmxTrans Logging Level].
     *
     * @schema KafkaSpecJmxTrans#logLevel
     */
    readonly logLevel?: string;

    /**
     * Queries to send to the Kafka brokers to define what data should be read from each broker. For more information on these properties see, xref:type-JmxTransQueryTemplate-reference[`JmxTransQueryTemplate` schema reference].
     *
     * @schema KafkaSpecJmxTrans#kafkaQueries
     */
    readonly kafkaQueries: KafkaSpecJmxTransKafkaQueries[];

    /**
     * CPU and memory resources to reserve.
     *
     * @schema KafkaSpecJmxTrans#resources
     */
    readonly resources?: KafkaSpecJmxTransResources;

    /**
     * Template for JmxTrans resources.
     *
     * @schema KafkaSpecJmxTrans#template
     */
    readonly template?: KafkaSpecJmxTransTemplate;

}

/**
 * Converts an object of type 'KafkaSpecJmxTrans' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTrans(obj: KafkaSpecJmxTrans | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'image': obj.image,
        'outputDefinitions': obj.outputDefinitions?.map(y => toJson_KafkaSpecJmxTransOutputDefinitions(y)),
        'logLevel': obj.logLevel,
        'kafkaQueries': obj.kafkaQueries?.map(y => toJson_KafkaSpecJmxTransKafkaQueries(y)),
        'resources': toJson_KafkaSpecJmxTransResources(obj.resources),
        'template': toJson_KafkaSpecJmxTransTemplate(obj.template),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Configuration of the Kafka Exporter. Kafka Exporter can provide additional metrics, for example lag of consumer group at topic/partition.
 *
 * @schema KafkaSpecKafkaExporter
 */
export interface KafkaSpecKafkaExporter {
    /**
     * The docker image for the pods.
     *
     * @schema KafkaSpecKafkaExporter#image
     */
    readonly image?: string;

    /**
     * Regular expression to specify which consumer groups to collect. Default value is `.*`.
     *
     * @schema KafkaSpecKafkaExporter#groupRegex
     */
    readonly groupRegex?: string;

    /**
     * Regular expression to specify which topics to collect. Default value is `.*`.
     *
     * @schema KafkaSpecKafkaExporter#topicRegex
     */
    readonly topicRegex?: string;

    /**
     * CPU and memory resources to reserve.
     *
     * @schema KafkaSpecKafkaExporter#resources
     */
    readonly resources?: KafkaSpecKafkaExporterResources;

    /**
     * Only log messages with the given severity or above. Valid levels: [`info`, `debug`, `trace`]. Default log level is `info`.
     *
     * @schema KafkaSpecKafkaExporter#logging
     */
    readonly logging?: string;

    /**
     * Enable Sarama logging, a Go client library used by the Kafka Exporter.
     *
     * @schema KafkaSpecKafkaExporter#enableSaramaLogging
     */
    readonly enableSaramaLogging?: boolean;

    /**
     * Customization of deployment templates and pods.
     *
     * @schema KafkaSpecKafkaExporter#template
     */
    readonly template?: KafkaSpecKafkaExporterTemplate;

    /**
     * Pod liveness check.
     *
     * @schema KafkaSpecKafkaExporter#livenessProbe
     */
    readonly livenessProbe?: KafkaSpecKafkaExporterLivenessProbe;

    /**
     * Pod readiness check.
     *
     * @schema KafkaSpecKafkaExporter#readinessProbe
     */
    readonly readinessProbe?: KafkaSpecKafkaExporterReadinessProbe;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporter' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporter(obj: KafkaSpecKafkaExporter | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'image': obj.image,
        'groupRegex': obj.groupRegex,
        'topicRegex': obj.topicRegex,
        'resources': toJson_KafkaSpecKafkaExporterResources(obj.resources),
        'logging': obj.logging,
        'enableSaramaLogging': obj.enableSaramaLogging,
        'template': toJson_KafkaSpecKafkaExporterTemplate(obj.template),
        'livenessProbe': toJson_KafkaSpecKafkaExporterLivenessProbe(obj.livenessProbe),
        'readinessProbe': toJson_KafkaSpecKafkaExporterReadinessProbe(obj.readinessProbe),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaListeners
 */
export interface KafkaSpecKafkaListeners {
    /**
     * Name of the listener. The name will be used to identify the listener and the related Kubernetes objects. The name has to be unique within given a Kafka cluster. The name can consist of lowercase characters and numbers and be up to 11 characters long.
     *
     * @schema KafkaSpecKafkaListeners#name
     */
    readonly name: string;

    /**
     * Port number used by the listener inside Kafka. The port number has to be unique within a given Kafka cluster. Allowed port numbers are 9092 and higher with the exception of ports 9404 and 9999, which are already used for Prometheus and JMX. Depending on the listener type, the port number might not be the same as the port number that connects Kafka clients.
     *
     * @schema KafkaSpecKafkaListeners#port
     */
    readonly port: number;

    /**
     * Type of the listener. Currently the supported types are `internal`, `route`, `loadbalancer`, `nodeport` and `ingress`.
     *
     * * `internal` type exposes Kafka internally only within the Kubernetes cluster.
     * * `route` type uses OpenShift Routes to expose Kafka.
     * * `loadbalancer` type uses LoadBalancer type services to expose Kafka.
     * * `nodeport` type uses NodePort type services to expose Kafka.
     * * `ingress` type uses Kubernetes Nginx Ingress to expose Kafka with TLS passthrough.
     * * `cluster-ip` type uses a per-broker `ClusterIP` service.
     *
     *
     * @schema KafkaSpecKafkaListeners#type
     */
    readonly type: KafkaSpecKafkaListenersType;

    /**
     * Enables TLS encryption on the listener. This is a required property.
     *
     * @schema KafkaSpecKafkaListeners#tls
     */
    readonly tls: boolean;

    /**
     * Authentication configuration for this listener.
     *
     * @schema KafkaSpecKafkaListeners#authentication
     */
    readonly authentication?: KafkaSpecKafkaListenersAuthentication;

    /**
     * Additional listener configuration.
     *
     * @schema KafkaSpecKafkaListeners#configuration
     */
    readonly configuration?: KafkaSpecKafkaListenersConfiguration;

    /**
     * List of peers which should be able to connect to this listener. Peers in this list are combined using a logical OR operation. If this field is empty or missing, all connections will be allowed for this listener. If this field is present and contains at least one item, the listener only allows the traffic which matches at least one item in this list.
     *
     * @schema KafkaSpecKafkaListeners#networkPolicyPeers
     */
    readonly networkPolicyPeers?: KafkaSpecKafkaListenersNetworkPolicyPeers[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaListeners' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaListeners(obj: KafkaSpecKafkaListeners | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'port': obj.port,
        'type': obj.type,
        'tls': obj.tls,
        'authentication': toJson_KafkaSpecKafkaListenersAuthentication(obj.authentication),
        'configuration': toJson_KafkaSpecKafkaListenersConfiguration(obj.configuration),
        'networkPolicyPeers': obj.networkPolicyPeers?.map(y => toJson_KafkaSpecKafkaListenersNetworkPolicyPeers(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Storage configuration (disk). Cannot be updated.
 *
 * @schema KafkaSpecKafkaStorage
 */
export interface KafkaSpecKafkaStorage {
    /**
     * The storage class to use for dynamic volume allocation.
     *
     * @schema KafkaSpecKafkaStorage#class
     */
    readonly class?: string;

    /**
     * Specifies if the persistent volume claim has to be deleted when the cluster is un-deployed.
     *
     * @schema KafkaSpecKafkaStorage#deleteClaim
     */
    readonly deleteClaim?: boolean;

    /**
     * Storage identification number. It is mandatory only for storage volumes defined in a storage of type 'jbod'.
     *
     * @schema KafkaSpecKafkaStorage#id
     */
    readonly id?: number;

    /**
     * Overrides for individual brokers. The `overrides` field allows to specify a different configuration for different brokers.
     *
     * @schema KafkaSpecKafkaStorage#overrides
     */
    readonly overrides?: KafkaSpecKafkaStorageOverrides[];

    /**
     * Specifies a specific persistent volume to use. It contains key:value pairs representing labels for selecting such a volume.
     *
     * @schema KafkaSpecKafkaStorage#selector
     */
    readonly selector?: any;

    /**
     * When type=persistent-claim, defines the size of the persistent volume claim (i.e 1Gi). Mandatory when type=persistent-claim.
     *
     * @schema KafkaSpecKafkaStorage#size
     */
    readonly size?: string;

    /**
     * When type=ephemeral, defines the total amount of local storage required for this EmptyDir volume (for example 1Gi).
     *
     * @schema KafkaSpecKafkaStorage#sizeLimit
     */
    readonly sizeLimit?: string;

    /**
     * Storage type, must be either 'ephemeral', 'persistent-claim', or 'jbod'.
     *
     * @schema KafkaSpecKafkaStorage#type
     */
    readonly type: KafkaSpecKafkaStorageType;

    /**
     * List of volumes as Storage objects representing the JBOD disks array.
     *
     * @schema KafkaSpecKafkaStorage#volumes
     */
    readonly volumes?: KafkaSpecKafkaStorageVolumes[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaStorage' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaStorage(obj: KafkaSpecKafkaStorage | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'class': obj.class,
        'deleteClaim': obj.deleteClaim,
        'id': obj.id,
        'overrides': obj.overrides?.map(y => toJson_KafkaSpecKafkaStorageOverrides(y)),
        'selector': obj.selector,
        'size': obj.size,
        'sizeLimit': obj.sizeLimit,
        'type': obj.type,
        'volumes': obj.volumes?.map(y => toJson_KafkaSpecKafkaStorageVolumes(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Authorization configuration for Kafka brokers.
 *
 * @schema KafkaSpecKafkaAuthorization
 */
export interface KafkaSpecKafkaAuthorization {
    /**
     * Defines whether a Kafka client should be allowed or denied by default when the authorizer fails to query the Open Policy Agent, for example, when it is temporarily unavailable). Defaults to `false` - all actions will be denied.
     *
     * @default false` - all actions will be denied.
     * @schema KafkaSpecKafkaAuthorization#allowOnError
     */
    readonly allowOnError?: boolean;

    /**
     * Authorization implementation class, which must be available in classpath.
     *
     * @schema KafkaSpecKafkaAuthorization#authorizerClass
     */
    readonly authorizerClass?: string;

    /**
     * OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
     *
     * @schema KafkaSpecKafkaAuthorization#clientId
     */
    readonly clientId?: string;

    /**
     * The connect timeout in seconds when connecting to authorization server. If not set, the effective connect timeout is 60 seconds.
     *
     * @schema KafkaSpecKafkaAuthorization#connectTimeoutSeconds
     */
    readonly connectTimeoutSeconds?: number;

    /**
     * Whether authorization decision should be delegated to the 'Simple' authorizer if DENIED by Keycloak Authorization Services policies. Default value is `false`.
     *
     * @schema KafkaSpecKafkaAuthorization#delegateToKafkaAcls
     */
    readonly delegateToKafkaAcls?: boolean;

    /**
     * Enable or disable TLS hostname verification. Default value is `false`.
     *
     * @schema KafkaSpecKafkaAuthorization#disableTlsHostnameVerification
     */
    readonly disableTlsHostnameVerification?: boolean;

    /**
     * Enable or disable OAuth metrics. Default value is `false`.
     *
     * @schema KafkaSpecKafkaAuthorization#enableMetrics
     */
    readonly enableMetrics?: boolean;

    /**
     * The expiration of the records kept in the local cache to avoid querying the Open Policy Agent for every request. Defines how often the cached authorization decisions are reloaded from the Open Policy Agent server. In milliseconds. Defaults to `3600000`.
     *
     * @default 3600000`.
     * @schema KafkaSpecKafkaAuthorization#expireAfterMs
     */
    readonly expireAfterMs?: number;

    /**
     * The time between two consecutive grants refresh runs in seconds. The default value is 60.
     *
     * @schema KafkaSpecKafkaAuthorization#grantsRefreshPeriodSeconds
     */
    readonly grantsRefreshPeriodSeconds?: number;

    /**
     * The number of threads to use to refresh grants for active sessions. The more threads, the more parallelism, so the sooner the job completes. However, using more threads places a heavier load on the authorization server. The default value is 5.
     *
     * @schema KafkaSpecKafkaAuthorization#grantsRefreshPoolSize
     */
    readonly grantsRefreshPoolSize?: number;

    /**
     * The maximum number of retries to attempt if an initial HTTP request fails. If not set, the default is to not attempt any retries.
     *
     * @schema KafkaSpecKafkaAuthorization#httpRetries
     */
    readonly httpRetries?: number;

    /**
     * Initial capacity of the local cache used by the authorizer to avoid querying the Open Policy Agent for every request Defaults to `5000`.
     *
     * @default 5000`.
     * @schema KafkaSpecKafkaAuthorization#initialCacheCapacity
     */
    readonly initialCacheCapacity?: number;

    /**
     * Maximum capacity of the local cache used by the authorizer to avoid querying the Open Policy Agent for every request. Defaults to `50000`.
     *
     * @default 50000`.
     * @schema KafkaSpecKafkaAuthorization#maximumCacheSize
     */
    readonly maximumCacheSize?: number;

    /**
     * The read timeout in seconds when connecting to authorization server. If not set, the effective read timeout is 60 seconds.
     *
     * @schema KafkaSpecKafkaAuthorization#readTimeoutSeconds
     */
    readonly readTimeoutSeconds?: number;

    /**
     * List of super users, which are user principals with unlimited access rights.
     *
     * @schema KafkaSpecKafkaAuthorization#superUsers
     */
    readonly superUsers?: string[];

    /**
     * Indicates whether the custom authorizer supports the APIs for managing ACLs using the Kafka Admin API. Defaults to `false`.
     *
     * @default false`.
     * @schema KafkaSpecKafkaAuthorization#supportsAdminApi
     */
    readonly supportsAdminApi?: boolean;

    /**
     * Trusted certificates for TLS connection to the OAuth server.
     *
     * @schema KafkaSpecKafkaAuthorization#tlsTrustedCertificates
     */
    readonly tlsTrustedCertificates?: KafkaSpecKafkaAuthorizationTlsTrustedCertificates[];

    /**
     * Authorization server token endpoint URI.
     *
     * @schema KafkaSpecKafkaAuthorization#tokenEndpointUri
     */
    readonly tokenEndpointUri?: string;

    /**
     * Authorization type. Currently, the supported types are `simple`, `keycloak`, `opa` and `custom`. `simple` authorization type uses Kafka's `kafka.security.authorizer.AclAuthorizer` class for authorization. `keycloak` authorization type uses Keycloak Authorization Services for authorization. `opa` authorization type uses Open Policy Agent based authorization.`custom` authorization type uses user-provided implementation for authorization.
     *
     * @schema KafkaSpecKafkaAuthorization#type
     */
    readonly type: KafkaSpecKafkaAuthorizationType;

    /**
     * The URL used to connect to the Open Policy Agent server. The URL has to include the policy which will be queried by the authorizer. This option is required.
     *
     * @schema KafkaSpecKafkaAuthorization#url
     */
    readonly url?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaAuthorization' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaAuthorization(obj: KafkaSpecKafkaAuthorization | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'allowOnError': obj.allowOnError,
        'authorizerClass': obj.authorizerClass,
        'clientId': obj.clientId,
        'connectTimeoutSeconds': obj.connectTimeoutSeconds,
        'delegateToKafkaAcls': obj.delegateToKafkaAcls,
        'disableTlsHostnameVerification': obj.disableTlsHostnameVerification,
        'enableMetrics': obj.enableMetrics,
        'expireAfterMs': obj.expireAfterMs,
        'grantsRefreshPeriodSeconds': obj.grantsRefreshPeriodSeconds,
        'grantsRefreshPoolSize': obj.grantsRefreshPoolSize,
        'httpRetries': obj.httpRetries,
        'initialCacheCapacity': obj.initialCacheCapacity,
        'maximumCacheSize': obj.maximumCacheSize,
        'readTimeoutSeconds': obj.readTimeoutSeconds,
        'superUsers': obj.superUsers?.map(y => y),
        'supportsAdminApi': obj.supportsAdminApi,
        'tlsTrustedCertificates': obj.tlsTrustedCertificates?.map(y => toJson_KafkaSpecKafkaAuthorizationTlsTrustedCertificates(y)),
        'tokenEndpointUri': obj.tokenEndpointUri,
        'type': obj.type,
        'url': obj.url,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Configuration of the `broker.rack` broker config.
 *
 * @schema KafkaSpecKafkaRack
 */
export interface KafkaSpecKafkaRack {
    /**
     * A key that matches labels assigned to the Kubernetes cluster nodes. The value of the label is used to set a broker's `broker.rack` config, and the `client.rack` config for Kafka Connect or MirrorMaker 2.
     *
     * @schema KafkaSpecKafkaRack#topologyKey
     */
    readonly topologyKey: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaRack' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaRack(obj: KafkaSpecKafkaRack | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'topologyKey': obj.topologyKey,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Pod liveness checking.
 *
 * @schema KafkaSpecKafkaLivenessProbe
 */
export interface KafkaSpecKafkaLivenessProbe {
    /**
     * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
     *
     * @default 3. Minimum value is 1.
     * @schema KafkaSpecKafkaLivenessProbe#failureThreshold
     */
    readonly failureThreshold?: number;

    /**
     * The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.
     *
     * @default 15 seconds. Minimum value is 0.
     * @schema KafkaSpecKafkaLivenessProbe#initialDelaySeconds
     */
    readonly initialDelaySeconds?: number;

    /**
     * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
     *
     * @default 10 seconds. Minimum value is 1.
     * @schema KafkaSpecKafkaLivenessProbe#periodSeconds
     */
    readonly periodSeconds?: number;

    /**
     * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
     *
     * @default 1. Must be 1 for liveness. Minimum value is 1.
     * @schema KafkaSpecKafkaLivenessProbe#successThreshold
     */
    readonly successThreshold?: number;

    /**
     * The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.
     *
     * @default 5 seconds. Minimum value is 1.
     * @schema KafkaSpecKafkaLivenessProbe#timeoutSeconds
     */
    readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'KafkaSpecKafkaLivenessProbe' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaLivenessProbe(obj: KafkaSpecKafkaLivenessProbe | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'failureThreshold': obj.failureThreshold,
        'initialDelaySeconds': obj.initialDelaySeconds,
        'periodSeconds': obj.periodSeconds,
        'successThreshold': obj.successThreshold,
        'timeoutSeconds': obj.timeoutSeconds,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Pod readiness checking.
 *
 * @schema KafkaSpecKafkaReadinessProbe
 */
export interface KafkaSpecKafkaReadinessProbe {
    /**
     * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
     *
     * @default 3. Minimum value is 1.
     * @schema KafkaSpecKafkaReadinessProbe#failureThreshold
     */
    readonly failureThreshold?: number;

    /**
     * The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.
     *
     * @default 15 seconds. Minimum value is 0.
     * @schema KafkaSpecKafkaReadinessProbe#initialDelaySeconds
     */
    readonly initialDelaySeconds?: number;

    /**
     * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
     *
     * @default 10 seconds. Minimum value is 1.
     * @schema KafkaSpecKafkaReadinessProbe#periodSeconds
     */
    readonly periodSeconds?: number;

    /**
     * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
     *
     * @default 1. Must be 1 for liveness. Minimum value is 1.
     * @schema KafkaSpecKafkaReadinessProbe#successThreshold
     */
    readonly successThreshold?: number;

    /**
     * The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.
     *
     * @default 5 seconds. Minimum value is 1.
     * @schema KafkaSpecKafkaReadinessProbe#timeoutSeconds
     */
    readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'KafkaSpecKafkaReadinessProbe' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaReadinessProbe(obj: KafkaSpecKafkaReadinessProbe | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'failureThreshold': obj.failureThreshold,
        'initialDelaySeconds': obj.initialDelaySeconds,
        'periodSeconds': obj.periodSeconds,
        'successThreshold': obj.successThreshold,
        'timeoutSeconds': obj.timeoutSeconds,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * JVM Options for pods.
 *
 * @schema KafkaSpecKafkaJvmOptions
 */
export interface KafkaSpecKafkaJvmOptions {
    /**
     * A map of -XX options to the JVM.
     *
     * @schema KafkaSpecKafkaJvmOptions#-XX
     */
    readonly xx?: any;

    /**
     * -Xms option to to the JVM.
     *
     * @schema KafkaSpecKafkaJvmOptions#-Xms
     */
    readonly xms?: string;

    /**
     * -Xmx option to to the JVM.
     *
     * @schema KafkaSpecKafkaJvmOptions#-Xmx
     */
    readonly xmx?: string;

    /**
     * Specifies whether the Garbage Collection logging is enabled. The default is false.
     *
     * @schema KafkaSpecKafkaJvmOptions#gcLoggingEnabled
     */
    readonly gcLoggingEnabled?: boolean;

    /**
     * A map of additional system properties which will be passed using the `-D` option to the JVM.
     *
     * @schema KafkaSpecKafkaJvmOptions#javaSystemProperties
     */
    readonly javaSystemProperties?: KafkaSpecKafkaJvmOptionsJavaSystemProperties[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaJvmOptions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaJvmOptions(obj: KafkaSpecKafkaJvmOptions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        '-XX': obj.xx,
        '-Xms': obj.xms,
        '-Xmx': obj.xmx,
        'gcLoggingEnabled': obj.gcLoggingEnabled,
        'javaSystemProperties': obj.javaSystemProperties?.map(y => toJson_KafkaSpecKafkaJvmOptionsJavaSystemProperties(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * JMX Options for Kafka brokers.
 *
 * @schema KafkaSpecKafkaJmxOptions
 */
export interface KafkaSpecKafkaJmxOptions {
    /**
     * Authentication configuration for connecting to the JMX port.
     *
     * @schema KafkaSpecKafkaJmxOptions#authentication
     */
    readonly authentication?: KafkaSpecKafkaJmxOptionsAuthentication;

}

/**
 * Converts an object of type 'KafkaSpecKafkaJmxOptions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaJmxOptions(obj: KafkaSpecKafkaJmxOptions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'authentication': toJson_KafkaSpecKafkaJmxOptionsAuthentication(obj.authentication),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * CPU and memory resources to reserve.
 *
 * @schema KafkaSpecKafkaResources
 */
export interface KafkaSpecKafkaResources {
    /**
     * @schema KafkaSpecKafkaResources#claims
     */
    readonly claims?: KafkaSpecKafkaResourcesClaims[];

    /**
     * @schema KafkaSpecKafkaResources#limits
     */
    readonly limits?: any;

    /**
     * @schema KafkaSpecKafkaResources#requests
     */
    readonly requests?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaResources' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaResources(obj: KafkaSpecKafkaResources | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'claims': obj.claims?.map(y => toJson_KafkaSpecKafkaResourcesClaims(y)),
        'limits': obj.limits,
        'requests': obj.requests,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Metrics configuration.
 *
 * @schema KafkaSpecKafkaMetricsConfig
 */
export interface KafkaSpecKafkaMetricsConfig {
    /**
     * Metrics type. Only 'jmxPrometheusExporter' supported currently.
     *
     * @schema KafkaSpecKafkaMetricsConfig#type
     */
    readonly type: KafkaSpecKafkaMetricsConfigType;

    /**
     * ConfigMap entry where the Prometheus JMX Exporter configuration is stored. For details of the structure of this configuration, see the {JMXExporter}.
     *
     * @schema KafkaSpecKafkaMetricsConfig#valueFrom
     */
    readonly valueFrom: KafkaSpecKafkaMetricsConfigValueFrom;

}

/**
 * Converts an object of type 'KafkaSpecKafkaMetricsConfig' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaMetricsConfig(obj: KafkaSpecKafkaMetricsConfig | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'type': obj.type,
        'valueFrom': toJson_KafkaSpecKafkaMetricsConfigValueFrom(obj.valueFrom),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Logging configuration for Kafka.
 *
 * @schema KafkaSpecKafkaLogging
 */
export interface KafkaSpecKafkaLogging {
    /**
     * A Map from logger name to logger level.
     *
     * @schema KafkaSpecKafkaLogging#loggers
     */
    readonly loggers?: any;

    /**
     * Logging type, must be either 'inline' or 'external'.
     *
     * @schema KafkaSpecKafkaLogging#type
     */
    readonly type: KafkaSpecKafkaLoggingType;

    /**
     * `ConfigMap` entry where the logging configuration is stored.
     *
     * @schema KafkaSpecKafkaLogging#valueFrom
     */
    readonly valueFrom?: KafkaSpecKafkaLoggingValueFrom;

}

/**
 * Converts an object of type 'KafkaSpecKafkaLogging' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaLogging(obj: KafkaSpecKafkaLogging | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'loggers': obj.loggers,
        'type': obj.type,
        'valueFrom': toJson_KafkaSpecKafkaLoggingValueFrom(obj.valueFrom),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka cluster resources. The template allows users to specify how the Kubernetes resources are generated.
 *
 * @schema KafkaSpecKafkaTemplate
 */
export interface KafkaSpecKafkaTemplate {
    /**
     * Template for Kafka `StatefulSet`.
     *
     * @schema KafkaSpecKafkaTemplate#statefulset
     */
    readonly statefulset?: KafkaSpecKafkaTemplateStatefulset;

    /**
     * Template for Kafka `Pods`.
     *
     * @schema KafkaSpecKafkaTemplate#pod
     */
    readonly pod?: KafkaSpecKafkaTemplatePod;

    /**
     * Template for Kafka bootstrap `Service`.
     *
     * @schema KafkaSpecKafkaTemplate#bootstrapService
     */
    readonly bootstrapService?: KafkaSpecKafkaTemplateBootstrapService;

    /**
     * Template for Kafka broker `Service`.
     *
     * @schema KafkaSpecKafkaTemplate#brokersService
     */
    readonly brokersService?: KafkaSpecKafkaTemplateBrokersService;

    /**
     * Template for Kafka external bootstrap `Service`.
     *
     * @schema KafkaSpecKafkaTemplate#externalBootstrapService
     */
    readonly externalBootstrapService?: KafkaSpecKafkaTemplateExternalBootstrapService;

    /**
     * Template for Kafka per-pod `Services` used for access from outside of Kubernetes.
     *
     * @schema KafkaSpecKafkaTemplate#perPodService
     */
    readonly perPodService?: KafkaSpecKafkaTemplatePerPodService;

    /**
     * Template for Kafka external bootstrap `Route`.
     *
     * @schema KafkaSpecKafkaTemplate#externalBootstrapRoute
     */
    readonly externalBootstrapRoute?: KafkaSpecKafkaTemplateExternalBootstrapRoute;

    /**
     * Template for Kafka per-pod `Routes` used for access from outside of OpenShift.
     *
     * @schema KafkaSpecKafkaTemplate#perPodRoute
     */
    readonly perPodRoute?: KafkaSpecKafkaTemplatePerPodRoute;

    /**
     * Template for Kafka external bootstrap `Ingress`.
     *
     * @schema KafkaSpecKafkaTemplate#externalBootstrapIngress
     */
    readonly externalBootstrapIngress?: KafkaSpecKafkaTemplateExternalBootstrapIngress;

    /**
     * Template for Kafka per-pod `Ingress` used for access from outside of Kubernetes.
     *
     * @schema KafkaSpecKafkaTemplate#perPodIngress
     */
    readonly perPodIngress?: KafkaSpecKafkaTemplatePerPodIngress;

    /**
     * Template for all Kafka `PersistentVolumeClaims`.
     *
     * @schema KafkaSpecKafkaTemplate#persistentVolumeClaim
     */
    readonly persistentVolumeClaim?: KafkaSpecKafkaTemplatePersistentVolumeClaim;

    /**
     * Template for Kafka `PodDisruptionBudget`.
     *
     * @schema KafkaSpecKafkaTemplate#podDisruptionBudget
     */
    readonly podDisruptionBudget?: KafkaSpecKafkaTemplatePodDisruptionBudget;

    /**
     * Template for the Kafka broker container.
     *
     * @schema KafkaSpecKafkaTemplate#kafkaContainer
     */
    readonly kafkaContainer?: KafkaSpecKafkaTemplateKafkaContainer;

    /**
     * Template for the Kafka init container.
     *
     * @schema KafkaSpecKafkaTemplate#initContainer
     */
    readonly initContainer?: KafkaSpecKafkaTemplateInitContainer;

    /**
     * Template for Secret with Kafka Cluster certificate public key.
     *
     * @schema KafkaSpecKafkaTemplate#clusterCaCert
     */
    readonly clusterCaCert?: KafkaSpecKafkaTemplateClusterCaCert;

    /**
     * Template for the Kafka service account.
     *
     * @schema KafkaSpecKafkaTemplate#serviceAccount
     */
    readonly serviceAccount?: KafkaSpecKafkaTemplateServiceAccount;

    /**
     * Template for Secret of the Kafka Cluster JMX authentication.
     *
     * @schema KafkaSpecKafkaTemplate#jmxSecret
     */
    readonly jmxSecret?: KafkaSpecKafkaTemplateJmxSecret;

    /**
     * Template for the Kafka ClusterRoleBinding.
     *
     * @schema KafkaSpecKafkaTemplate#clusterRoleBinding
     */
    readonly clusterRoleBinding?: KafkaSpecKafkaTemplateClusterRoleBinding;

    /**
     * Template for Kafka `StrimziPodSet` resource.
     *
     * @schema KafkaSpecKafkaTemplate#podSet
     */
    readonly podSet?: KafkaSpecKafkaTemplatePodSet;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplate' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplate(obj: KafkaSpecKafkaTemplate | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'statefulset': toJson_KafkaSpecKafkaTemplateStatefulset(obj.statefulset),
        'pod': toJson_KafkaSpecKafkaTemplatePod(obj.pod),
        'bootstrapService': toJson_KafkaSpecKafkaTemplateBootstrapService(obj.bootstrapService),
        'brokersService': toJson_KafkaSpecKafkaTemplateBrokersService(obj.brokersService),
        'externalBootstrapService': toJson_KafkaSpecKafkaTemplateExternalBootstrapService(obj.externalBootstrapService),
        'perPodService': toJson_KafkaSpecKafkaTemplatePerPodService(obj.perPodService),
        'externalBootstrapRoute': toJson_KafkaSpecKafkaTemplateExternalBootstrapRoute(obj.externalBootstrapRoute),
        'perPodRoute': toJson_KafkaSpecKafkaTemplatePerPodRoute(obj.perPodRoute),
        'externalBootstrapIngress': toJson_KafkaSpecKafkaTemplateExternalBootstrapIngress(obj.externalBootstrapIngress),
        'perPodIngress': toJson_KafkaSpecKafkaTemplatePerPodIngress(obj.perPodIngress),
        'persistentVolumeClaim': toJson_KafkaSpecKafkaTemplatePersistentVolumeClaim(obj.persistentVolumeClaim),
        'podDisruptionBudget': toJson_KafkaSpecKafkaTemplatePodDisruptionBudget(obj.podDisruptionBudget),
        'kafkaContainer': toJson_KafkaSpecKafkaTemplateKafkaContainer(obj.kafkaContainer),
        'initContainer': toJson_KafkaSpecKafkaTemplateInitContainer(obj.initContainer),
        'clusterCaCert': toJson_KafkaSpecKafkaTemplateClusterCaCert(obj.clusterCaCert),
        'serviceAccount': toJson_KafkaSpecKafkaTemplateServiceAccount(obj.serviceAccount),
        'jmxSecret': toJson_KafkaSpecKafkaTemplateJmxSecret(obj.jmxSecret),
        'clusterRoleBinding': toJson_KafkaSpecKafkaTemplateClusterRoleBinding(obj.clusterRoleBinding),
        'podSet': toJson_KafkaSpecKafkaTemplatePodSet(obj.podSet),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Storage configuration (disk). Cannot be updated.
 *
 * @schema KafkaSpecZookeeperStorage
 */
export interface KafkaSpecZookeeperStorage {
    /**
     * The storage class to use for dynamic volume allocation.
     *
     * @schema KafkaSpecZookeeperStorage#class
     */
    readonly class?: string;

    /**
     * Specifies if the persistent volume claim has to be deleted when the cluster is un-deployed.
     *
     * @schema KafkaSpecZookeeperStorage#deleteClaim
     */
    readonly deleteClaim?: boolean;

    /**
     * Storage identification number. It is mandatory only for storage volumes defined in a storage of type 'jbod'.
     *
     * @schema KafkaSpecZookeeperStorage#id
     */
    readonly id?: number;

    /**
     * Overrides for individual brokers. The `overrides` field allows to specify a different configuration for different brokers.
     *
     * @schema KafkaSpecZookeeperStorage#overrides
     */
    readonly overrides?: KafkaSpecZookeeperStorageOverrides[];

    /**
     * Specifies a specific persistent volume to use. It contains key:value pairs representing labels for selecting such a volume.
     *
     * @schema KafkaSpecZookeeperStorage#selector
     */
    readonly selector?: any;

    /**
     * When type=persistent-claim, defines the size of the persistent volume claim (i.e 1Gi). Mandatory when type=persistent-claim.
     *
     * @schema KafkaSpecZookeeperStorage#size
     */
    readonly size?: string;

    /**
     * When type=ephemeral, defines the total amount of local storage required for this EmptyDir volume (for example 1Gi).
     *
     * @schema KafkaSpecZookeeperStorage#sizeLimit
     */
    readonly sizeLimit?: string;

    /**
     * Storage type, must be either 'ephemeral' or 'persistent-claim'.
     *
     * @schema KafkaSpecZookeeperStorage#type
     */
    readonly type: KafkaSpecZookeeperStorageType;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperStorage' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperStorage(obj: KafkaSpecZookeeperStorage | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'class': obj.class,
        'deleteClaim': obj.deleteClaim,
        'id': obj.id,
        'overrides': obj.overrides?.map(y => toJson_KafkaSpecZookeeperStorageOverrides(y)),
        'selector': obj.selector,
        'size': obj.size,
        'sizeLimit': obj.sizeLimit,
        'type': obj.type,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Pod liveness checking.
 *
 * @schema KafkaSpecZookeeperLivenessProbe
 */
export interface KafkaSpecZookeeperLivenessProbe {
    /**
     * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
     *
     * @default 3. Minimum value is 1.
     * @schema KafkaSpecZookeeperLivenessProbe#failureThreshold
     */
    readonly failureThreshold?: number;

    /**
     * The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.
     *
     * @default 15 seconds. Minimum value is 0.
     * @schema KafkaSpecZookeeperLivenessProbe#initialDelaySeconds
     */
    readonly initialDelaySeconds?: number;

    /**
     * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
     *
     * @default 10 seconds. Minimum value is 1.
     * @schema KafkaSpecZookeeperLivenessProbe#periodSeconds
     */
    readonly periodSeconds?: number;

    /**
     * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
     *
     * @default 1. Must be 1 for liveness. Minimum value is 1.
     * @schema KafkaSpecZookeeperLivenessProbe#successThreshold
     */
    readonly successThreshold?: number;

    /**
     * The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.
     *
     * @default 5 seconds. Minimum value is 1.
     * @schema KafkaSpecZookeeperLivenessProbe#timeoutSeconds
     */
    readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperLivenessProbe' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperLivenessProbe(obj: KafkaSpecZookeeperLivenessProbe | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'failureThreshold': obj.failureThreshold,
        'initialDelaySeconds': obj.initialDelaySeconds,
        'periodSeconds': obj.periodSeconds,
        'successThreshold': obj.successThreshold,
        'timeoutSeconds': obj.timeoutSeconds,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Pod readiness checking.
 *
 * @schema KafkaSpecZookeeperReadinessProbe
 */
export interface KafkaSpecZookeeperReadinessProbe {
    /**
     * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
     *
     * @default 3. Minimum value is 1.
     * @schema KafkaSpecZookeeperReadinessProbe#failureThreshold
     */
    readonly failureThreshold?: number;

    /**
     * The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.
     *
     * @default 15 seconds. Minimum value is 0.
     * @schema KafkaSpecZookeeperReadinessProbe#initialDelaySeconds
     */
    readonly initialDelaySeconds?: number;

    /**
     * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
     *
     * @default 10 seconds. Minimum value is 1.
     * @schema KafkaSpecZookeeperReadinessProbe#periodSeconds
     */
    readonly periodSeconds?: number;

    /**
     * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
     *
     * @default 1. Must be 1 for liveness. Minimum value is 1.
     * @schema KafkaSpecZookeeperReadinessProbe#successThreshold
     */
    readonly successThreshold?: number;

    /**
     * The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.
     *
     * @default 5 seconds. Minimum value is 1.
     * @schema KafkaSpecZookeeperReadinessProbe#timeoutSeconds
     */
    readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperReadinessProbe' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperReadinessProbe(obj: KafkaSpecZookeeperReadinessProbe | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'failureThreshold': obj.failureThreshold,
        'initialDelaySeconds': obj.initialDelaySeconds,
        'periodSeconds': obj.periodSeconds,
        'successThreshold': obj.successThreshold,
        'timeoutSeconds': obj.timeoutSeconds,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * JVM Options for pods.
 *
 * @schema KafkaSpecZookeeperJvmOptions
 */
export interface KafkaSpecZookeeperJvmOptions {
    /**
     * A map of -XX options to the JVM.
     *
     * @schema KafkaSpecZookeeperJvmOptions#-XX
     */
    readonly xx?: any;

    /**
     * -Xms option to to the JVM.
     *
     * @schema KafkaSpecZookeeperJvmOptions#-Xms
     */
    readonly xms?: string;

    /**
     * -Xmx option to to the JVM.
     *
     * @schema KafkaSpecZookeeperJvmOptions#-Xmx
     */
    readonly xmx?: string;

    /**
     * Specifies whether the Garbage Collection logging is enabled. The default is false.
     *
     * @schema KafkaSpecZookeeperJvmOptions#gcLoggingEnabled
     */
    readonly gcLoggingEnabled?: boolean;

    /**
     * A map of additional system properties which will be passed using the `-D` option to the JVM.
     *
     * @schema KafkaSpecZookeeperJvmOptions#javaSystemProperties
     */
    readonly javaSystemProperties?: KafkaSpecZookeeperJvmOptionsJavaSystemProperties[];

}

/**
 * Converts an object of type 'KafkaSpecZookeeperJvmOptions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperJvmOptions(obj: KafkaSpecZookeeperJvmOptions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        '-XX': obj.xx,
        '-Xms': obj.xms,
        '-Xmx': obj.xmx,
        'gcLoggingEnabled': obj.gcLoggingEnabled,
        'javaSystemProperties': obj.javaSystemProperties?.map(y => toJson_KafkaSpecZookeeperJvmOptionsJavaSystemProperties(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * JMX Options for Zookeeper nodes.
 *
 * @schema KafkaSpecZookeeperJmxOptions
 */
export interface KafkaSpecZookeeperJmxOptions {
    /**
     * Authentication configuration for connecting to the JMX port.
     *
     * @schema KafkaSpecZookeeperJmxOptions#authentication
     */
    readonly authentication?: KafkaSpecZookeeperJmxOptionsAuthentication;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperJmxOptions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperJmxOptions(obj: KafkaSpecZookeeperJmxOptions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'authentication': toJson_KafkaSpecZookeeperJmxOptionsAuthentication(obj.authentication),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * CPU and memory resources to reserve.
 *
 * @schema KafkaSpecZookeeperResources
 */
export interface KafkaSpecZookeeperResources {
    /**
     * @schema KafkaSpecZookeeperResources#claims
     */
    readonly claims?: KafkaSpecZookeeperResourcesClaims[];

    /**
     * @schema KafkaSpecZookeeperResources#limits
     */
    readonly limits?: any;

    /**
     * @schema KafkaSpecZookeeperResources#requests
     */
    readonly requests?: any;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperResources' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperResources(obj: KafkaSpecZookeeperResources | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'claims': obj.claims?.map(y => toJson_KafkaSpecZookeeperResourcesClaims(y)),
        'limits': obj.limits,
        'requests': obj.requests,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Metrics configuration.
 *
 * @schema KafkaSpecZookeeperMetricsConfig
 */
export interface KafkaSpecZookeeperMetricsConfig {
    /**
     * Metrics type. Only 'jmxPrometheusExporter' supported currently.
     *
     * @schema KafkaSpecZookeeperMetricsConfig#type
     */
    readonly type: KafkaSpecZookeeperMetricsConfigType;

    /**
     * ConfigMap entry where the Prometheus JMX Exporter configuration is stored. For details of the structure of this configuration, see the {JMXExporter}.
     *
     * @schema KafkaSpecZookeeperMetricsConfig#valueFrom
     */
    readonly valueFrom: KafkaSpecZookeeperMetricsConfigValueFrom;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperMetricsConfig' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperMetricsConfig(obj: KafkaSpecZookeeperMetricsConfig | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'type': obj.type,
        'valueFrom': toJson_KafkaSpecZookeeperMetricsConfigValueFrom(obj.valueFrom),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Logging configuration for ZooKeeper.
 *
 * @schema KafkaSpecZookeeperLogging
 */
export interface KafkaSpecZookeeperLogging {
    /**
     * A Map from logger name to logger level.
     *
     * @schema KafkaSpecZookeeperLogging#loggers
     */
    readonly loggers?: any;

    /**
     * Logging type, must be either 'inline' or 'external'.
     *
     * @schema KafkaSpecZookeeperLogging#type
     */
    readonly type: KafkaSpecZookeeperLoggingType;

    /**
     * `ConfigMap` entry where the logging configuration is stored.
     *
     * @schema KafkaSpecZookeeperLogging#valueFrom
     */
    readonly valueFrom?: KafkaSpecZookeeperLoggingValueFrom;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperLogging' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperLogging(obj: KafkaSpecZookeeperLogging | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'loggers': obj.loggers,
        'type': obj.type,
        'valueFrom': toJson_KafkaSpecZookeeperLoggingValueFrom(obj.valueFrom),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for ZooKeeper cluster resources. The template allows users to specify how the Kubernetes resources are generated.
 *
 * @schema KafkaSpecZookeeperTemplate
 */
export interface KafkaSpecZookeeperTemplate {
    /**
     * Template for ZooKeeper `StatefulSet`.
     *
     * @schema KafkaSpecZookeeperTemplate#statefulset
     */
    readonly statefulset?: KafkaSpecZookeeperTemplateStatefulset;

    /**
     * Template for ZooKeeper `Pods`.
     *
     * @schema KafkaSpecZookeeperTemplate#pod
     */
    readonly pod?: KafkaSpecZookeeperTemplatePod;

    /**
     * Template for ZooKeeper client `Service`.
     *
     * @schema KafkaSpecZookeeperTemplate#clientService
     */
    readonly clientService?: KafkaSpecZookeeperTemplateClientService;

    /**
     * Template for ZooKeeper nodes `Service`.
     *
     * @schema KafkaSpecZookeeperTemplate#nodesService
     */
    readonly nodesService?: KafkaSpecZookeeperTemplateNodesService;

    /**
     * Template for all ZooKeeper `PersistentVolumeClaims`.
     *
     * @schema KafkaSpecZookeeperTemplate#persistentVolumeClaim
     */
    readonly persistentVolumeClaim?: KafkaSpecZookeeperTemplatePersistentVolumeClaim;

    /**
     * Template for ZooKeeper `PodDisruptionBudget`.
     *
     * @schema KafkaSpecZookeeperTemplate#podDisruptionBudget
     */
    readonly podDisruptionBudget?: KafkaSpecZookeeperTemplatePodDisruptionBudget;

    /**
     * Template for the ZooKeeper container.
     *
     * @schema KafkaSpecZookeeperTemplate#zookeeperContainer
     */
    readonly zookeeperContainer?: KafkaSpecZookeeperTemplateZookeeperContainer;

    /**
     * Template for the ZooKeeper service account.
     *
     * @schema KafkaSpecZookeeperTemplate#serviceAccount
     */
    readonly serviceAccount?: KafkaSpecZookeeperTemplateServiceAccount;

    /**
     * Template for Secret of the Zookeeper Cluster JMX authentication.
     *
     * @schema KafkaSpecZookeeperTemplate#jmxSecret
     */
    readonly jmxSecret?: KafkaSpecZookeeperTemplateJmxSecret;

    /**
     * Template for ZooKeeper `StrimziPodSet` resource.
     *
     * @schema KafkaSpecZookeeperTemplate#podSet
     */
    readonly podSet?: KafkaSpecZookeeperTemplatePodSet;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplate' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplate(obj: KafkaSpecZookeeperTemplate | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'statefulset': toJson_KafkaSpecZookeeperTemplateStatefulset(obj.statefulset),
        'pod': toJson_KafkaSpecZookeeperTemplatePod(obj.pod),
        'clientService': toJson_KafkaSpecZookeeperTemplateClientService(obj.clientService),
        'nodesService': toJson_KafkaSpecZookeeperTemplateNodesService(obj.nodesService),
        'persistentVolumeClaim': toJson_KafkaSpecZookeeperTemplatePersistentVolumeClaim(obj.persistentVolumeClaim),
        'podDisruptionBudget': toJson_KafkaSpecZookeeperTemplatePodDisruptionBudget(obj.podDisruptionBudget),
        'zookeeperContainer': toJson_KafkaSpecZookeeperTemplateZookeeperContainer(obj.zookeeperContainer),
        'serviceAccount': toJson_KafkaSpecZookeeperTemplateServiceAccount(obj.serviceAccount),
        'jmxSecret': toJson_KafkaSpecZookeeperTemplateJmxSecret(obj.jmxSecret),
        'podSet': toJson_KafkaSpecZookeeperTemplatePodSet(obj.podSet),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Configuration of the Topic Operator.
 *
 * @schema KafkaSpecEntityOperatorTopicOperator
 */
export interface KafkaSpecEntityOperatorTopicOperator {
    /**
     * The namespace the Topic Operator should watch.
     *
     * @schema KafkaSpecEntityOperatorTopicOperator#watchedNamespace
     */
    readonly watchedNamespace?: string;

    /**
     * The image to use for the Topic Operator.
     *
     * @schema KafkaSpecEntityOperatorTopicOperator#image
     */
    readonly image?: string;

    /**
     * Interval between periodic reconciliations.
     *
     * @schema KafkaSpecEntityOperatorTopicOperator#reconciliationIntervalSeconds
     */
    readonly reconciliationIntervalSeconds?: number;

    /**
     * Timeout for the ZooKeeper session.
     *
     * @schema KafkaSpecEntityOperatorTopicOperator#zookeeperSessionTimeoutSeconds
     */
    readonly zookeeperSessionTimeoutSeconds?: number;

    /**
     * Pod startup checking.
     *
     * @schema KafkaSpecEntityOperatorTopicOperator#startupProbe
     */
    readonly startupProbe?: KafkaSpecEntityOperatorTopicOperatorStartupProbe;

    /**
     * Pod liveness checking.
     *
     * @schema KafkaSpecEntityOperatorTopicOperator#livenessProbe
     */
    readonly livenessProbe?: KafkaSpecEntityOperatorTopicOperatorLivenessProbe;

    /**
     * Pod readiness checking.
     *
     * @schema KafkaSpecEntityOperatorTopicOperator#readinessProbe
     */
    readonly readinessProbe?: KafkaSpecEntityOperatorTopicOperatorReadinessProbe;

    /**
     * CPU and memory resources to reserve.
     *
     * @schema KafkaSpecEntityOperatorTopicOperator#resources
     */
    readonly resources?: KafkaSpecEntityOperatorTopicOperatorResources;

    /**
     * The number of attempts at getting topic metadata.
     *
     * @schema KafkaSpecEntityOperatorTopicOperator#topicMetadataMaxAttempts
     */
    readonly topicMetadataMaxAttempts?: number;

    /**
     * Logging configuration.
     *
     * @schema KafkaSpecEntityOperatorTopicOperator#logging
     */
    readonly logging?: KafkaSpecEntityOperatorTopicOperatorLogging;

    /**
     * JVM Options for pods.
     *
     * @schema KafkaSpecEntityOperatorTopicOperator#jvmOptions
     */
    readonly jvmOptions?: KafkaSpecEntityOperatorTopicOperatorJvmOptions;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTopicOperator' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTopicOperator(obj: KafkaSpecEntityOperatorTopicOperator | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'watchedNamespace': obj.watchedNamespace,
        'image': obj.image,
        'reconciliationIntervalSeconds': obj.reconciliationIntervalSeconds,
        'zookeeperSessionTimeoutSeconds': obj.zookeeperSessionTimeoutSeconds,
        'startupProbe': toJson_KafkaSpecEntityOperatorTopicOperatorStartupProbe(obj.startupProbe),
        'livenessProbe': toJson_KafkaSpecEntityOperatorTopicOperatorLivenessProbe(obj.livenessProbe),
        'readinessProbe': toJson_KafkaSpecEntityOperatorTopicOperatorReadinessProbe(obj.readinessProbe),
        'resources': toJson_KafkaSpecEntityOperatorTopicOperatorResources(obj.resources),
        'topicMetadataMaxAttempts': obj.topicMetadataMaxAttempts,
        'logging': toJson_KafkaSpecEntityOperatorTopicOperatorLogging(obj.logging),
        'jvmOptions': toJson_KafkaSpecEntityOperatorTopicOperatorJvmOptions(obj.jvmOptions),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Configuration of the User Operator.
 *
 * @schema KafkaSpecEntityOperatorUserOperator
 */
export interface KafkaSpecEntityOperatorUserOperator {
    /**
     * The namespace the User Operator should watch.
     *
     * @schema KafkaSpecEntityOperatorUserOperator#watchedNamespace
     */
    readonly watchedNamespace?: string;

    /**
     * The image to use for the User Operator.
     *
     * @schema KafkaSpecEntityOperatorUserOperator#image
     */
    readonly image?: string;

    /**
     * Interval between periodic reconciliations.
     *
     * @schema KafkaSpecEntityOperatorUserOperator#reconciliationIntervalSeconds
     */
    readonly reconciliationIntervalSeconds?: number;

    /**
     * Timeout for the ZooKeeper session.
     *
     * @schema KafkaSpecEntityOperatorUserOperator#zookeeperSessionTimeoutSeconds
     */
    readonly zookeeperSessionTimeoutSeconds?: number;

    /**
     * The prefix that will be added to the KafkaUser name to be used as the Secret name.
     *
     * @schema KafkaSpecEntityOperatorUserOperator#secretPrefix
     */
    readonly secretPrefix?: string;

    /**
     * Pod liveness checking.
     *
     * @schema KafkaSpecEntityOperatorUserOperator#livenessProbe
     */
    readonly livenessProbe?: KafkaSpecEntityOperatorUserOperatorLivenessProbe;

    /**
     * Pod readiness checking.
     *
     * @schema KafkaSpecEntityOperatorUserOperator#readinessProbe
     */
    readonly readinessProbe?: KafkaSpecEntityOperatorUserOperatorReadinessProbe;

    /**
     * CPU and memory resources to reserve.
     *
     * @schema KafkaSpecEntityOperatorUserOperator#resources
     */
    readonly resources?: KafkaSpecEntityOperatorUserOperatorResources;

    /**
     * Logging configuration.
     *
     * @schema KafkaSpecEntityOperatorUserOperator#logging
     */
    readonly logging?: KafkaSpecEntityOperatorUserOperatorLogging;

    /**
     * JVM Options for pods.
     *
     * @schema KafkaSpecEntityOperatorUserOperator#jvmOptions
     */
    readonly jvmOptions?: KafkaSpecEntityOperatorUserOperatorJvmOptions;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorUserOperator' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorUserOperator(obj: KafkaSpecEntityOperatorUserOperator | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'watchedNamespace': obj.watchedNamespace,
        'image': obj.image,
        'reconciliationIntervalSeconds': obj.reconciliationIntervalSeconds,
        'zookeeperSessionTimeoutSeconds': obj.zookeeperSessionTimeoutSeconds,
        'secretPrefix': obj.secretPrefix,
        'livenessProbe': toJson_KafkaSpecEntityOperatorUserOperatorLivenessProbe(obj.livenessProbe),
        'readinessProbe': toJson_KafkaSpecEntityOperatorUserOperatorReadinessProbe(obj.readinessProbe),
        'resources': toJson_KafkaSpecEntityOperatorUserOperatorResources(obj.resources),
        'logging': toJson_KafkaSpecEntityOperatorUserOperatorLogging(obj.logging),
        'jvmOptions': toJson_KafkaSpecEntityOperatorUserOperatorJvmOptions(obj.jvmOptions),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * TLS sidecar configuration.
 *
 * @schema KafkaSpecEntityOperatorTlsSidecar
 */
export interface KafkaSpecEntityOperatorTlsSidecar {
    /**
     * The docker image for the container.
     *
     * @schema KafkaSpecEntityOperatorTlsSidecar#image
     */
    readonly image?: string;

    /**
     * Pod liveness checking.
     *
     * @schema KafkaSpecEntityOperatorTlsSidecar#livenessProbe
     */
    readonly livenessProbe?: KafkaSpecEntityOperatorTlsSidecarLivenessProbe;

    /**
     * The log level for the TLS sidecar. Default value is `notice`.
     *
     * @schema KafkaSpecEntityOperatorTlsSidecar#logLevel
     */
    readonly logLevel?: KafkaSpecEntityOperatorTlsSidecarLogLevel;

    /**
     * Pod readiness checking.
     *
     * @schema KafkaSpecEntityOperatorTlsSidecar#readinessProbe
     */
    readonly readinessProbe?: KafkaSpecEntityOperatorTlsSidecarReadinessProbe;

    /**
     * CPU and memory resources to reserve.
     *
     * @schema KafkaSpecEntityOperatorTlsSidecar#resources
     */
    readonly resources?: KafkaSpecEntityOperatorTlsSidecarResources;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTlsSidecar' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTlsSidecar(obj: KafkaSpecEntityOperatorTlsSidecar | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'image': obj.image,
        'livenessProbe': toJson_KafkaSpecEntityOperatorTlsSidecarLivenessProbe(obj.livenessProbe),
        'logLevel': obj.logLevel,
        'readinessProbe': toJson_KafkaSpecEntityOperatorTlsSidecarReadinessProbe(obj.readinessProbe),
        'resources': toJson_KafkaSpecEntityOperatorTlsSidecarResources(obj.resources),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for Entity Operator resources. The template allows users to specify how a `Deployment` and `Pod` is generated.
 *
 * @schema KafkaSpecEntityOperatorTemplate
 */
export interface KafkaSpecEntityOperatorTemplate {
    /**
     * Template for Entity Operator `Deployment`.
     *
     * @schema KafkaSpecEntityOperatorTemplate#deployment
     */
    readonly deployment?: KafkaSpecEntityOperatorTemplateDeployment;

    /**
     * Template for Entity Operator `Pods`.
     *
     * @schema KafkaSpecEntityOperatorTemplate#pod
     */
    readonly pod?: KafkaSpecEntityOperatorTemplatePod;

    /**
     * Template for the Entity Topic Operator container.
     *
     * @schema KafkaSpecEntityOperatorTemplate#topicOperatorContainer
     */
    readonly topicOperatorContainer?: KafkaSpecEntityOperatorTemplateTopicOperatorContainer;

    /**
     * Template for the Entity User Operator container.
     *
     * @schema KafkaSpecEntityOperatorTemplate#userOperatorContainer
     */
    readonly userOperatorContainer?: KafkaSpecEntityOperatorTemplateUserOperatorContainer;

    /**
     * Template for the Entity Operator TLS sidecar container.
     *
     * @schema KafkaSpecEntityOperatorTemplate#tlsSidecarContainer
     */
    readonly tlsSidecarContainer?: KafkaSpecEntityOperatorTemplateTlsSidecarContainer;

    /**
     * Template for the Entity Operator service account.
     *
     * @schema KafkaSpecEntityOperatorTemplate#serviceAccount
     */
    readonly serviceAccount?: KafkaSpecEntityOperatorTemplateServiceAccount;

    /**
     * Template for the Entity Operator Role.
     *
     * @schema KafkaSpecEntityOperatorTemplate#entityOperatorRole
     */
    readonly entityOperatorRole?: KafkaSpecEntityOperatorTemplateEntityOperatorRole;

    /**
     * Template for the Entity Topic Operator RoleBinding.
     *
     * @schema KafkaSpecEntityOperatorTemplate#topicOperatorRoleBinding
     */
    readonly topicOperatorRoleBinding?: KafkaSpecEntityOperatorTemplateTopicOperatorRoleBinding;

    /**
     * Template for the Entity Topic Operator RoleBinding.
     *
     * @schema KafkaSpecEntityOperatorTemplate#userOperatorRoleBinding
     */
    readonly userOperatorRoleBinding?: KafkaSpecEntityOperatorTemplateUserOperatorRoleBinding;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplate' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplate(obj: KafkaSpecEntityOperatorTemplate | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'deployment': toJson_KafkaSpecEntityOperatorTemplateDeployment(obj.deployment),
        'pod': toJson_KafkaSpecEntityOperatorTemplatePod(obj.pod),
        'topicOperatorContainer': toJson_KafkaSpecEntityOperatorTemplateTopicOperatorContainer(obj.topicOperatorContainer),
        'userOperatorContainer': toJson_KafkaSpecEntityOperatorTemplateUserOperatorContainer(obj.userOperatorContainer),
        'tlsSidecarContainer': toJson_KafkaSpecEntityOperatorTemplateTlsSidecarContainer(obj.tlsSidecarContainer),
        'serviceAccount': toJson_KafkaSpecEntityOperatorTemplateServiceAccount(obj.serviceAccount),
        'entityOperatorRole': toJson_KafkaSpecEntityOperatorTemplateEntityOperatorRole(obj.entityOperatorRole),
        'topicOperatorRoleBinding': toJson_KafkaSpecEntityOperatorTemplateTopicOperatorRoleBinding(obj.topicOperatorRoleBinding),
        'userOperatorRoleBinding': toJson_KafkaSpecEntityOperatorTemplateUserOperatorRoleBinding(obj.userOperatorRoleBinding),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * How should CA certificate expiration be handled when `generateCertificateAuthority=true`. The default is for a new CA certificate to be generated reusing the existing private key.
 *
 * @schema KafkaSpecClusterCaCertificateExpirationPolicy
 */
export enum KafkaSpecClusterCaCertificateExpirationPolicy {
    /** renew-certificate */
    RENEW_CERTIFICATE = "renew-certificate",
    /** replace-key */
    REPLACE_KEY = "replace-key",
}

/**
 * How should CA certificate expiration be handled when `generateCertificateAuthority=true`. The default is for a new CA certificate to be generated reusing the existing private key.
 *
 * @schema KafkaSpecClientsCaCertificateExpirationPolicy
 */
export enum KafkaSpecClientsCaCertificateExpirationPolicy {
    /** renew-certificate */
    RENEW_CERTIFICATE = "renew-certificate",
    /** replace-key */
    REPLACE_KEY = "replace-key",
}

/**
 * TLS sidecar configuration.
 *
 * @schema KafkaSpecCruiseControlTlsSidecar
 */
export interface KafkaSpecCruiseControlTlsSidecar {
    /**
     * The docker image for the container.
     *
     * @schema KafkaSpecCruiseControlTlsSidecar#image
     */
    readonly image?: string;

    /**
     * Pod liveness checking.
     *
     * @schema KafkaSpecCruiseControlTlsSidecar#livenessProbe
     */
    readonly livenessProbe?: KafkaSpecCruiseControlTlsSidecarLivenessProbe;

    /**
     * The log level for the TLS sidecar. Default value is `notice`.
     *
     * @schema KafkaSpecCruiseControlTlsSidecar#logLevel
     */
    readonly logLevel?: KafkaSpecCruiseControlTlsSidecarLogLevel;

    /**
     * Pod readiness checking.
     *
     * @schema KafkaSpecCruiseControlTlsSidecar#readinessProbe
     */
    readonly readinessProbe?: KafkaSpecCruiseControlTlsSidecarReadinessProbe;

    /**
     * CPU and memory resources to reserve.
     *
     * @schema KafkaSpecCruiseControlTlsSidecar#resources
     */
    readonly resources?: KafkaSpecCruiseControlTlsSidecarResources;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTlsSidecar' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTlsSidecar(obj: KafkaSpecCruiseControlTlsSidecar | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'image': obj.image,
        'livenessProbe': toJson_KafkaSpecCruiseControlTlsSidecarLivenessProbe(obj.livenessProbe),
        'logLevel': obj.logLevel,
        'readinessProbe': toJson_KafkaSpecCruiseControlTlsSidecarReadinessProbe(obj.readinessProbe),
        'resources': toJson_KafkaSpecCruiseControlTlsSidecarResources(obj.resources),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * CPU and memory resources to reserve for the Cruise Control container.
 *
 * @schema KafkaSpecCruiseControlResources
 */
export interface KafkaSpecCruiseControlResources {
    /**
     * @schema KafkaSpecCruiseControlResources#claims
     */
    readonly claims?: KafkaSpecCruiseControlResourcesClaims[];

    /**
     * @schema KafkaSpecCruiseControlResources#limits
     */
    readonly limits?: any;

    /**
     * @schema KafkaSpecCruiseControlResources#requests
     */
    readonly requests?: any;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlResources' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlResources(obj: KafkaSpecCruiseControlResources | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'claims': obj.claims?.map(y => toJson_KafkaSpecCruiseControlResourcesClaims(y)),
        'limits': obj.limits,
        'requests': obj.requests,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Pod liveness checking for the Cruise Control container.
 *
 * @schema KafkaSpecCruiseControlLivenessProbe
 */
export interface KafkaSpecCruiseControlLivenessProbe {
    /**
     * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
     *
     * @default 3. Minimum value is 1.
     * @schema KafkaSpecCruiseControlLivenessProbe#failureThreshold
     */
    readonly failureThreshold?: number;

    /**
     * The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.
     *
     * @default 15 seconds. Minimum value is 0.
     * @schema KafkaSpecCruiseControlLivenessProbe#initialDelaySeconds
     */
    readonly initialDelaySeconds?: number;

    /**
     * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
     *
     * @default 10 seconds. Minimum value is 1.
     * @schema KafkaSpecCruiseControlLivenessProbe#periodSeconds
     */
    readonly periodSeconds?: number;

    /**
     * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
     *
     * @default 1. Must be 1 for liveness. Minimum value is 1.
     * @schema KafkaSpecCruiseControlLivenessProbe#successThreshold
     */
    readonly successThreshold?: number;

    /**
     * The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.
     *
     * @default 5 seconds. Minimum value is 1.
     * @schema KafkaSpecCruiseControlLivenessProbe#timeoutSeconds
     */
    readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlLivenessProbe' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlLivenessProbe(obj: KafkaSpecCruiseControlLivenessProbe | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'failureThreshold': obj.failureThreshold,
        'initialDelaySeconds': obj.initialDelaySeconds,
        'periodSeconds': obj.periodSeconds,
        'successThreshold': obj.successThreshold,
        'timeoutSeconds': obj.timeoutSeconds,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Pod readiness checking for the Cruise Control container.
 *
 * @schema KafkaSpecCruiseControlReadinessProbe
 */
export interface KafkaSpecCruiseControlReadinessProbe {
    /**
     * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
     *
     * @default 3. Minimum value is 1.
     * @schema KafkaSpecCruiseControlReadinessProbe#failureThreshold
     */
    readonly failureThreshold?: number;

    /**
     * The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.
     *
     * @default 15 seconds. Minimum value is 0.
     * @schema KafkaSpecCruiseControlReadinessProbe#initialDelaySeconds
     */
    readonly initialDelaySeconds?: number;

    /**
     * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
     *
     * @default 10 seconds. Minimum value is 1.
     * @schema KafkaSpecCruiseControlReadinessProbe#periodSeconds
     */
    readonly periodSeconds?: number;

    /**
     * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
     *
     * @default 1. Must be 1 for liveness. Minimum value is 1.
     * @schema KafkaSpecCruiseControlReadinessProbe#successThreshold
     */
    readonly successThreshold?: number;

    /**
     * The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.
     *
     * @default 5 seconds. Minimum value is 1.
     * @schema KafkaSpecCruiseControlReadinessProbe#timeoutSeconds
     */
    readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlReadinessProbe' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlReadinessProbe(obj: KafkaSpecCruiseControlReadinessProbe | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'failureThreshold': obj.failureThreshold,
        'initialDelaySeconds': obj.initialDelaySeconds,
        'periodSeconds': obj.periodSeconds,
        'successThreshold': obj.successThreshold,
        'timeoutSeconds': obj.timeoutSeconds,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * JVM Options for the Cruise Control container.
 *
 * @schema KafkaSpecCruiseControlJvmOptions
 */
export interface KafkaSpecCruiseControlJvmOptions {
    /**
     * A map of -XX options to the JVM.
     *
     * @schema KafkaSpecCruiseControlJvmOptions#-XX
     */
    readonly xx?: any;

    /**
     * -Xms option to to the JVM.
     *
     * @schema KafkaSpecCruiseControlJvmOptions#-Xms
     */
    readonly xms?: string;

    /**
     * -Xmx option to to the JVM.
     *
     * @schema KafkaSpecCruiseControlJvmOptions#-Xmx
     */
    readonly xmx?: string;

    /**
     * Specifies whether the Garbage Collection logging is enabled. The default is false.
     *
     * @schema KafkaSpecCruiseControlJvmOptions#gcLoggingEnabled
     */
    readonly gcLoggingEnabled?: boolean;

    /**
     * A map of additional system properties which will be passed using the `-D` option to the JVM.
     *
     * @schema KafkaSpecCruiseControlJvmOptions#javaSystemProperties
     */
    readonly javaSystemProperties?: KafkaSpecCruiseControlJvmOptionsJavaSystemProperties[];

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlJvmOptions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlJvmOptions(obj: KafkaSpecCruiseControlJvmOptions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        '-XX': obj.xx,
        '-Xms': obj.xms,
        '-Xmx': obj.xmx,
        'gcLoggingEnabled': obj.gcLoggingEnabled,
        'javaSystemProperties': obj.javaSystemProperties?.map(y => toJson_KafkaSpecCruiseControlJvmOptionsJavaSystemProperties(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Logging configuration (Log4j 2) for Cruise Control.
 *
 * @schema KafkaSpecCruiseControlLogging
 */
export interface KafkaSpecCruiseControlLogging {
    /**
     * A Map from logger name to logger level.
     *
     * @schema KafkaSpecCruiseControlLogging#loggers
     */
    readonly loggers?: any;

    /**
     * Logging type, must be either 'inline' or 'external'.
     *
     * @schema KafkaSpecCruiseControlLogging#type
     */
    readonly type: KafkaSpecCruiseControlLoggingType;

    /**
     * `ConfigMap` entry where the logging configuration is stored.
     *
     * @schema KafkaSpecCruiseControlLogging#valueFrom
     */
    readonly valueFrom?: KafkaSpecCruiseControlLoggingValueFrom;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlLogging' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlLogging(obj: KafkaSpecCruiseControlLogging | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'loggers': obj.loggers,
        'type': obj.type,
        'valueFrom': toJson_KafkaSpecCruiseControlLoggingValueFrom(obj.valueFrom),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template to specify how Cruise Control resources, `Deployments` and `Pods`, are generated.
 *
 * @schema KafkaSpecCruiseControlTemplate
 */
export interface KafkaSpecCruiseControlTemplate {
    /**
     * Template for Cruise Control `Deployment`.
     *
     * @schema KafkaSpecCruiseControlTemplate#deployment
     */
    readonly deployment?: KafkaSpecCruiseControlTemplateDeployment;

    /**
     * Template for Cruise Control `Pods`.
     *
     * @schema KafkaSpecCruiseControlTemplate#pod
     */
    readonly pod?: KafkaSpecCruiseControlTemplatePod;

    /**
     * Template for Cruise Control API `Service`.
     *
     * @schema KafkaSpecCruiseControlTemplate#apiService
     */
    readonly apiService?: KafkaSpecCruiseControlTemplateApiService;

    /**
     * Template for Cruise Control `PodDisruptionBudget`.
     *
     * @schema KafkaSpecCruiseControlTemplate#podDisruptionBudget
     */
    readonly podDisruptionBudget?: KafkaSpecCruiseControlTemplatePodDisruptionBudget;

    /**
     * Template for the Cruise Control container.
     *
     * @schema KafkaSpecCruiseControlTemplate#cruiseControlContainer
     */
    readonly cruiseControlContainer?: KafkaSpecCruiseControlTemplateCruiseControlContainer;

    /**
     * Template for the Cruise Control TLS sidecar container.
     *
     * @schema KafkaSpecCruiseControlTemplate#tlsSidecarContainer
     */
    readonly tlsSidecarContainer?: KafkaSpecCruiseControlTemplateTlsSidecarContainer;

    /**
     * Template for the Cruise Control service account.
     *
     * @schema KafkaSpecCruiseControlTemplate#serviceAccount
     */
    readonly serviceAccount?: KafkaSpecCruiseControlTemplateServiceAccount;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplate' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplate(obj: KafkaSpecCruiseControlTemplate | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'deployment': toJson_KafkaSpecCruiseControlTemplateDeployment(obj.deployment),
        'pod': toJson_KafkaSpecCruiseControlTemplatePod(obj.pod),
        'apiService': toJson_KafkaSpecCruiseControlTemplateApiService(obj.apiService),
        'podDisruptionBudget': toJson_KafkaSpecCruiseControlTemplatePodDisruptionBudget(obj.podDisruptionBudget),
        'cruiseControlContainer': toJson_KafkaSpecCruiseControlTemplateCruiseControlContainer(obj.cruiseControlContainer),
        'tlsSidecarContainer': toJson_KafkaSpecCruiseControlTemplateTlsSidecarContainer(obj.tlsSidecarContainer),
        'serviceAccount': toJson_KafkaSpecCruiseControlTemplateServiceAccount(obj.serviceAccount),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * The Cruise Control `brokerCapacity` configuration.
 *
 * @schema KafkaSpecCruiseControlBrokerCapacity
 */
export interface KafkaSpecCruiseControlBrokerCapacity {
    /**
     * Broker capacity for disk in bytes. Use a number value with either standard Kubernetes byte units (K, M, G, or T), their bibyte (power of two) equivalents (Ki, Mi, Gi, or Ti), or a byte value with or without E notation. For example, 100000M, 100000Mi, 104857600000, or 1e+11.
     *
     * @schema KafkaSpecCruiseControlBrokerCapacity#disk
     */
    readonly disk?: string;

    /**
     * Broker capacity for CPU resource utilization as a percentage (0 - 100).
     *
     * @schema KafkaSpecCruiseControlBrokerCapacity#cpuUtilization
     */
    readonly cpuUtilization?: number;

    /**
     * Broker capacity for CPU resource in cores or millicores. For example, 1, 1.500, 1500m. For more information on valid CPU resource units see https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#meaning-of-cpu.
     *
     * @schema KafkaSpecCruiseControlBrokerCapacity#cpu
     */
    readonly cpu?: string;

    /**
     * Broker capacity for inbound network throughput in bytes per second. Use an integer value with standard Kubernetes byte units (K, M, G) or their bibyte (power of two) equivalents (Ki, Mi, Gi) per second. For example, 10000KiB/s.
     *
     * @schema KafkaSpecCruiseControlBrokerCapacity#inboundNetwork
     */
    readonly inboundNetwork?: string;

    /**
     * Broker capacity for outbound network throughput in bytes per second. Use an integer value with standard Kubernetes byte units (K, M, G) or their bibyte (power of two) equivalents (Ki, Mi, Gi) per second. For example, 10000KiB/s.
     *
     * @schema KafkaSpecCruiseControlBrokerCapacity#outboundNetwork
     */
    readonly outboundNetwork?: string;

    /**
     * Overrides for individual brokers. The `overrides` property lets you specify a different capacity configuration for different brokers.
     *
     * @schema KafkaSpecCruiseControlBrokerCapacity#overrides
     */
    readonly overrides?: KafkaSpecCruiseControlBrokerCapacityOverrides[];

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlBrokerCapacity' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlBrokerCapacity(obj: KafkaSpecCruiseControlBrokerCapacity | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'disk': obj.disk,
        'cpuUtilization': obj.cpuUtilization,
        'cpu': obj.cpu,
        'inboundNetwork': obj.inboundNetwork,
        'outboundNetwork': obj.outboundNetwork,
        'overrides': obj.overrides?.map(y => toJson_KafkaSpecCruiseControlBrokerCapacityOverrides(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Metrics configuration.
 *
 * @schema KafkaSpecCruiseControlMetricsConfig
 */
export interface KafkaSpecCruiseControlMetricsConfig {
    /**
     * Metrics type. Only 'jmxPrometheusExporter' supported currently.
     *
     * @schema KafkaSpecCruiseControlMetricsConfig#type
     */
    readonly type: KafkaSpecCruiseControlMetricsConfigType;

    /**
     * ConfigMap entry where the Prometheus JMX Exporter configuration is stored. For details of the structure of this configuration, see the {JMXExporter}.
     *
     * @schema KafkaSpecCruiseControlMetricsConfig#valueFrom
     */
    readonly valueFrom: KafkaSpecCruiseControlMetricsConfigValueFrom;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlMetricsConfig' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlMetricsConfig(obj: KafkaSpecCruiseControlMetricsConfig | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'type': obj.type,
        'valueFrom': toJson_KafkaSpecCruiseControlMetricsConfigValueFrom(obj.valueFrom),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransOutputDefinitions
 */
export interface KafkaSpecJmxTransOutputDefinitions {
    /**
     * Template for setting the format of the data that will be pushed.For more information see https://github.com/jmxtrans/jmxtrans/wiki/OutputWriters[JmxTrans OutputWriters].
     *
     * @schema KafkaSpecJmxTransOutputDefinitions#outputType
     */
    readonly outputType: string;

    /**
     * The DNS/hostname of the remote host that the data is pushed to.
     *
     * @schema KafkaSpecJmxTransOutputDefinitions#host
     */
    readonly host?: string;

    /**
     * The port of the remote host that the data is pushed to.
     *
     * @schema KafkaSpecJmxTransOutputDefinitions#port
     */
    readonly port?: number;

    /**
     * How many seconds the JmxTrans waits before pushing a new set of data out.
     *
     * @schema KafkaSpecJmxTransOutputDefinitions#flushDelayInSeconds
     */
    readonly flushDelayInSeconds?: number;

    /**
     * Template for filtering data to be included in response to a wildcard query. For more information see https://github.com/jmxtrans/jmxtrans/wiki/Queries[JmxTrans queries].
     *
     * @schema KafkaSpecJmxTransOutputDefinitions#typeNames
     */
    readonly typeNames?: string[];

    /**
     * Template for setting the name of the output definition. This is used to identify where to send the results of queries should be sent.
     *
     * @schema KafkaSpecJmxTransOutputDefinitions#name
     */
    readonly name: string;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransOutputDefinitions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransOutputDefinitions(obj: KafkaSpecJmxTransOutputDefinitions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'outputType': obj.outputType,
        'host': obj.host,
        'port': obj.port,
        'flushDelayInSeconds': obj.flushDelayInSeconds,
        'typeNames': obj.typeNames?.map(y => y),
        'name': obj.name,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransKafkaQueries
 */
export interface KafkaSpecJmxTransKafkaQueries {
    /**
     * If using wildcards instead of a specific MBean then the data is gathered from multiple MBeans. Otherwise if specifying an MBean then data is gathered from that specified MBean.
     *
     * @schema KafkaSpecJmxTransKafkaQueries#targetMBean
     */
    readonly targetMBean: string;

    /**
     * Determine which attributes of the targeted MBean should be included.
     *
     * @schema KafkaSpecJmxTransKafkaQueries#attributes
     */
    readonly attributes: string[];

    /**
     * List of the names of output definitions specified in the spec.kafka.jmxTrans.outputDefinitions that have defined where JMX metrics are pushed to, and in which data format.
     *
     * @schema KafkaSpecJmxTransKafkaQueries#outputs
     */
    readonly outputs: string[];

}

/**
 * Converts an object of type 'KafkaSpecJmxTransKafkaQueries' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransKafkaQueries(obj: KafkaSpecJmxTransKafkaQueries | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'targetMBean': obj.targetMBean,
        'attributes': obj.attributes?.map(y => y),
        'outputs': obj.outputs?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * CPU and memory resources to reserve.
 *
 * @schema KafkaSpecJmxTransResources
 */
export interface KafkaSpecJmxTransResources {
    /**
     * @schema KafkaSpecJmxTransResources#claims
     */
    readonly claims?: KafkaSpecJmxTransResourcesClaims[];

    /**
     * @schema KafkaSpecJmxTransResources#limits
     */
    readonly limits?: any;

    /**
     * @schema KafkaSpecJmxTransResources#requests
     */
    readonly requests?: any;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransResources' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransResources(obj: KafkaSpecJmxTransResources | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'claims': obj.claims?.map(y => toJson_KafkaSpecJmxTransResourcesClaims(y)),
        'limits': obj.limits,
        'requests': obj.requests,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for JmxTrans resources.
 *
 * @schema KafkaSpecJmxTransTemplate
 */
export interface KafkaSpecJmxTransTemplate {
    /**
     * Template for JmxTrans `Deployment`.
     *
     * @schema KafkaSpecJmxTransTemplate#deployment
     */
    readonly deployment?: KafkaSpecJmxTransTemplateDeployment;

    /**
     * Template for JmxTrans `Pods`.
     *
     * @schema KafkaSpecJmxTransTemplate#pod
     */
    readonly pod?: KafkaSpecJmxTransTemplatePod;

    /**
     * Template for JmxTrans container.
     *
     * @schema KafkaSpecJmxTransTemplate#container
     */
    readonly container?: KafkaSpecJmxTransTemplateContainer;

    /**
     * Template for the JmxTrans service account.
     *
     * @schema KafkaSpecJmxTransTemplate#serviceAccount
     */
    readonly serviceAccount?: KafkaSpecJmxTransTemplateServiceAccount;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplate' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplate(obj: KafkaSpecJmxTransTemplate | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'deployment': toJson_KafkaSpecJmxTransTemplateDeployment(obj.deployment),
        'pod': toJson_KafkaSpecJmxTransTemplatePod(obj.pod),
        'container': toJson_KafkaSpecJmxTransTemplateContainer(obj.container),
        'serviceAccount': toJson_KafkaSpecJmxTransTemplateServiceAccount(obj.serviceAccount),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * CPU and memory resources to reserve.
 *
 * @schema KafkaSpecKafkaExporterResources
 */
export interface KafkaSpecKafkaExporterResources {
    /**
     * @schema KafkaSpecKafkaExporterResources#claims
     */
    readonly claims?: KafkaSpecKafkaExporterResourcesClaims[];

    /**
     * @schema KafkaSpecKafkaExporterResources#limits
     */
    readonly limits?: any;

    /**
     * @schema KafkaSpecKafkaExporterResources#requests
     */
    readonly requests?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterResources' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterResources(obj: KafkaSpecKafkaExporterResources | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'claims': obj.claims?.map(y => toJson_KafkaSpecKafkaExporterResourcesClaims(y)),
        'limits': obj.limits,
        'requests': obj.requests,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Customization of deployment templates and pods.
 *
 * @schema KafkaSpecKafkaExporterTemplate
 */
export interface KafkaSpecKafkaExporterTemplate {
    /**
     * Template for Kafka Exporter `Deployment`.
     *
     * @schema KafkaSpecKafkaExporterTemplate#deployment
     */
    readonly deployment?: KafkaSpecKafkaExporterTemplateDeployment;

    /**
     * Template for Kafka Exporter `Pods`.
     *
     * @schema KafkaSpecKafkaExporterTemplate#pod
     */
    readonly pod?: KafkaSpecKafkaExporterTemplatePod;

    /**
     * Template for Kafka Exporter `Service`.
     *
     * @schema KafkaSpecKafkaExporterTemplate#service
     */
    readonly service?: KafkaSpecKafkaExporterTemplateService;

    /**
     * Template for the Kafka Exporter container.
     *
     * @schema KafkaSpecKafkaExporterTemplate#container
     */
    readonly container?: KafkaSpecKafkaExporterTemplateContainer;

    /**
     * Template for the Kafka Exporter service account.
     *
     * @schema KafkaSpecKafkaExporterTemplate#serviceAccount
     */
    readonly serviceAccount?: KafkaSpecKafkaExporterTemplateServiceAccount;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplate' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplate(obj: KafkaSpecKafkaExporterTemplate | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'deployment': toJson_KafkaSpecKafkaExporterTemplateDeployment(obj.deployment),
        'pod': toJson_KafkaSpecKafkaExporterTemplatePod(obj.pod),
        'service': toJson_KafkaSpecKafkaExporterTemplateService(obj.service),
        'container': toJson_KafkaSpecKafkaExporterTemplateContainer(obj.container),
        'serviceAccount': toJson_KafkaSpecKafkaExporterTemplateServiceAccount(obj.serviceAccount),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Pod liveness check.
 *
 * @schema KafkaSpecKafkaExporterLivenessProbe
 */
export interface KafkaSpecKafkaExporterLivenessProbe {
    /**
     * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
     *
     * @default 3. Minimum value is 1.
     * @schema KafkaSpecKafkaExporterLivenessProbe#failureThreshold
     */
    readonly failureThreshold?: number;

    /**
     * The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.
     *
     * @default 15 seconds. Minimum value is 0.
     * @schema KafkaSpecKafkaExporterLivenessProbe#initialDelaySeconds
     */
    readonly initialDelaySeconds?: number;

    /**
     * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
     *
     * @default 10 seconds. Minimum value is 1.
     * @schema KafkaSpecKafkaExporterLivenessProbe#periodSeconds
     */
    readonly periodSeconds?: number;

    /**
     * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
     *
     * @default 1. Must be 1 for liveness. Minimum value is 1.
     * @schema KafkaSpecKafkaExporterLivenessProbe#successThreshold
     */
    readonly successThreshold?: number;

    /**
     * The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.
     *
     * @default 5 seconds. Minimum value is 1.
     * @schema KafkaSpecKafkaExporterLivenessProbe#timeoutSeconds
     */
    readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterLivenessProbe' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterLivenessProbe(obj: KafkaSpecKafkaExporterLivenessProbe | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'failureThreshold': obj.failureThreshold,
        'initialDelaySeconds': obj.initialDelaySeconds,
        'periodSeconds': obj.periodSeconds,
        'successThreshold': obj.successThreshold,
        'timeoutSeconds': obj.timeoutSeconds,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Pod readiness check.
 *
 * @schema KafkaSpecKafkaExporterReadinessProbe
 */
export interface KafkaSpecKafkaExporterReadinessProbe {
    /**
     * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
     *
     * @default 3. Minimum value is 1.
     * @schema KafkaSpecKafkaExporterReadinessProbe#failureThreshold
     */
    readonly failureThreshold?: number;

    /**
     * The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.
     *
     * @default 15 seconds. Minimum value is 0.
     * @schema KafkaSpecKafkaExporterReadinessProbe#initialDelaySeconds
     */
    readonly initialDelaySeconds?: number;

    /**
     * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
     *
     * @default 10 seconds. Minimum value is 1.
     * @schema KafkaSpecKafkaExporterReadinessProbe#periodSeconds
     */
    readonly periodSeconds?: number;

    /**
     * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
     *
     * @default 1. Must be 1 for liveness. Minimum value is 1.
     * @schema KafkaSpecKafkaExporterReadinessProbe#successThreshold
     */
    readonly successThreshold?: number;

    /**
     * The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.
     *
     * @default 5 seconds. Minimum value is 1.
     * @schema KafkaSpecKafkaExporterReadinessProbe#timeoutSeconds
     */
    readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterReadinessProbe' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterReadinessProbe(obj: KafkaSpecKafkaExporterReadinessProbe | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'failureThreshold': obj.failureThreshold,
        'initialDelaySeconds': obj.initialDelaySeconds,
        'periodSeconds': obj.periodSeconds,
        'successThreshold': obj.successThreshold,
        'timeoutSeconds': obj.timeoutSeconds,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Type of the listener. Currently the supported types are `internal`, `route`, `loadbalancer`, `nodeport` and `ingress`.
 *
 * * `internal` type exposes Kafka internally only within the Kubernetes cluster.
 * * `route` type uses OpenShift Routes to expose Kafka.
 * * `loadbalancer` type uses LoadBalancer type services to expose Kafka.
 * * `nodeport` type uses NodePort type services to expose Kafka.
 * * `ingress` type uses Kubernetes Nginx Ingress to expose Kafka with TLS passthrough.
 * * `cluster-ip` type uses a per-broker `ClusterIP` service.
 *
 *
 * @schema KafkaSpecKafkaListenersType
 */
export enum KafkaSpecKafkaListenersType {
    /** internal */
    INTERNAL = "internal",
    /** route */
    ROUTE = "route",
    /** loadbalancer */
    LOADBALANCER = "loadbalancer",
    /** nodeport */
    NODEPORT = "nodeport",
    /** ingress */
    INGRESS = "ingress",
    /** cluster-ip */
    CLUSTER_IP = "cluster-ip",
}

/**
 * Authentication configuration for this listener.
 *
 * @schema KafkaSpecKafkaListenersAuthentication
 */
export interface KafkaSpecKafkaListenersAuthentication {
    /**
     * Configure whether the access token is treated as JWT. This must be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
     *
     * @default true`.
     * @schema KafkaSpecKafkaListenersAuthentication#accessTokenIsJwt
     */
    readonly accessTokenIsJwt?: boolean;

    /**
     * Configure whether the access token type check is performed or not. This should be set to `false` if the authorization server does not include 'typ' claim in JWT token. Defaults to `true`.
     *
     * @default true`.
     * @schema KafkaSpecKafkaListenersAuthentication#checkAccessTokenType
     */
    readonly checkAccessTokenType?: boolean;

    /**
     * Enable or disable audience checking. Audience checks identify the recipients of tokens. If audience checking is enabled, the OAuth Client ID also has to be configured using the `clientId` property. The Kafka broker will reject tokens that do not have its `clientId` in their `aud` (audience) claim.Default value is `false`.
     *
     * @schema KafkaSpecKafkaListenersAuthentication#checkAudience
     */
    readonly checkAudience?: boolean;

    /**
     * Enable or disable issuer checking. By default issuer is checked using the value configured by `validIssuerUri`. Default value is `true`.
     *
     * @schema KafkaSpecKafkaListenersAuthentication#checkIssuer
     */
    readonly checkIssuer?: boolean;

    /**
     * The audience to use when making requests to the authorization server's token endpoint. Used for inter-broker authentication and for configuring OAuth 2.0 over PLAIN using the `clientId` and `secret` method.
     *
     * @schema KafkaSpecKafkaListenersAuthentication#clientAudience
     */
    readonly clientAudience?: string;

    /**
     * OAuth Client ID which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
     *
     * @schema KafkaSpecKafkaListenersAuthentication#clientId
     */
    readonly clientId?: string;

    /**
     * The scope to use when making requests to the authorization server's token endpoint. Used for inter-broker authentication and for configuring OAuth 2.0 over PLAIN using the `clientId` and `secret` method.
     *
     * @schema KafkaSpecKafkaListenersAuthentication#clientScope
     */
    readonly clientScope?: string;

    /**
     * Link to Kubernetes Secret containing the OAuth client secret which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
     *
     * @schema KafkaSpecKafkaListenersAuthentication#clientSecret
     */
    readonly clientSecret?: KafkaSpecKafkaListenersAuthenticationClientSecret;

    /**
     * The connect timeout in seconds when connecting to authorization server. If not set, the effective connect timeout is 60 seconds.
     *
     * @schema KafkaSpecKafkaListenersAuthentication#connectTimeoutSeconds
     */
    readonly connectTimeoutSeconds?: number;

    /**
     * JsonPath filter query to be applied to the JWT token or to the response of the introspection endpoint for additional token validation. Not set by default.
     *
     * @schema KafkaSpecKafkaListenersAuthentication#customClaimCheck
     */
    readonly customClaimCheck?: string;

    /**
     * Enable or disable TLS hostname verification. Default value is `false`.
     *
     * @schema KafkaSpecKafkaListenersAuthentication#disableTlsHostnameVerification
     */
    readonly disableTlsHostnameVerification?: boolean;

    /**
     * Enable or disable ECDSA support by installing BouncyCastle crypto provider. ECDSA support is always enabled. The BouncyCastle libraries are no longer packaged with Strimzi. Value is ignored.
     *
     * @schema KafkaSpecKafkaListenersAuthentication#enableECDSA
     */
    readonly enableEcdsa?: boolean;

    /**
     * Enable or disable OAuth metrics. Default value is `false`.
     *
     * @schema KafkaSpecKafkaListenersAuthentication#enableMetrics
     */
    readonly enableMetrics?: boolean;

    /**
     * Enable or disable OAuth authentication over SASL_OAUTHBEARER. Default value is `true`.
     *
     * @schema KafkaSpecKafkaListenersAuthentication#enableOauthBearer
     */
    readonly enableOauthBearer?: boolean;

    /**
     * Enable or disable OAuth authentication over SASL_PLAIN. There is no re-authentication support when this mechanism is used. Default value is `false`.
     *
     * @schema KafkaSpecKafkaListenersAuthentication#enablePlain
     */
    readonly enablePlain?: boolean;

    /**
     * Enable or disable termination of Kafka broker processes due to potentially recoverable runtime errors during startup. Default value is `true`.
     *
     * @schema KafkaSpecKafkaListenersAuthentication#failFast
     */
    readonly failFast?: boolean;

    /**
     * The fallback username claim to be used for the user id if the claim specified by `userNameClaim` is not present. This is useful when `client_credentials` authentication only results in the client id being provided in another claim. It only takes effect if `userNameClaim` is set.
     *
     * @schema KafkaSpecKafkaListenersAuthentication#fallbackUserNameClaim
     */
    readonly fallbackUserNameClaim?: string;

    /**
     * The prefix to use with the value of `fallbackUserNameClaim` to construct the user id. This only takes effect if `fallbackUserNameClaim` is true, and the value is present for the claim. Mapping usernames and client ids into the same user id space is useful in preventing name collisions.
     *
     * @schema KafkaSpecKafkaListenersAuthentication#fallbackUserNamePrefix
     */
    readonly fallbackUserNamePrefix?: string;

    /**
     * JsonPath query used to extract groups for the user during authentication. Extracted groups can be used by a custom authorizer. By default no groups are extracted.
     *
     * @schema KafkaSpecKafkaListenersAuthentication#groupsClaim
     */
    readonly groupsClaim?: string;

    /**
     * A delimiter used to parse groups when they are extracted as a single String value rather than a JSON array. Default value is ',' (comma).
     *
     * @schema KafkaSpecKafkaListenersAuthentication#groupsClaimDelimiter
     */
    readonly groupsClaimDelimiter?: string;

    /**
     * The maximum number of retries to attempt if an initial HTTP request fails. If not set, the default is to not attempt any retries.
     *
     * @schema KafkaSpecKafkaListenersAuthentication#httpRetries
     */
    readonly httpRetries?: number;

    /**
     * The pause to take before retrying a failed HTTP request. If not set, the default is to not pause at all but to immediately repeat a request.
     *
     * @schema KafkaSpecKafkaListenersAuthentication#httpRetryPauseMs
     */
    readonly httpRetryPauseMs?: number;

    /**
     * URI of the token introspection endpoint which can be used to validate opaque non-JWT tokens.
     *
     * @schema KafkaSpecKafkaListenersAuthentication#introspectionEndpointUri
     */
    readonly introspectionEndpointUri?: string;

    /**
     * URI of the JWKS certificate endpoint, which can be used for local JWT validation.
     *
     * @schema KafkaSpecKafkaListenersAuthentication#jwksEndpointUri
     */
    readonly jwksEndpointUri?: string;

    /**
     * Configures how often are the JWKS certificates considered valid. The expiry interval has to be at least 60 seconds longer then the refresh interval specified in `jwksRefreshSeconds`. Defaults to 360 seconds.
     *
     * @default 360 seconds.
     * @schema KafkaSpecKafkaListenersAuthentication#jwksExpirySeconds
     */
    readonly jwksExpirySeconds?: number;

    /**
     * Flag to ignore the 'use' attribute of `key` declarations in a JWKS endpoint response. Default value is `false`.
     *
     * @schema KafkaSpecKafkaListenersAuthentication#jwksIgnoreKeyUse
     */
    readonly jwksIgnoreKeyUse?: boolean;

    /**
     * The minimum pause between two consecutive refreshes. When an unknown signing key is encountered the refresh is scheduled immediately, but will always wait for this minimum pause. Defaults to 1 second.
     *
     * @default 1 second.
     * @schema KafkaSpecKafkaListenersAuthentication#jwksMinRefreshPauseSeconds
     */
    readonly jwksMinRefreshPauseSeconds?: number;

    /**
     * Configures how often are the JWKS certificates refreshed. The refresh interval has to be at least 60 seconds shorter then the expiry interval specified in `jwksExpirySeconds`. Defaults to 300 seconds.
     *
     * @default 300 seconds.
     * @schema KafkaSpecKafkaListenersAuthentication#jwksRefreshSeconds
     */
    readonly jwksRefreshSeconds?: number;

    /**
     * Configuration to be used for a specific listener. All values are prefixed with listener.name._<listener_name>_.
     *
     * @schema KafkaSpecKafkaListenersAuthentication#listenerConfig
     */
    readonly listenerConfig?: any;

    /**
     * Maximum number of seconds the authenticated session remains valid without re-authentication. This enables Apache Kafka re-authentication feature, and causes sessions to expire when the access token expires. If the access token expires before max time or if max time is reached, the client has to re-authenticate, otherwise the server will drop the connection. Not set by default - the authenticated session does not expire when the access token expires. This option only applies to SASL_OAUTHBEARER authentication mechanism (when `enableOauthBearer` is `true`).
     *
     * @schema KafkaSpecKafkaListenersAuthentication#maxSecondsWithoutReauthentication
     */
    readonly maxSecondsWithoutReauthentication?: number;

    /**
     * The read timeout in seconds when connecting to authorization server. If not set, the effective read timeout is 60 seconds.
     *
     * @schema KafkaSpecKafkaListenersAuthentication#readTimeoutSeconds
     */
    readonly readTimeoutSeconds?: number;

    /**
     * Enable or disable SASL on this listener.
     *
     * @schema KafkaSpecKafkaListenersAuthentication#sasl
     */
    readonly sasl?: boolean;

    /**
     * Secrets to be mounted to /opt/kafka/custom-authn-secrets/custom-listener-_<listener_name>-<port>_/_<secret_name>_.
     *
     * @schema KafkaSpecKafkaListenersAuthentication#secrets
     */
    readonly secrets?: KafkaSpecKafkaListenersAuthenticationSecrets[];

    /**
     * Trusted certificates for TLS connection to the OAuth server.
     *
     * @schema KafkaSpecKafkaListenersAuthentication#tlsTrustedCertificates
     */
    readonly tlsTrustedCertificates?: KafkaSpecKafkaListenersAuthenticationTlsTrustedCertificates[];

    /**
     * URI of the Token Endpoint to use with SASL_PLAIN mechanism when the client authenticates with `clientId` and a `secret`. If set, the client can authenticate over SASL_PLAIN by either setting `username` to `clientId`, and setting `password` to client `secret`, or by setting `username` to account username, and `password` to access token prefixed with `$accessToken:`. If this option is not set, the `password` is always interpreted as an access token (without a prefix), and `username` as the account username (a so called 'no-client-credentials' mode).
     *
     * @schema KafkaSpecKafkaListenersAuthentication#tokenEndpointUri
     */
    readonly tokenEndpointUri?: string;

    /**
     * Authentication type. `oauth` type uses SASL OAUTHBEARER Authentication. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `tls` type uses TLS Client Authentication. `tls` type is supported only on TLS listeners.`custom` type allows for any authentication type to be used.
     *
     * @schema KafkaSpecKafkaListenersAuthentication#type
     */
    readonly type: KafkaSpecKafkaListenersAuthenticationType;

    /**
     * URI of the User Info Endpoint to use as a fallback to obtaining the user id when the Introspection Endpoint does not return information that can be used for the user id.
     *
     * @schema KafkaSpecKafkaListenersAuthentication#userInfoEndpointUri
     */
    readonly userInfoEndpointUri?: string;

    /**
     * Name of the claim from the JWT authentication token, Introspection Endpoint response or User Info Endpoint response which will be used to extract the user id. Defaults to `sub`.
     *
     * @default sub`.
     * @schema KafkaSpecKafkaListenersAuthentication#userNameClaim
     */
    readonly userNameClaim?: string;

    /**
     * URI of the token issuer used for authentication.
     *
     * @schema KafkaSpecKafkaListenersAuthentication#validIssuerUri
     */
    readonly validIssuerUri?: string;

    /**
     * Valid value for the `token_type` attribute returned by the Introspection Endpoint. No default value, and not checked by default.
     *
     * @schema KafkaSpecKafkaListenersAuthentication#validTokenType
     */
    readonly validTokenType?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaListenersAuthentication' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaListenersAuthentication(obj: KafkaSpecKafkaListenersAuthentication | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'accessTokenIsJwt': obj.accessTokenIsJwt,
        'checkAccessTokenType': obj.checkAccessTokenType,
        'checkAudience': obj.checkAudience,
        'checkIssuer': obj.checkIssuer,
        'clientAudience': obj.clientAudience,
        'clientId': obj.clientId,
        'clientScope': obj.clientScope,
        'clientSecret': toJson_KafkaSpecKafkaListenersAuthenticationClientSecret(obj.clientSecret),
        'connectTimeoutSeconds': obj.connectTimeoutSeconds,
        'customClaimCheck': obj.customClaimCheck,
        'disableTlsHostnameVerification': obj.disableTlsHostnameVerification,
        'enableECDSA': obj.enableEcdsa,
        'enableMetrics': obj.enableMetrics,
        'enableOauthBearer': obj.enableOauthBearer,
        'enablePlain': obj.enablePlain,
        'failFast': obj.failFast,
        'fallbackUserNameClaim': obj.fallbackUserNameClaim,
        'fallbackUserNamePrefix': obj.fallbackUserNamePrefix,
        'groupsClaim': obj.groupsClaim,
        'groupsClaimDelimiter': obj.groupsClaimDelimiter,
        'httpRetries': obj.httpRetries,
        'httpRetryPauseMs': obj.httpRetryPauseMs,
        'introspectionEndpointUri': obj.introspectionEndpointUri,
        'jwksEndpointUri': obj.jwksEndpointUri,
        'jwksExpirySeconds': obj.jwksExpirySeconds,
        'jwksIgnoreKeyUse': obj.jwksIgnoreKeyUse,
        'jwksMinRefreshPauseSeconds': obj.jwksMinRefreshPauseSeconds,
        'jwksRefreshSeconds': obj.jwksRefreshSeconds,
        'listenerConfig': obj.listenerConfig,
        'maxSecondsWithoutReauthentication': obj.maxSecondsWithoutReauthentication,
        'readTimeoutSeconds': obj.readTimeoutSeconds,
        'sasl': obj.sasl,
        'secrets': obj.secrets?.map(y => toJson_KafkaSpecKafkaListenersAuthenticationSecrets(y)),
        'tlsTrustedCertificates': obj.tlsTrustedCertificates?.map(y => toJson_KafkaSpecKafkaListenersAuthenticationTlsTrustedCertificates(y)),
        'tokenEndpointUri': obj.tokenEndpointUri,
        'type': obj.type,
        'userInfoEndpointUri': obj.userInfoEndpointUri,
        'userNameClaim': obj.userNameClaim,
        'validIssuerUri': obj.validIssuerUri,
        'validTokenType': obj.validTokenType,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Additional listener configuration.
 *
 * @schema KafkaSpecKafkaListenersConfiguration
 */
export interface KafkaSpecKafkaListenersConfiguration {
    /**
     * Reference to the `Secret` which holds the certificate and private key pair which will be used for this listener. The certificate can optionally contain the whole chain. This field can be used only with listeners with enabled TLS encryption.
     *
     * @schema KafkaSpecKafkaListenersConfiguration#brokerCertChainAndKey
     */
    readonly brokerCertChainAndKey?: KafkaSpecKafkaListenersConfigurationBrokerCertChainAndKey;

    /**
     * Specifies whether the service routes external traffic to node-local or cluster-wide endpoints. `Cluster` may cause a second hop to another node and obscures the client source IP. `Local` avoids a second hop for LoadBalancer and Nodeport type services and preserves the client source IP (when supported by the infrastructure). If unspecified, Kubernetes will use `Cluster` as the default.This field can be used only with `loadbalancer` or `nodeport` type listener.
     *
     * @schema KafkaSpecKafkaListenersConfiguration#externalTrafficPolicy
     */
    readonly externalTrafficPolicy?: KafkaSpecKafkaListenersConfigurationExternalTrafficPolicy;

    /**
     * A list of CIDR ranges (for example `10.0.0.0/8` or `130.211.204.1/32`) from which clients can connect to load balancer type listeners. If supported by the platform, traffic through the loadbalancer is restricted to the specified CIDR ranges. This field is applicable only for loadbalancer type services and is ignored if the cloud provider does not support the feature. This field can be used only with `loadbalancer` type listener.
     *
     * @schema KafkaSpecKafkaListenersConfiguration#loadBalancerSourceRanges
     */
    readonly loadBalancerSourceRanges?: string[];

    /**
     * Bootstrap configuration.
     *
     * @schema KafkaSpecKafkaListenersConfiguration#bootstrap
     */
    readonly bootstrap?: KafkaSpecKafkaListenersConfigurationBootstrap;

    /**
     * Per-broker configurations.
     *
     * @schema KafkaSpecKafkaListenersConfiguration#brokers
     */
    readonly brokers?: KafkaSpecKafkaListenersConfigurationBrokers[];

    /**
     * Specifies the IP Family Policy used by the service. Available options are `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a single IP family. `PreferDualStack` is for two IP families on dual-stack configured clusters or a single IP family on single-stack clusters. `RequireDualStack` fails unless there are two IP families on dual-stack configured clusters. If unspecified, Kubernetes will choose the default value based on the service type. Available on Kubernetes 1.20 and newer.
     *
     * @schema KafkaSpecKafkaListenersConfiguration#ipFamilyPolicy
     */
    readonly ipFamilyPolicy?: KafkaSpecKafkaListenersConfigurationIpFamilyPolicy;

    /**
     * Specifies the IP Families used by the service. Available options are `IPv4` and `IPv6. If unspecified, Kubernetes will choose the default value based on the `ipFamilyPolicy` setting. Available on Kubernetes 1.20 and newer.
     *
     * @schema KafkaSpecKafkaListenersConfiguration#ipFamilies
     */
    readonly ipFamilies?: KafkaSpecKafkaListenersConfigurationIpFamilies[];

    /**
     * Whether to create the bootstrap service or not. The bootstrap service is created by default (if not specified differently). This field can be used with the `loadBalancer` type listener.
     *
     * @schema KafkaSpecKafkaListenersConfiguration#createBootstrapService
     */
    readonly createBootstrapService?: boolean;

    /**
     * Configures a specific class for `Ingress` and `LoadBalancer` that defines which controller will be used. This field can only be used with `ingress` and `loadbalancer` type listeners. If not specified, the default controller is used. For an `ingress` listener, set the `ingressClassName` property in the `Ingress` resources. For a `loadbalancer` listener, set the `loadBalancerClass` property  in the `Service` resources.
     *
     * @schema KafkaSpecKafkaListenersConfiguration#class
     */
    readonly class?: string;

    /**
     * A list of finalizers which will be configured for the `LoadBalancer` type Services created for this listener. If supported by the platform, the finalizer `service.kubernetes.io/load-balancer-cleanup` to make sure that the external load balancer is deleted together with the service.For more information, see https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/#garbage-collecting-load-balancers. This field can be used only with `loadbalancer` type listeners.
     *
     * @schema KafkaSpecKafkaListenersConfiguration#finalizers
     */
    readonly finalizers?: string[];

    /**
     * The maximum connection creation rate we allow in this listener at any time. New connections will be throttled if the limit is reached.
     *
     * @schema KafkaSpecKafkaListenersConfiguration#maxConnectionCreationRate
     */
    readonly maxConnectionCreationRate?: number;

    /**
     * The maximum number of connections we allow for this listener in the broker at any time. New connections are blocked if the limit is reached.
     *
     * @schema KafkaSpecKafkaListenersConfiguration#maxConnections
     */
    readonly maxConnections?: number;

    /**
     * Defines which address type should be used as the node address. Available types are: `ExternalDNS`, `ExternalIP`, `InternalDNS`, `InternalIP` and `Hostname`. By default, the addresses will be used in the following order (the first one found will be used):
     *
     * * `ExternalDNS`
     * * `ExternalIP`
     * * `InternalDNS`
     * * `InternalIP`
     * * `Hostname`
     *
     * This field is used to select the preferred address type, which is checked first. If no address is found for this address type, the other types are checked in the default order. This field can only be used with `nodeport` type listener.
     *
     * @schema KafkaSpecKafkaListenersConfiguration#preferredNodePortAddressType
     */
    readonly preferredNodePortAddressType?: KafkaSpecKafkaListenersConfigurationPreferredNodePortAddressType;

    /**
     * Configures whether the Kubernetes service DNS domain should be used or not. If set to `true`, the generated addresses will contain the service DNS domain suffix (by default `.cluster.local`, can be configured using environment variable `KUBERNETES_SERVICE_DNS_DOMAIN`). Defaults to `false`.This field can be used only with `internal` and `cluster-ip` type listeners.
     *
     * @default false`.This field can be used only with `internal` and `cluster-ip` type listeners.
     * @schema KafkaSpecKafkaListenersConfiguration#useServiceDnsDomain
     */
    readonly useServiceDnsDomain?: boolean;

}

/**
 * Converts an object of type 'KafkaSpecKafkaListenersConfiguration' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaListenersConfiguration(obj: KafkaSpecKafkaListenersConfiguration | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'brokerCertChainAndKey': toJson_KafkaSpecKafkaListenersConfigurationBrokerCertChainAndKey(obj.brokerCertChainAndKey),
        'externalTrafficPolicy': obj.externalTrafficPolicy,
        'loadBalancerSourceRanges': obj.loadBalancerSourceRanges?.map(y => y),
        'bootstrap': toJson_KafkaSpecKafkaListenersConfigurationBootstrap(obj.bootstrap),
        'brokers': obj.brokers?.map(y => toJson_KafkaSpecKafkaListenersConfigurationBrokers(y)),
        'ipFamilyPolicy': obj.ipFamilyPolicy,
        'ipFamilies': obj.ipFamilies?.map(y => y),
        'createBootstrapService': obj.createBootstrapService,
        'class': obj.class,
        'finalizers': obj.finalizers?.map(y => y),
        'maxConnectionCreationRate': obj.maxConnectionCreationRate,
        'maxConnections': obj.maxConnections,
        'preferredNodePortAddressType': obj.preferredNodePortAddressType,
        'useServiceDnsDomain': obj.useServiceDnsDomain,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaListenersNetworkPolicyPeers
 */
export interface KafkaSpecKafkaListenersNetworkPolicyPeers {
    /**
     * @schema KafkaSpecKafkaListenersNetworkPolicyPeers#ipBlock
     */
    readonly ipBlock?: KafkaSpecKafkaListenersNetworkPolicyPeersIpBlock;

    /**
     * @schema KafkaSpecKafkaListenersNetworkPolicyPeers#namespaceSelector
     */
    readonly namespaceSelector?: KafkaSpecKafkaListenersNetworkPolicyPeersNamespaceSelector;

    /**
     * @schema KafkaSpecKafkaListenersNetworkPolicyPeers#podSelector
     */
    readonly podSelector?: KafkaSpecKafkaListenersNetworkPolicyPeersPodSelector;

}

/**
 * Converts an object of type 'KafkaSpecKafkaListenersNetworkPolicyPeers' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaListenersNetworkPolicyPeers(obj: KafkaSpecKafkaListenersNetworkPolicyPeers | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'ipBlock': toJson_KafkaSpecKafkaListenersNetworkPolicyPeersIpBlock(obj.ipBlock),
        'namespaceSelector': toJson_KafkaSpecKafkaListenersNetworkPolicyPeersNamespaceSelector(obj.namespaceSelector),
        'podSelector': toJson_KafkaSpecKafkaListenersNetworkPolicyPeersPodSelector(obj.podSelector),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaStorageOverrides
 */
export interface KafkaSpecKafkaStorageOverrides {
    /**
     * The storage class to use for dynamic volume allocation for this broker.
     *
     * @schema KafkaSpecKafkaStorageOverrides#class
     */
    readonly class?: string;

    /**
     * Id of the kafka broker (broker identifier).
     *
     * @schema KafkaSpecKafkaStorageOverrides#broker
     */
    readonly broker?: number;

}

/**
 * Converts an object of type 'KafkaSpecKafkaStorageOverrides' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaStorageOverrides(obj: KafkaSpecKafkaStorageOverrides | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'class': obj.class,
        'broker': obj.broker,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Storage type, must be either 'ephemeral', 'persistent-claim', or 'jbod'.
 *
 * @schema KafkaSpecKafkaStorageType
 */
export enum KafkaSpecKafkaStorageType {
    /** ephemeral */
    EPHEMERAL = "ephemeral",
    /** persistent-claim */
    PERSISTENT_CLAIM = "persistent-claim",
    /** jbod */
    JBOD = "jbod",
}

/**
 * @schema KafkaSpecKafkaStorageVolumes
 */
export interface KafkaSpecKafkaStorageVolumes {
    /**
     * The storage class to use for dynamic volume allocation.
     *
     * @schema KafkaSpecKafkaStorageVolumes#class
     */
    readonly class?: string;

    /**
     * Specifies if the persistent volume claim has to be deleted when the cluster is un-deployed.
     *
     * @schema KafkaSpecKafkaStorageVolumes#deleteClaim
     */
    readonly deleteClaim?: boolean;

    /**
     * Storage identification number. It is mandatory only for storage volumes defined in a storage of type 'jbod'.
     *
     * @schema KafkaSpecKafkaStorageVolumes#id
     */
    readonly id?: number;

    /**
     * Overrides for individual brokers. The `overrides` field allows to specify a different configuration for different brokers.
     *
     * @schema KafkaSpecKafkaStorageVolumes#overrides
     */
    readonly overrides?: KafkaSpecKafkaStorageVolumesOverrides[];

    /**
     * Specifies a specific persistent volume to use. It contains key:value pairs representing labels for selecting such a volume.
     *
     * @schema KafkaSpecKafkaStorageVolumes#selector
     */
    readonly selector?: any;

    /**
     * When type=persistent-claim, defines the size of the persistent volume claim (i.e 1Gi). Mandatory when type=persistent-claim.
     *
     * @schema KafkaSpecKafkaStorageVolumes#size
     */
    readonly size?: string;

    /**
     * When type=ephemeral, defines the total amount of local storage required for this EmptyDir volume (for example 1Gi).
     *
     * @schema KafkaSpecKafkaStorageVolumes#sizeLimit
     */
    readonly sizeLimit?: string;

    /**
     * Storage type, must be either 'ephemeral' or 'persistent-claim'.
     *
     * @schema KafkaSpecKafkaStorageVolumes#type
     */
    readonly type: KafkaSpecKafkaStorageVolumesType;

}

/**
 * Converts an object of type 'KafkaSpecKafkaStorageVolumes' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaStorageVolumes(obj: KafkaSpecKafkaStorageVolumes | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'class': obj.class,
        'deleteClaim': obj.deleteClaim,
        'id': obj.id,
        'overrides': obj.overrides?.map(y => toJson_KafkaSpecKafkaStorageVolumesOverrides(y)),
        'selector': obj.selector,
        'size': obj.size,
        'sizeLimit': obj.sizeLimit,
        'type': obj.type,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaAuthorizationTlsTrustedCertificates
 */
export interface KafkaSpecKafkaAuthorizationTlsTrustedCertificates {
    /**
     * The name of the file certificate in the Secret.
     *
     * @schema KafkaSpecKafkaAuthorizationTlsTrustedCertificates#certificate
     */
    readonly certificate: string;

    /**
     * The name of the Secret containing the certificate.
     *
     * @schema KafkaSpecKafkaAuthorizationTlsTrustedCertificates#secretName
     */
    readonly secretName: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaAuthorizationTlsTrustedCertificates' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaAuthorizationTlsTrustedCertificates(obj: KafkaSpecKafkaAuthorizationTlsTrustedCertificates | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'certificate': obj.certificate,
        'secretName': obj.secretName,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Authorization type. Currently, the supported types are `simple`, `keycloak`, `opa` and `custom`. `simple` authorization type uses Kafka's `kafka.security.authorizer.AclAuthorizer` class for authorization. `keycloak` authorization type uses Keycloak Authorization Services for authorization. `opa` authorization type uses Open Policy Agent based authorization.`custom` authorization type uses user-provided implementation for authorization.
 *
 * @schema KafkaSpecKafkaAuthorizationType
 */
export enum KafkaSpecKafkaAuthorizationType {
    /** simple */
    SIMPLE = "simple",
    /** opa */
    OPA = "opa",
    /** keycloak */
    KEYCLOAK = "keycloak",
    /** custom */
    CUSTOM = "custom",
}

/**
 * @schema KafkaSpecKafkaJvmOptionsJavaSystemProperties
 */
export interface KafkaSpecKafkaJvmOptionsJavaSystemProperties {
    /**
     * The system property name.
     *
     * @schema KafkaSpecKafkaJvmOptionsJavaSystemProperties#name
     */
    readonly name?: string;

    /**
     * The system property value.
     *
     * @schema KafkaSpecKafkaJvmOptionsJavaSystemProperties#value
     */
    readonly value?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaJvmOptionsJavaSystemProperties' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaJvmOptionsJavaSystemProperties(obj: KafkaSpecKafkaJvmOptionsJavaSystemProperties | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Authentication configuration for connecting to the JMX port.
 *
 * @schema KafkaSpecKafkaJmxOptionsAuthentication
 */
export interface KafkaSpecKafkaJmxOptionsAuthentication {
    /**
     * Authentication type. Currently the only supported types are `password`.`password` type creates a username and protected port with no TLS.
     *
     * @schema KafkaSpecKafkaJmxOptionsAuthentication#type
     */
    readonly type: KafkaSpecKafkaJmxOptionsAuthenticationType;

}

/**
 * Converts an object of type 'KafkaSpecKafkaJmxOptionsAuthentication' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaJmxOptionsAuthentication(obj: KafkaSpecKafkaJmxOptionsAuthentication | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'type': obj.type,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaResourcesClaims
 */
export interface KafkaSpecKafkaResourcesClaims {
    /**
     * @schema KafkaSpecKafkaResourcesClaims#name
     */
    readonly name?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaResourcesClaims' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaResourcesClaims(obj: KafkaSpecKafkaResourcesClaims | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Metrics type. Only 'jmxPrometheusExporter' supported currently.
 *
 * @schema KafkaSpecKafkaMetricsConfigType
 */
export enum KafkaSpecKafkaMetricsConfigType {
    /** jmxPrometheusExporter */
    JMX_PROMETHEUS_EXPORTER = "jmxPrometheusExporter",
}

/**
 * ConfigMap entry where the Prometheus JMX Exporter configuration is stored. For details of the structure of this configuration, see the {JMXExporter}.
 *
 * @schema KafkaSpecKafkaMetricsConfigValueFrom
 */
export interface KafkaSpecKafkaMetricsConfigValueFrom {
    /**
     * Reference to the key in the ConfigMap containing the configuration.
     *
     * @schema KafkaSpecKafkaMetricsConfigValueFrom#configMapKeyRef
     */
    readonly configMapKeyRef?: KafkaSpecKafkaMetricsConfigValueFromConfigMapKeyRef;

}

/**
 * Converts an object of type 'KafkaSpecKafkaMetricsConfigValueFrom' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaMetricsConfigValueFrom(obj: KafkaSpecKafkaMetricsConfigValueFrom | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'configMapKeyRef': toJson_KafkaSpecKafkaMetricsConfigValueFromConfigMapKeyRef(obj.configMapKeyRef),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Logging type, must be either 'inline' or 'external'.
 *
 * @schema KafkaSpecKafkaLoggingType
 */
export enum KafkaSpecKafkaLoggingType {
    /** inline */
    INLINE = "inline",
    /** external */
    EXTERNAL = "external",
}

/**
 * `ConfigMap` entry where the logging configuration is stored.
 *
 * @schema KafkaSpecKafkaLoggingValueFrom
 */
export interface KafkaSpecKafkaLoggingValueFrom {
    /**
     * Reference to the key in the ConfigMap containing the configuration.
     *
     * @schema KafkaSpecKafkaLoggingValueFrom#configMapKeyRef
     */
    readonly configMapKeyRef?: KafkaSpecKafkaLoggingValueFromConfigMapKeyRef;

}

/**
 * Converts an object of type 'KafkaSpecKafkaLoggingValueFrom' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaLoggingValueFrom(obj: KafkaSpecKafkaLoggingValueFrom | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'configMapKeyRef': toJson_KafkaSpecKafkaLoggingValueFromConfigMapKeyRef(obj.configMapKeyRef),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka `StatefulSet`.
 *
 * @schema KafkaSpecKafkaTemplateStatefulset
 */
export interface KafkaSpecKafkaTemplateStatefulset {
    /**
     * Metadata applied to the resource.
     *
     * @schema KafkaSpecKafkaTemplateStatefulset#metadata
     */
    readonly metadata?: KafkaSpecKafkaTemplateStatefulsetMetadata;

    /**
     * PodManagementPolicy which will be used for this StatefulSet. Valid values are `Parallel` and `OrderedReady`. Defaults to `Parallel`.
     *
     * @default Parallel`.
     * @schema KafkaSpecKafkaTemplateStatefulset#podManagementPolicy
     */
    readonly podManagementPolicy?: KafkaSpecKafkaTemplateStatefulsetPodManagementPolicy;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateStatefulset' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateStatefulset(obj: KafkaSpecKafkaTemplateStatefulset | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_KafkaSpecKafkaTemplateStatefulsetMetadata(obj.metadata),
        'podManagementPolicy': obj.podManagementPolicy,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka `Pods`.
 *
 * @schema KafkaSpecKafkaTemplatePod
 */
export interface KafkaSpecKafkaTemplatePod {
    /**
     * Metadata applied to the resource.
     *
     * @schema KafkaSpecKafkaTemplatePod#metadata
     */
    readonly metadata?: KafkaSpecKafkaTemplatePodMetadata;

    /**
     * List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
     *
     * @schema KafkaSpecKafkaTemplatePod#imagePullSecrets
     */
    readonly imagePullSecrets?: KafkaSpecKafkaTemplatePodImagePullSecrets[];

    /**
     * Configures pod-level security attributes and common container settings.
     *
     * @schema KafkaSpecKafkaTemplatePod#securityContext
     */
    readonly securityContext?: KafkaSpecKafkaTemplatePodSecurityContext;

    /**
     * The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
     *
     * @default 30 seconds.
     * @schema KafkaSpecKafkaTemplatePod#terminationGracePeriodSeconds
     */
    readonly terminationGracePeriodSeconds?: number;

    /**
     * The pod's affinity rules.
     *
     * @schema KafkaSpecKafkaTemplatePod#affinity
     */
    readonly affinity?: KafkaSpecKafkaTemplatePodAffinity;

    /**
     * The pod's tolerations.
     *
     * @schema KafkaSpecKafkaTemplatePod#tolerations
     */
    readonly tolerations?: KafkaSpecKafkaTemplatePodTolerations[];

    /**
     * The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
     *
     * @schema KafkaSpecKafkaTemplatePod#priorityClassName
     */
    readonly priorityClassName?: string;

    /**
     * The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
     *
     * @schema KafkaSpecKafkaTemplatePod#schedulerName
     */
    readonly schedulerName?: string;

    /**
     * The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the Pod's hosts file if specified.
     *
     * @schema KafkaSpecKafkaTemplatePod#hostAliases
     */
    readonly hostAliases?: KafkaSpecKafkaTemplatePodHostAliases[];

    /**
     * Defines the total amount (for example `1Gi`) of local storage required for temporary EmptyDir volume (`/tmp`). Default value is `5Mi`.
     *
     * @schema KafkaSpecKafkaTemplatePod#tmpDirSizeLimit
     */
    readonly tmpDirSizeLimit?: string;

    /**
     * Indicates whether information about services should be injected into Pod's environment variables.
     *
     * @schema KafkaSpecKafkaTemplatePod#enableServiceLinks
     */
    readonly enableServiceLinks?: boolean;

    /**
     * The pod's topology spread constraints.
     *
     * @schema KafkaSpecKafkaTemplatePod#topologySpreadConstraints
     */
    readonly topologySpreadConstraints?: KafkaSpecKafkaTemplatePodTopologySpreadConstraints[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePod' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePod(obj: KafkaSpecKafkaTemplatePod | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_KafkaSpecKafkaTemplatePodMetadata(obj.metadata),
        'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_KafkaSpecKafkaTemplatePodImagePullSecrets(y)),
        'securityContext': toJson_KafkaSpecKafkaTemplatePodSecurityContext(obj.securityContext),
        'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
        'affinity': toJson_KafkaSpecKafkaTemplatePodAffinity(obj.affinity),
        'tolerations': obj.tolerations?.map(y => toJson_KafkaSpecKafkaTemplatePodTolerations(y)),
        'priorityClassName': obj.priorityClassName,
        'schedulerName': obj.schedulerName,
        'hostAliases': obj.hostAliases?.map(y => toJson_KafkaSpecKafkaTemplatePodHostAliases(y)),
        'tmpDirSizeLimit': obj.tmpDirSizeLimit,
        'enableServiceLinks': obj.enableServiceLinks,
        'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => toJson_KafkaSpecKafkaTemplatePodTopologySpreadConstraints(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka bootstrap `Service`.
 *
 * @schema KafkaSpecKafkaTemplateBootstrapService
 */
export interface KafkaSpecKafkaTemplateBootstrapService {
    /**
     * Metadata applied to the resource.
     *
     * @schema KafkaSpecKafkaTemplateBootstrapService#metadata
     */
    readonly metadata?: KafkaSpecKafkaTemplateBootstrapServiceMetadata;

    /**
     * Specifies the IP Family Policy used by the service. Available options are `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a single IP family. `PreferDualStack` is for two IP families on dual-stack configured clusters or a single IP family on single-stack clusters. `RequireDualStack` fails unless there are two IP families on dual-stack configured clusters. If unspecified, Kubernetes will choose the default value based on the service type. Available on Kubernetes 1.20 and newer.
     *
     * @schema KafkaSpecKafkaTemplateBootstrapService#ipFamilyPolicy
     */
    readonly ipFamilyPolicy?: KafkaSpecKafkaTemplateBootstrapServiceIpFamilyPolicy;

    /**
     * Specifies the IP Families used by the service. Available options are `IPv4` and `IPv6. If unspecified, Kubernetes will choose the default value based on the `ipFamilyPolicy` setting. Available on Kubernetes 1.20 and newer.
     *
     * @schema KafkaSpecKafkaTemplateBootstrapService#ipFamilies
     */
    readonly ipFamilies?: KafkaSpecKafkaTemplateBootstrapServiceIpFamilies[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateBootstrapService' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateBootstrapService(obj: KafkaSpecKafkaTemplateBootstrapService | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_KafkaSpecKafkaTemplateBootstrapServiceMetadata(obj.metadata),
        'ipFamilyPolicy': obj.ipFamilyPolicy,
        'ipFamilies': obj.ipFamilies?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka broker `Service`.
 *
 * @schema KafkaSpecKafkaTemplateBrokersService
 */
export interface KafkaSpecKafkaTemplateBrokersService {
    /**
     * Metadata applied to the resource.
     *
     * @schema KafkaSpecKafkaTemplateBrokersService#metadata
     */
    readonly metadata?: KafkaSpecKafkaTemplateBrokersServiceMetadata;

    /**
     * Specifies the IP Family Policy used by the service. Available options are `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a single IP family. `PreferDualStack` is for two IP families on dual-stack configured clusters or a single IP family on single-stack clusters. `RequireDualStack` fails unless there are two IP families on dual-stack configured clusters. If unspecified, Kubernetes will choose the default value based on the service type. Available on Kubernetes 1.20 and newer.
     *
     * @schema KafkaSpecKafkaTemplateBrokersService#ipFamilyPolicy
     */
    readonly ipFamilyPolicy?: KafkaSpecKafkaTemplateBrokersServiceIpFamilyPolicy;

    /**
     * Specifies the IP Families used by the service. Available options are `IPv4` and `IPv6. If unspecified, Kubernetes will choose the default value based on the `ipFamilyPolicy` setting. Available on Kubernetes 1.20 and newer.
     *
     * @schema KafkaSpecKafkaTemplateBrokersService#ipFamilies
     */
    readonly ipFamilies?: KafkaSpecKafkaTemplateBrokersServiceIpFamilies[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateBrokersService' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateBrokersService(obj: KafkaSpecKafkaTemplateBrokersService | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_KafkaSpecKafkaTemplateBrokersServiceMetadata(obj.metadata),
        'ipFamilyPolicy': obj.ipFamilyPolicy,
        'ipFamilies': obj.ipFamilies?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka external bootstrap `Service`.
 *
 * @schema KafkaSpecKafkaTemplateExternalBootstrapService
 */
export interface KafkaSpecKafkaTemplateExternalBootstrapService {
    /**
     * Metadata applied to the resource.
     *
     * @schema KafkaSpecKafkaTemplateExternalBootstrapService#metadata
     */
    readonly metadata?: KafkaSpecKafkaTemplateExternalBootstrapServiceMetadata;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateExternalBootstrapService' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateExternalBootstrapService(obj: KafkaSpecKafkaTemplateExternalBootstrapService | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_KafkaSpecKafkaTemplateExternalBootstrapServiceMetadata(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka per-pod `Services` used for access from outside of Kubernetes.
 *
 * @schema KafkaSpecKafkaTemplatePerPodService
 */
export interface KafkaSpecKafkaTemplatePerPodService {
    /**
     * Metadata applied to the resource.
     *
     * @schema KafkaSpecKafkaTemplatePerPodService#metadata
     */
    readonly metadata?: KafkaSpecKafkaTemplatePerPodServiceMetadata;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePerPodService' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePerPodService(obj: KafkaSpecKafkaTemplatePerPodService | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_KafkaSpecKafkaTemplatePerPodServiceMetadata(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka external bootstrap `Route`.
 *
 * @schema KafkaSpecKafkaTemplateExternalBootstrapRoute
 */
export interface KafkaSpecKafkaTemplateExternalBootstrapRoute {
    /**
     * Metadata applied to the resource.
     *
     * @schema KafkaSpecKafkaTemplateExternalBootstrapRoute#metadata
     */
    readonly metadata?: KafkaSpecKafkaTemplateExternalBootstrapRouteMetadata;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateExternalBootstrapRoute' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateExternalBootstrapRoute(obj: KafkaSpecKafkaTemplateExternalBootstrapRoute | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_KafkaSpecKafkaTemplateExternalBootstrapRouteMetadata(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka per-pod `Routes` used for access from outside of OpenShift.
 *
 * @schema KafkaSpecKafkaTemplatePerPodRoute
 */
export interface KafkaSpecKafkaTemplatePerPodRoute {
    /**
     * Metadata applied to the resource.
     *
     * @schema KafkaSpecKafkaTemplatePerPodRoute#metadata
     */
    readonly metadata?: KafkaSpecKafkaTemplatePerPodRouteMetadata;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePerPodRoute' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePerPodRoute(obj: KafkaSpecKafkaTemplatePerPodRoute | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_KafkaSpecKafkaTemplatePerPodRouteMetadata(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka external bootstrap `Ingress`.
 *
 * @schema KafkaSpecKafkaTemplateExternalBootstrapIngress
 */
export interface KafkaSpecKafkaTemplateExternalBootstrapIngress {
    /**
     * Metadata applied to the resource.
     *
     * @schema KafkaSpecKafkaTemplateExternalBootstrapIngress#metadata
     */
    readonly metadata?: KafkaSpecKafkaTemplateExternalBootstrapIngressMetadata;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateExternalBootstrapIngress' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateExternalBootstrapIngress(obj: KafkaSpecKafkaTemplateExternalBootstrapIngress | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_KafkaSpecKafkaTemplateExternalBootstrapIngressMetadata(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka per-pod `Ingress` used for access from outside of Kubernetes.
 *
 * @schema KafkaSpecKafkaTemplatePerPodIngress
 */
export interface KafkaSpecKafkaTemplatePerPodIngress {
    /**
     * Metadata applied to the resource.
     *
     * @schema KafkaSpecKafkaTemplatePerPodIngress#metadata
     */
    readonly metadata?: KafkaSpecKafkaTemplatePerPodIngressMetadata;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePerPodIngress' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePerPodIngress(obj: KafkaSpecKafkaTemplatePerPodIngress | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_KafkaSpecKafkaTemplatePerPodIngressMetadata(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for all Kafka `PersistentVolumeClaims`.
 *
 * @schema KafkaSpecKafkaTemplatePersistentVolumeClaim
 */
export interface KafkaSpecKafkaTemplatePersistentVolumeClaim {
    /**
     * Metadata applied to the resource.
     *
     * @schema KafkaSpecKafkaTemplatePersistentVolumeClaim#metadata
     */
    readonly metadata?: KafkaSpecKafkaTemplatePersistentVolumeClaimMetadata;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePersistentVolumeClaim' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePersistentVolumeClaim(obj: KafkaSpecKafkaTemplatePersistentVolumeClaim | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_KafkaSpecKafkaTemplatePersistentVolumeClaimMetadata(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka `PodDisruptionBudget`.
 *
 * @schema KafkaSpecKafkaTemplatePodDisruptionBudget
 */
export interface KafkaSpecKafkaTemplatePodDisruptionBudget {
    /**
     * Metadata to apply to the `PodDisruptionBudgetTemplate` resource.
     *
     * @schema KafkaSpecKafkaTemplatePodDisruptionBudget#metadata
     */
    readonly metadata?: KafkaSpecKafkaTemplatePodDisruptionBudgetMetadata;

    /**
     * Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
     *
     * @default 1.
     * @schema KafkaSpecKafkaTemplatePodDisruptionBudget#maxUnavailable
     */
    readonly maxUnavailable?: number;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodDisruptionBudget' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodDisruptionBudget(obj: KafkaSpecKafkaTemplatePodDisruptionBudget | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_KafkaSpecKafkaTemplatePodDisruptionBudgetMetadata(obj.metadata),
        'maxUnavailable': obj.maxUnavailable,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for the Kafka broker container.
 *
 * @schema KafkaSpecKafkaTemplateKafkaContainer
 */
export interface KafkaSpecKafkaTemplateKafkaContainer {
    /**
     * Environment variables which should be applied to the container.
     *
     * @schema KafkaSpecKafkaTemplateKafkaContainer#env
     */
    readonly env?: KafkaSpecKafkaTemplateKafkaContainerEnv[];

    /**
     * Security context for the container.
     *
     * @schema KafkaSpecKafkaTemplateKafkaContainer#securityContext
     */
    readonly securityContext?: KafkaSpecKafkaTemplateKafkaContainerSecurityContext;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateKafkaContainer' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateKafkaContainer(obj: KafkaSpecKafkaTemplateKafkaContainer | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'env': obj.env?.map(y => toJson_KafkaSpecKafkaTemplateKafkaContainerEnv(y)),
        'securityContext': toJson_KafkaSpecKafkaTemplateKafkaContainerSecurityContext(obj.securityContext),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for the Kafka init container.
 *
 * @schema KafkaSpecKafkaTemplateInitContainer
 */
export interface KafkaSpecKafkaTemplateInitContainer {
    /**
     * Environment variables which should be applied to the container.
     *
     * @schema KafkaSpecKafkaTemplateInitContainer#env
     */
    readonly env?: KafkaSpecKafkaTemplateInitContainerEnv[];

    /**
     * Security context for the container.
     *
     * @schema KafkaSpecKafkaTemplateInitContainer#securityContext
     */
    readonly securityContext?: KafkaSpecKafkaTemplateInitContainerSecurityContext;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateInitContainer' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateInitContainer(obj: KafkaSpecKafkaTemplateInitContainer | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'env': obj.env?.map(y => toJson_KafkaSpecKafkaTemplateInitContainerEnv(y)),
        'securityContext': toJson_KafkaSpecKafkaTemplateInitContainerSecurityContext(obj.securityContext),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for Secret with Kafka Cluster certificate public key.
 *
 * @schema KafkaSpecKafkaTemplateClusterCaCert
 */
export interface KafkaSpecKafkaTemplateClusterCaCert {
    /**
     * Metadata applied to the resource.
     *
     * @schema KafkaSpecKafkaTemplateClusterCaCert#metadata
     */
    readonly metadata?: KafkaSpecKafkaTemplateClusterCaCertMetadata;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateClusterCaCert' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateClusterCaCert(obj: KafkaSpecKafkaTemplateClusterCaCert | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_KafkaSpecKafkaTemplateClusterCaCertMetadata(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for the Kafka service account.
 *
 * @schema KafkaSpecKafkaTemplateServiceAccount
 */
export interface KafkaSpecKafkaTemplateServiceAccount {
    /**
     * Metadata applied to the resource.
     *
     * @schema KafkaSpecKafkaTemplateServiceAccount#metadata
     */
    readonly metadata?: KafkaSpecKafkaTemplateServiceAccountMetadata;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateServiceAccount' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateServiceAccount(obj: KafkaSpecKafkaTemplateServiceAccount | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_KafkaSpecKafkaTemplateServiceAccountMetadata(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for Secret of the Kafka Cluster JMX authentication.
 *
 * @schema KafkaSpecKafkaTemplateJmxSecret
 */
export interface KafkaSpecKafkaTemplateJmxSecret {
    /**
     * Metadata applied to the resource.
     *
     * @schema KafkaSpecKafkaTemplateJmxSecret#metadata
     */
    readonly metadata?: KafkaSpecKafkaTemplateJmxSecretMetadata;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateJmxSecret' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateJmxSecret(obj: KafkaSpecKafkaTemplateJmxSecret | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_KafkaSpecKafkaTemplateJmxSecretMetadata(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for the Kafka ClusterRoleBinding.
 *
 * @schema KafkaSpecKafkaTemplateClusterRoleBinding
 */
export interface KafkaSpecKafkaTemplateClusterRoleBinding {
    /**
     * Metadata applied to the resource.
     *
     * @schema KafkaSpecKafkaTemplateClusterRoleBinding#metadata
     */
    readonly metadata?: KafkaSpecKafkaTemplateClusterRoleBindingMetadata;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateClusterRoleBinding' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateClusterRoleBinding(obj: KafkaSpecKafkaTemplateClusterRoleBinding | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_KafkaSpecKafkaTemplateClusterRoleBindingMetadata(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka `StrimziPodSet` resource.
 *
 * @schema KafkaSpecKafkaTemplatePodSet
 */
export interface KafkaSpecKafkaTemplatePodSet {
    /**
     * Metadata applied to the resource.
     *
     * @schema KafkaSpecKafkaTemplatePodSet#metadata
     */
    readonly metadata?: KafkaSpecKafkaTemplatePodSetMetadata;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodSet' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodSet(obj: KafkaSpecKafkaTemplatePodSet | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_KafkaSpecKafkaTemplatePodSetMetadata(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperStorageOverrides
 */
export interface KafkaSpecZookeeperStorageOverrides {
    /**
     * The storage class to use for dynamic volume allocation for this broker.
     *
     * @schema KafkaSpecZookeeperStorageOverrides#class
     */
    readonly class?: string;

    /**
     * Id of the kafka broker (broker identifier).
     *
     * @schema KafkaSpecZookeeperStorageOverrides#broker
     */
    readonly broker?: number;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperStorageOverrides' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperStorageOverrides(obj: KafkaSpecZookeeperStorageOverrides | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'class': obj.class,
        'broker': obj.broker,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Storage type, must be either 'ephemeral' or 'persistent-claim'.
 *
 * @schema KafkaSpecZookeeperStorageType
 */
export enum KafkaSpecZookeeperStorageType {
    /** ephemeral */
    EPHEMERAL = "ephemeral",
    /** persistent-claim */
    PERSISTENT_CLAIM = "persistent-claim",
}

/**
 * @schema KafkaSpecZookeeperJvmOptionsJavaSystemProperties
 */
export interface KafkaSpecZookeeperJvmOptionsJavaSystemProperties {
    /**
     * The system property name.
     *
     * @schema KafkaSpecZookeeperJvmOptionsJavaSystemProperties#name
     */
    readonly name?: string;

    /**
     * The system property value.
     *
     * @schema KafkaSpecZookeeperJvmOptionsJavaSystemProperties#value
     */
    readonly value?: string;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperJvmOptionsJavaSystemProperties' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperJvmOptionsJavaSystemProperties(obj: KafkaSpecZookeeperJvmOptionsJavaSystemProperties | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Authentication configuration for connecting to the JMX port.
 *
 * @schema KafkaSpecZookeeperJmxOptionsAuthentication
 */
export interface KafkaSpecZookeeperJmxOptionsAuthentication {
    /**
     * Authentication type. Currently the only supported types are `password`.`password` type creates a username and protected port with no TLS.
     *
     * @schema KafkaSpecZookeeperJmxOptionsAuthentication#type
     */
    readonly type: KafkaSpecZookeeperJmxOptionsAuthenticationType;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperJmxOptionsAuthentication' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperJmxOptionsAuthentication(obj: KafkaSpecZookeeperJmxOptionsAuthentication | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'type': obj.type,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperResourcesClaims
 */
export interface KafkaSpecZookeeperResourcesClaims {
    /**
     * @schema KafkaSpecZookeeperResourcesClaims#name
     */
    readonly name?: string;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperResourcesClaims' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperResourcesClaims(obj: KafkaSpecZookeeperResourcesClaims | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Metrics type. Only 'jmxPrometheusExporter' supported currently.
 *
 * @schema KafkaSpecZookeeperMetricsConfigType
 */
export enum KafkaSpecZookeeperMetricsConfigType {
    /** jmxPrometheusExporter */
    JMX_PROMETHEUS_EXPORTER = "jmxPrometheusExporter",
}

/**
 * ConfigMap entry where the Prometheus JMX Exporter configuration is stored. For details of the structure of this configuration, see the {JMXExporter}.
 *
 * @schema KafkaSpecZookeeperMetricsConfigValueFrom
 */
export interface KafkaSpecZookeeperMetricsConfigValueFrom {
    /**
     * Reference to the key in the ConfigMap containing the configuration.
     *
     * @schema KafkaSpecZookeeperMetricsConfigValueFrom#configMapKeyRef
     */
    readonly configMapKeyRef?: KafkaSpecZookeeperMetricsConfigValueFromConfigMapKeyRef;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperMetricsConfigValueFrom' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperMetricsConfigValueFrom(obj: KafkaSpecZookeeperMetricsConfigValueFrom | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'configMapKeyRef': toJson_KafkaSpecZookeeperMetricsConfigValueFromConfigMapKeyRef(obj.configMapKeyRef),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Logging type, must be either 'inline' or 'external'.
 *
 * @schema KafkaSpecZookeeperLoggingType
 */
export enum KafkaSpecZookeeperLoggingType {
    /** inline */
    INLINE = "inline",
    /** external */
    EXTERNAL = "external",
}

/**
 * `ConfigMap` entry where the logging configuration is stored.
 *
 * @schema KafkaSpecZookeeperLoggingValueFrom
 */
export interface KafkaSpecZookeeperLoggingValueFrom {
    /**
     * Reference to the key in the ConfigMap containing the configuration.
     *
     * @schema KafkaSpecZookeeperLoggingValueFrom#configMapKeyRef
     */
    readonly configMapKeyRef?: KafkaSpecZookeeperLoggingValueFromConfigMapKeyRef;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperLoggingValueFrom' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperLoggingValueFrom(obj: KafkaSpecZookeeperLoggingValueFrom | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'configMapKeyRef': toJson_KafkaSpecZookeeperLoggingValueFromConfigMapKeyRef(obj.configMapKeyRef),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for ZooKeeper `StatefulSet`.
 *
 * @schema KafkaSpecZookeeperTemplateStatefulset
 */
export interface KafkaSpecZookeeperTemplateStatefulset {
    /**
     * Metadata applied to the resource.
     *
     * @schema KafkaSpecZookeeperTemplateStatefulset#metadata
     */
    readonly metadata?: KafkaSpecZookeeperTemplateStatefulsetMetadata;

    /**
     * PodManagementPolicy which will be used for this StatefulSet. Valid values are `Parallel` and `OrderedReady`. Defaults to `Parallel`.
     *
     * @default Parallel`.
     * @schema KafkaSpecZookeeperTemplateStatefulset#podManagementPolicy
     */
    readonly podManagementPolicy?: KafkaSpecZookeeperTemplateStatefulsetPodManagementPolicy;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplateStatefulset' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplateStatefulset(obj: KafkaSpecZookeeperTemplateStatefulset | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_KafkaSpecZookeeperTemplateStatefulsetMetadata(obj.metadata),
        'podManagementPolicy': obj.podManagementPolicy,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for ZooKeeper `Pods`.
 *
 * @schema KafkaSpecZookeeperTemplatePod
 */
export interface KafkaSpecZookeeperTemplatePod {
    /**
     * Metadata applied to the resource.
     *
     * @schema KafkaSpecZookeeperTemplatePod#metadata
     */
    readonly metadata?: KafkaSpecZookeeperTemplatePodMetadata;

    /**
     * List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
     *
     * @schema KafkaSpecZookeeperTemplatePod#imagePullSecrets
     */
    readonly imagePullSecrets?: KafkaSpecZookeeperTemplatePodImagePullSecrets[];

    /**
     * Configures pod-level security attributes and common container settings.
     *
     * @schema KafkaSpecZookeeperTemplatePod#securityContext
     */
    readonly securityContext?: KafkaSpecZookeeperTemplatePodSecurityContext;

    /**
     * The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
     *
     * @default 30 seconds.
     * @schema KafkaSpecZookeeperTemplatePod#terminationGracePeriodSeconds
     */
    readonly terminationGracePeriodSeconds?: number;

    /**
     * The pod's affinity rules.
     *
     * @schema KafkaSpecZookeeperTemplatePod#affinity
     */
    readonly affinity?: KafkaSpecZookeeperTemplatePodAffinity;

    /**
     * The pod's tolerations.
     *
     * @schema KafkaSpecZookeeperTemplatePod#tolerations
     */
    readonly tolerations?: KafkaSpecZookeeperTemplatePodTolerations[];

    /**
     * The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
     *
     * @schema KafkaSpecZookeeperTemplatePod#priorityClassName
     */
    readonly priorityClassName?: string;

    /**
     * The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
     *
     * @schema KafkaSpecZookeeperTemplatePod#schedulerName
     */
    readonly schedulerName?: string;

    /**
     * The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the Pod's hosts file if specified.
     *
     * @schema KafkaSpecZookeeperTemplatePod#hostAliases
     */
    readonly hostAliases?: KafkaSpecZookeeperTemplatePodHostAliases[];

    /**
     * Defines the total amount (for example `1Gi`) of local storage required for temporary EmptyDir volume (`/tmp`). Default value is `5Mi`.
     *
     * @schema KafkaSpecZookeeperTemplatePod#tmpDirSizeLimit
     */
    readonly tmpDirSizeLimit?: string;

    /**
     * Indicates whether information about services should be injected into Pod's environment variables.
     *
     * @schema KafkaSpecZookeeperTemplatePod#enableServiceLinks
     */
    readonly enableServiceLinks?: boolean;

    /**
     * The pod's topology spread constraints.
     *
     * @schema KafkaSpecZookeeperTemplatePod#topologySpreadConstraints
     */
    readonly topologySpreadConstraints?: KafkaSpecZookeeperTemplatePodTopologySpreadConstraints[];

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePod' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePod(obj: KafkaSpecZookeeperTemplatePod | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_KafkaSpecZookeeperTemplatePodMetadata(obj.metadata),
        'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_KafkaSpecZookeeperTemplatePodImagePullSecrets(y)),
        'securityContext': toJson_KafkaSpecZookeeperTemplatePodSecurityContext(obj.securityContext),
        'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
        'affinity': toJson_KafkaSpecZookeeperTemplatePodAffinity(obj.affinity),
        'tolerations': obj.tolerations?.map(y => toJson_KafkaSpecZookeeperTemplatePodTolerations(y)),
        'priorityClassName': obj.priorityClassName,
        'schedulerName': obj.schedulerName,
        'hostAliases': obj.hostAliases?.map(y => toJson_KafkaSpecZookeeperTemplatePodHostAliases(y)),
        'tmpDirSizeLimit': obj.tmpDirSizeLimit,
        'enableServiceLinks': obj.enableServiceLinks,
        'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => toJson_KafkaSpecZookeeperTemplatePodTopologySpreadConstraints(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for ZooKeeper client `Service`.
 *
 * @schema KafkaSpecZookeeperTemplateClientService
 */
export interface KafkaSpecZookeeperTemplateClientService {
    /**
     * Metadata applied to the resource.
     *
     * @schema KafkaSpecZookeeperTemplateClientService#metadata
     */
    readonly metadata?: KafkaSpecZookeeperTemplateClientServiceMetadata;

    /**
     * Specifies the IP Family Policy used by the service. Available options are `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a single IP family. `PreferDualStack` is for two IP families on dual-stack configured clusters or a single IP family on single-stack clusters. `RequireDualStack` fails unless there are two IP families on dual-stack configured clusters. If unspecified, Kubernetes will choose the default value based on the service type. Available on Kubernetes 1.20 and newer.
     *
     * @schema KafkaSpecZookeeperTemplateClientService#ipFamilyPolicy
     */
    readonly ipFamilyPolicy?: KafkaSpecZookeeperTemplateClientServiceIpFamilyPolicy;

    /**
     * Specifies the IP Families used by the service. Available options are `IPv4` and `IPv6. If unspecified, Kubernetes will choose the default value based on the `ipFamilyPolicy` setting. Available on Kubernetes 1.20 and newer.
     *
     * @schema KafkaSpecZookeeperTemplateClientService#ipFamilies
     */
    readonly ipFamilies?: KafkaSpecZookeeperTemplateClientServiceIpFamilies[];

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplateClientService' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplateClientService(obj: KafkaSpecZookeeperTemplateClientService | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_KafkaSpecZookeeperTemplateClientServiceMetadata(obj.metadata),
        'ipFamilyPolicy': obj.ipFamilyPolicy,
        'ipFamilies': obj.ipFamilies?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for ZooKeeper nodes `Service`.
 *
 * @schema KafkaSpecZookeeperTemplateNodesService
 */
export interface KafkaSpecZookeeperTemplateNodesService {
    /**
     * Metadata applied to the resource.
     *
     * @schema KafkaSpecZookeeperTemplateNodesService#metadata
     */
    readonly metadata?: KafkaSpecZookeeperTemplateNodesServiceMetadata;

    /**
     * Specifies the IP Family Policy used by the service. Available options are `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a single IP family. `PreferDualStack` is for two IP families on dual-stack configured clusters or a single IP family on single-stack clusters. `RequireDualStack` fails unless there are two IP families on dual-stack configured clusters. If unspecified, Kubernetes will choose the default value based on the service type. Available on Kubernetes 1.20 and newer.
     *
     * @schema KafkaSpecZookeeperTemplateNodesService#ipFamilyPolicy
     */
    readonly ipFamilyPolicy?: KafkaSpecZookeeperTemplateNodesServiceIpFamilyPolicy;

    /**
     * Specifies the IP Families used by the service. Available options are `IPv4` and `IPv6. If unspecified, Kubernetes will choose the default value based on the `ipFamilyPolicy` setting. Available on Kubernetes 1.20 and newer.
     *
     * @schema KafkaSpecZookeeperTemplateNodesService#ipFamilies
     */
    readonly ipFamilies?: KafkaSpecZookeeperTemplateNodesServiceIpFamilies[];

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplateNodesService' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplateNodesService(obj: KafkaSpecZookeeperTemplateNodesService | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_KafkaSpecZookeeperTemplateNodesServiceMetadata(obj.metadata),
        'ipFamilyPolicy': obj.ipFamilyPolicy,
        'ipFamilies': obj.ipFamilies?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for all ZooKeeper `PersistentVolumeClaims`.
 *
 * @schema KafkaSpecZookeeperTemplatePersistentVolumeClaim
 */
export interface KafkaSpecZookeeperTemplatePersistentVolumeClaim {
    /**
     * Metadata applied to the resource.
     *
     * @schema KafkaSpecZookeeperTemplatePersistentVolumeClaim#metadata
     */
    readonly metadata?: KafkaSpecZookeeperTemplatePersistentVolumeClaimMetadata;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePersistentVolumeClaim' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePersistentVolumeClaim(obj: KafkaSpecZookeeperTemplatePersistentVolumeClaim | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_KafkaSpecZookeeperTemplatePersistentVolumeClaimMetadata(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for ZooKeeper `PodDisruptionBudget`.
 *
 * @schema KafkaSpecZookeeperTemplatePodDisruptionBudget
 */
export interface KafkaSpecZookeeperTemplatePodDisruptionBudget {
    /**
     * Metadata to apply to the `PodDisruptionBudgetTemplate` resource.
     *
     * @schema KafkaSpecZookeeperTemplatePodDisruptionBudget#metadata
     */
    readonly metadata?: KafkaSpecZookeeperTemplatePodDisruptionBudgetMetadata;

    /**
     * Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
     *
     * @default 1.
     * @schema KafkaSpecZookeeperTemplatePodDisruptionBudget#maxUnavailable
     */
    readonly maxUnavailable?: number;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodDisruptionBudget' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodDisruptionBudget(obj: KafkaSpecZookeeperTemplatePodDisruptionBudget | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_KafkaSpecZookeeperTemplatePodDisruptionBudgetMetadata(obj.metadata),
        'maxUnavailable': obj.maxUnavailable,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for the ZooKeeper container.
 *
 * @schema KafkaSpecZookeeperTemplateZookeeperContainer
 */
export interface KafkaSpecZookeeperTemplateZookeeperContainer {
    /**
     * Environment variables which should be applied to the container.
     *
     * @schema KafkaSpecZookeeperTemplateZookeeperContainer#env
     */
    readonly env?: KafkaSpecZookeeperTemplateZookeeperContainerEnv[];

    /**
     * Security context for the container.
     *
     * @schema KafkaSpecZookeeperTemplateZookeeperContainer#securityContext
     */
    readonly securityContext?: KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplateZookeeperContainer' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplateZookeeperContainer(obj: KafkaSpecZookeeperTemplateZookeeperContainer | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'env': obj.env?.map(y => toJson_KafkaSpecZookeeperTemplateZookeeperContainerEnv(y)),
        'securityContext': toJson_KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext(obj.securityContext),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for the ZooKeeper service account.
 *
 * @schema KafkaSpecZookeeperTemplateServiceAccount
 */
export interface KafkaSpecZookeeperTemplateServiceAccount {
    /**
     * Metadata applied to the resource.
     *
     * @schema KafkaSpecZookeeperTemplateServiceAccount#metadata
     */
    readonly metadata?: KafkaSpecZookeeperTemplateServiceAccountMetadata;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplateServiceAccount' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplateServiceAccount(obj: KafkaSpecZookeeperTemplateServiceAccount | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_KafkaSpecZookeeperTemplateServiceAccountMetadata(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for Secret of the Zookeeper Cluster JMX authentication.
 *
 * @schema KafkaSpecZookeeperTemplateJmxSecret
 */
export interface KafkaSpecZookeeperTemplateJmxSecret {
    /**
     * Metadata applied to the resource.
     *
     * @schema KafkaSpecZookeeperTemplateJmxSecret#metadata
     */
    readonly metadata?: KafkaSpecZookeeperTemplateJmxSecretMetadata;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplateJmxSecret' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplateJmxSecret(obj: KafkaSpecZookeeperTemplateJmxSecret | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_KafkaSpecZookeeperTemplateJmxSecretMetadata(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for ZooKeeper `StrimziPodSet` resource.
 *
 * @schema KafkaSpecZookeeperTemplatePodSet
 */
export interface KafkaSpecZookeeperTemplatePodSet {
    /**
     * Metadata applied to the resource.
     *
     * @schema KafkaSpecZookeeperTemplatePodSet#metadata
     */
    readonly metadata?: KafkaSpecZookeeperTemplatePodSetMetadata;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodSet' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodSet(obj: KafkaSpecZookeeperTemplatePodSet | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_KafkaSpecZookeeperTemplatePodSetMetadata(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Pod startup checking.
 *
 * @schema KafkaSpecEntityOperatorTopicOperatorStartupProbe
 */
export interface KafkaSpecEntityOperatorTopicOperatorStartupProbe {
    /**
     * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
     *
     * @default 3. Minimum value is 1.
     * @schema KafkaSpecEntityOperatorTopicOperatorStartupProbe#failureThreshold
     */
    readonly failureThreshold?: number;

    /**
     * The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.
     *
     * @default 15 seconds. Minimum value is 0.
     * @schema KafkaSpecEntityOperatorTopicOperatorStartupProbe#initialDelaySeconds
     */
    readonly initialDelaySeconds?: number;

    /**
     * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
     *
     * @default 10 seconds. Minimum value is 1.
     * @schema KafkaSpecEntityOperatorTopicOperatorStartupProbe#periodSeconds
     */
    readonly periodSeconds?: number;

    /**
     * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
     *
     * @default 1. Must be 1 for liveness. Minimum value is 1.
     * @schema KafkaSpecEntityOperatorTopicOperatorStartupProbe#successThreshold
     */
    readonly successThreshold?: number;

    /**
     * The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.
     *
     * @default 5 seconds. Minimum value is 1.
     * @schema KafkaSpecEntityOperatorTopicOperatorStartupProbe#timeoutSeconds
     */
    readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTopicOperatorStartupProbe' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTopicOperatorStartupProbe(obj: KafkaSpecEntityOperatorTopicOperatorStartupProbe | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'failureThreshold': obj.failureThreshold,
        'initialDelaySeconds': obj.initialDelaySeconds,
        'periodSeconds': obj.periodSeconds,
        'successThreshold': obj.successThreshold,
        'timeoutSeconds': obj.timeoutSeconds,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Pod liveness checking.
 *
 * @schema KafkaSpecEntityOperatorTopicOperatorLivenessProbe
 */
export interface KafkaSpecEntityOperatorTopicOperatorLivenessProbe {
    /**
     * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
     *
     * @default 3. Minimum value is 1.
     * @schema KafkaSpecEntityOperatorTopicOperatorLivenessProbe#failureThreshold
     */
    readonly failureThreshold?: number;

    /**
     * The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.
     *
     * @default 15 seconds. Minimum value is 0.
     * @schema KafkaSpecEntityOperatorTopicOperatorLivenessProbe#initialDelaySeconds
     */
    readonly initialDelaySeconds?: number;

    /**
     * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
     *
     * @default 10 seconds. Minimum value is 1.
     * @schema KafkaSpecEntityOperatorTopicOperatorLivenessProbe#periodSeconds
     */
    readonly periodSeconds?: number;

    /**
     * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
     *
     * @default 1. Must be 1 for liveness. Minimum value is 1.
     * @schema KafkaSpecEntityOperatorTopicOperatorLivenessProbe#successThreshold
     */
    readonly successThreshold?: number;

    /**
     * The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.
     *
     * @default 5 seconds. Minimum value is 1.
     * @schema KafkaSpecEntityOperatorTopicOperatorLivenessProbe#timeoutSeconds
     */
    readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTopicOperatorLivenessProbe' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTopicOperatorLivenessProbe(obj: KafkaSpecEntityOperatorTopicOperatorLivenessProbe | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'failureThreshold': obj.failureThreshold,
        'initialDelaySeconds': obj.initialDelaySeconds,
        'periodSeconds': obj.periodSeconds,
        'successThreshold': obj.successThreshold,
        'timeoutSeconds': obj.timeoutSeconds,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Pod readiness checking.
 *
 * @schema KafkaSpecEntityOperatorTopicOperatorReadinessProbe
 */
export interface KafkaSpecEntityOperatorTopicOperatorReadinessProbe {
    /**
     * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
     *
     * @default 3. Minimum value is 1.
     * @schema KafkaSpecEntityOperatorTopicOperatorReadinessProbe#failureThreshold
     */
    readonly failureThreshold?: number;

    /**
     * The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.
     *
     * @default 15 seconds. Minimum value is 0.
     * @schema KafkaSpecEntityOperatorTopicOperatorReadinessProbe#initialDelaySeconds
     */
    readonly initialDelaySeconds?: number;

    /**
     * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
     *
     * @default 10 seconds. Minimum value is 1.
     * @schema KafkaSpecEntityOperatorTopicOperatorReadinessProbe#periodSeconds
     */
    readonly periodSeconds?: number;

    /**
     * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
     *
     * @default 1. Must be 1 for liveness. Minimum value is 1.
     * @schema KafkaSpecEntityOperatorTopicOperatorReadinessProbe#successThreshold
     */
    readonly successThreshold?: number;

    /**
     * The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.
     *
     * @default 5 seconds. Minimum value is 1.
     * @schema KafkaSpecEntityOperatorTopicOperatorReadinessProbe#timeoutSeconds
     */
    readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTopicOperatorReadinessProbe' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTopicOperatorReadinessProbe(obj: KafkaSpecEntityOperatorTopicOperatorReadinessProbe | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'failureThreshold': obj.failureThreshold,
        'initialDelaySeconds': obj.initialDelaySeconds,
        'periodSeconds': obj.periodSeconds,
        'successThreshold': obj.successThreshold,
        'timeoutSeconds': obj.timeoutSeconds,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * CPU and memory resources to reserve.
 *
 * @schema KafkaSpecEntityOperatorTopicOperatorResources
 */
export interface KafkaSpecEntityOperatorTopicOperatorResources {
    /**
     * @schema KafkaSpecEntityOperatorTopicOperatorResources#claims
     */
    readonly claims?: KafkaSpecEntityOperatorTopicOperatorResourcesClaims[];

    /**
     * @schema KafkaSpecEntityOperatorTopicOperatorResources#limits
     */
    readonly limits?: any;

    /**
     * @schema KafkaSpecEntityOperatorTopicOperatorResources#requests
     */
    readonly requests?: any;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTopicOperatorResources' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTopicOperatorResources(obj: KafkaSpecEntityOperatorTopicOperatorResources | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'claims': obj.claims?.map(y => toJson_KafkaSpecEntityOperatorTopicOperatorResourcesClaims(y)),
        'limits': obj.limits,
        'requests': obj.requests,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Logging configuration.
 *
 * @schema KafkaSpecEntityOperatorTopicOperatorLogging
 */
export interface KafkaSpecEntityOperatorTopicOperatorLogging {
    /**
     * A Map from logger name to logger level.
     *
     * @schema KafkaSpecEntityOperatorTopicOperatorLogging#loggers
     */
    readonly loggers?: any;

    /**
     * Logging type, must be either 'inline' or 'external'.
     *
     * @schema KafkaSpecEntityOperatorTopicOperatorLogging#type
     */
    readonly type: KafkaSpecEntityOperatorTopicOperatorLoggingType;

    /**
     * `ConfigMap` entry where the logging configuration is stored.
     *
     * @schema KafkaSpecEntityOperatorTopicOperatorLogging#valueFrom
     */
    readonly valueFrom?: KafkaSpecEntityOperatorTopicOperatorLoggingValueFrom;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTopicOperatorLogging' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTopicOperatorLogging(obj: KafkaSpecEntityOperatorTopicOperatorLogging | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'loggers': obj.loggers,
        'type': obj.type,
        'valueFrom': toJson_KafkaSpecEntityOperatorTopicOperatorLoggingValueFrom(obj.valueFrom),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * JVM Options for pods.
 *
 * @schema KafkaSpecEntityOperatorTopicOperatorJvmOptions
 */
export interface KafkaSpecEntityOperatorTopicOperatorJvmOptions {
    /**
     * A map of -XX options to the JVM.
     *
     * @schema KafkaSpecEntityOperatorTopicOperatorJvmOptions#-XX
     */
    readonly xx?: any;

    /**
     * -Xms option to to the JVM.
     *
     * @schema KafkaSpecEntityOperatorTopicOperatorJvmOptions#-Xms
     */
    readonly xms?: string;

    /**
     * -Xmx option to to the JVM.
     *
     * @schema KafkaSpecEntityOperatorTopicOperatorJvmOptions#-Xmx
     */
    readonly xmx?: string;

    /**
     * Specifies whether the Garbage Collection logging is enabled. The default is false.
     *
     * @schema KafkaSpecEntityOperatorTopicOperatorJvmOptions#gcLoggingEnabled
     */
    readonly gcLoggingEnabled?: boolean;

    /**
     * A map of additional system properties which will be passed using the `-D` option to the JVM.
     *
     * @schema KafkaSpecEntityOperatorTopicOperatorJvmOptions#javaSystemProperties
     */
    readonly javaSystemProperties?: KafkaSpecEntityOperatorTopicOperatorJvmOptionsJavaSystemProperties[];

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTopicOperatorJvmOptions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTopicOperatorJvmOptions(obj: KafkaSpecEntityOperatorTopicOperatorJvmOptions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        '-XX': obj.xx,
        '-Xms': obj.xms,
        '-Xmx': obj.xmx,
        'gcLoggingEnabled': obj.gcLoggingEnabled,
        'javaSystemProperties': obj.javaSystemProperties?.map(y => toJson_KafkaSpecEntityOperatorTopicOperatorJvmOptionsJavaSystemProperties(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Pod liveness checking.
 *
 * @schema KafkaSpecEntityOperatorUserOperatorLivenessProbe
 */
export interface KafkaSpecEntityOperatorUserOperatorLivenessProbe {
    /**
     * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
     *
     * @default 3. Minimum value is 1.
     * @schema KafkaSpecEntityOperatorUserOperatorLivenessProbe#failureThreshold
     */
    readonly failureThreshold?: number;

    /**
     * The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.
     *
     * @default 15 seconds. Minimum value is 0.
     * @schema KafkaSpecEntityOperatorUserOperatorLivenessProbe#initialDelaySeconds
     */
    readonly initialDelaySeconds?: number;

    /**
     * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
     *
     * @default 10 seconds. Minimum value is 1.
     * @schema KafkaSpecEntityOperatorUserOperatorLivenessProbe#periodSeconds
     */
    readonly periodSeconds?: number;

    /**
     * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
     *
     * @default 1. Must be 1 for liveness. Minimum value is 1.
     * @schema KafkaSpecEntityOperatorUserOperatorLivenessProbe#successThreshold
     */
    readonly successThreshold?: number;

    /**
     * The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.
     *
     * @default 5 seconds. Minimum value is 1.
     * @schema KafkaSpecEntityOperatorUserOperatorLivenessProbe#timeoutSeconds
     */
    readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorUserOperatorLivenessProbe' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorUserOperatorLivenessProbe(obj: KafkaSpecEntityOperatorUserOperatorLivenessProbe | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'failureThreshold': obj.failureThreshold,
        'initialDelaySeconds': obj.initialDelaySeconds,
        'periodSeconds': obj.periodSeconds,
        'successThreshold': obj.successThreshold,
        'timeoutSeconds': obj.timeoutSeconds,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Pod readiness checking.
 *
 * @schema KafkaSpecEntityOperatorUserOperatorReadinessProbe
 */
export interface KafkaSpecEntityOperatorUserOperatorReadinessProbe {
    /**
     * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
     *
     * @default 3. Minimum value is 1.
     * @schema KafkaSpecEntityOperatorUserOperatorReadinessProbe#failureThreshold
     */
    readonly failureThreshold?: number;

    /**
     * The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.
     *
     * @default 15 seconds. Minimum value is 0.
     * @schema KafkaSpecEntityOperatorUserOperatorReadinessProbe#initialDelaySeconds
     */
    readonly initialDelaySeconds?: number;

    /**
     * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
     *
     * @default 10 seconds. Minimum value is 1.
     * @schema KafkaSpecEntityOperatorUserOperatorReadinessProbe#periodSeconds
     */
    readonly periodSeconds?: number;

    /**
     * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
     *
     * @default 1. Must be 1 for liveness. Minimum value is 1.
     * @schema KafkaSpecEntityOperatorUserOperatorReadinessProbe#successThreshold
     */
    readonly successThreshold?: number;

    /**
     * The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.
     *
     * @default 5 seconds. Minimum value is 1.
     * @schema KafkaSpecEntityOperatorUserOperatorReadinessProbe#timeoutSeconds
     */
    readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorUserOperatorReadinessProbe' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorUserOperatorReadinessProbe(obj: KafkaSpecEntityOperatorUserOperatorReadinessProbe | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'failureThreshold': obj.failureThreshold,
        'initialDelaySeconds': obj.initialDelaySeconds,
        'periodSeconds': obj.periodSeconds,
        'successThreshold': obj.successThreshold,
        'timeoutSeconds': obj.timeoutSeconds,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * CPU and memory resources to reserve.
 *
 * @schema KafkaSpecEntityOperatorUserOperatorResources
 */
export interface KafkaSpecEntityOperatorUserOperatorResources {
    /**
     * @schema KafkaSpecEntityOperatorUserOperatorResources#claims
     */
    readonly claims?: KafkaSpecEntityOperatorUserOperatorResourcesClaims[];

    /**
     * @schema KafkaSpecEntityOperatorUserOperatorResources#limits
     */
    readonly limits?: any;

    /**
     * @schema KafkaSpecEntityOperatorUserOperatorResources#requests
     */
    readonly requests?: any;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorUserOperatorResources' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorUserOperatorResources(obj: KafkaSpecEntityOperatorUserOperatorResources | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'claims': obj.claims?.map(y => toJson_KafkaSpecEntityOperatorUserOperatorResourcesClaims(y)),
        'limits': obj.limits,
        'requests': obj.requests,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Logging configuration.
 *
 * @schema KafkaSpecEntityOperatorUserOperatorLogging
 */
export interface KafkaSpecEntityOperatorUserOperatorLogging {
    /**
     * A Map from logger name to logger level.
     *
     * @schema KafkaSpecEntityOperatorUserOperatorLogging#loggers
     */
    readonly loggers?: any;

    /**
     * Logging type, must be either 'inline' or 'external'.
     *
     * @schema KafkaSpecEntityOperatorUserOperatorLogging#type
     */
    readonly type: KafkaSpecEntityOperatorUserOperatorLoggingType;

    /**
     * `ConfigMap` entry where the logging configuration is stored.
     *
     * @schema KafkaSpecEntityOperatorUserOperatorLogging#valueFrom
     */
    readonly valueFrom?: KafkaSpecEntityOperatorUserOperatorLoggingValueFrom;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorUserOperatorLogging' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorUserOperatorLogging(obj: KafkaSpecEntityOperatorUserOperatorLogging | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'loggers': obj.loggers,
        'type': obj.type,
        'valueFrom': toJson_KafkaSpecEntityOperatorUserOperatorLoggingValueFrom(obj.valueFrom),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * JVM Options for pods.
 *
 * @schema KafkaSpecEntityOperatorUserOperatorJvmOptions
 */
export interface KafkaSpecEntityOperatorUserOperatorJvmOptions {
    /**
     * A map of -XX options to the JVM.
     *
     * @schema KafkaSpecEntityOperatorUserOperatorJvmOptions#-XX
     */
    readonly xx?: any;

    /**
     * -Xms option to to the JVM.
     *
     * @schema KafkaSpecEntityOperatorUserOperatorJvmOptions#-Xms
     */
    readonly xms?: string;

    /**
     * -Xmx option to to the JVM.
     *
     * @schema KafkaSpecEntityOperatorUserOperatorJvmOptions#-Xmx
     */
    readonly xmx?: string;

    /**
     * Specifies whether the Garbage Collection logging is enabled. The default is false.
     *
     * @schema KafkaSpecEntityOperatorUserOperatorJvmOptions#gcLoggingEnabled
     */
    readonly gcLoggingEnabled?: boolean;

    /**
     * A map of additional system properties which will be passed using the `-D` option to the JVM.
     *
     * @schema KafkaSpecEntityOperatorUserOperatorJvmOptions#javaSystemProperties
     */
    readonly javaSystemProperties?: KafkaSpecEntityOperatorUserOperatorJvmOptionsJavaSystemProperties[];

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorUserOperatorJvmOptions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorUserOperatorJvmOptions(obj: KafkaSpecEntityOperatorUserOperatorJvmOptions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        '-XX': obj.xx,
        '-Xms': obj.xms,
        '-Xmx': obj.xmx,
        'gcLoggingEnabled': obj.gcLoggingEnabled,
        'javaSystemProperties': obj.javaSystemProperties?.map(y => toJson_KafkaSpecEntityOperatorUserOperatorJvmOptionsJavaSystemProperties(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Pod liveness checking.
 *
 * @schema KafkaSpecEntityOperatorTlsSidecarLivenessProbe
 */
export interface KafkaSpecEntityOperatorTlsSidecarLivenessProbe {
    /**
     * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
     *
     * @default 3. Minimum value is 1.
     * @schema KafkaSpecEntityOperatorTlsSidecarLivenessProbe#failureThreshold
     */
    readonly failureThreshold?: number;

    /**
     * The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.
     *
     * @default 15 seconds. Minimum value is 0.
     * @schema KafkaSpecEntityOperatorTlsSidecarLivenessProbe#initialDelaySeconds
     */
    readonly initialDelaySeconds?: number;

    /**
     * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
     *
     * @default 10 seconds. Minimum value is 1.
     * @schema KafkaSpecEntityOperatorTlsSidecarLivenessProbe#periodSeconds
     */
    readonly periodSeconds?: number;

    /**
     * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
     *
     * @default 1. Must be 1 for liveness. Minimum value is 1.
     * @schema KafkaSpecEntityOperatorTlsSidecarLivenessProbe#successThreshold
     */
    readonly successThreshold?: number;

    /**
     * The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.
     *
     * @default 5 seconds. Minimum value is 1.
     * @schema KafkaSpecEntityOperatorTlsSidecarLivenessProbe#timeoutSeconds
     */
    readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTlsSidecarLivenessProbe' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTlsSidecarLivenessProbe(obj: KafkaSpecEntityOperatorTlsSidecarLivenessProbe | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'failureThreshold': obj.failureThreshold,
        'initialDelaySeconds': obj.initialDelaySeconds,
        'periodSeconds': obj.periodSeconds,
        'successThreshold': obj.successThreshold,
        'timeoutSeconds': obj.timeoutSeconds,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * The log level for the TLS sidecar. Default value is `notice`.
 *
 * @schema KafkaSpecEntityOperatorTlsSidecarLogLevel
 */
export enum KafkaSpecEntityOperatorTlsSidecarLogLevel {
    /** emerg */
    EMERG = "emerg",
    /** alert */
    ALERT = "alert",
    /** crit */
    CRIT = "crit",
    /** err */
    ERR = "err",
    /** warning */
    WARNING = "warning",
    /** notice */
    NOTICE = "notice",
    /** info */
    INFO = "info",
    /** debug */
    DEBUG = "debug",
}

/**
 * Pod readiness checking.
 *
 * @schema KafkaSpecEntityOperatorTlsSidecarReadinessProbe
 */
export interface KafkaSpecEntityOperatorTlsSidecarReadinessProbe {
    /**
     * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
     *
     * @default 3. Minimum value is 1.
     * @schema KafkaSpecEntityOperatorTlsSidecarReadinessProbe#failureThreshold
     */
    readonly failureThreshold?: number;

    /**
     * The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.
     *
     * @default 15 seconds. Minimum value is 0.
     * @schema KafkaSpecEntityOperatorTlsSidecarReadinessProbe#initialDelaySeconds
     */
    readonly initialDelaySeconds?: number;

    /**
     * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
     *
     * @default 10 seconds. Minimum value is 1.
     * @schema KafkaSpecEntityOperatorTlsSidecarReadinessProbe#periodSeconds
     */
    readonly periodSeconds?: number;

    /**
     * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
     *
     * @default 1. Must be 1 for liveness. Minimum value is 1.
     * @schema KafkaSpecEntityOperatorTlsSidecarReadinessProbe#successThreshold
     */
    readonly successThreshold?: number;

    /**
     * The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.
     *
     * @default 5 seconds. Minimum value is 1.
     * @schema KafkaSpecEntityOperatorTlsSidecarReadinessProbe#timeoutSeconds
     */
    readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTlsSidecarReadinessProbe' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTlsSidecarReadinessProbe(obj: KafkaSpecEntityOperatorTlsSidecarReadinessProbe | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'failureThreshold': obj.failureThreshold,
        'initialDelaySeconds': obj.initialDelaySeconds,
        'periodSeconds': obj.periodSeconds,
        'successThreshold': obj.successThreshold,
        'timeoutSeconds': obj.timeoutSeconds,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * CPU and memory resources to reserve.
 *
 * @schema KafkaSpecEntityOperatorTlsSidecarResources
 */
export interface KafkaSpecEntityOperatorTlsSidecarResources {
    /**
     * @schema KafkaSpecEntityOperatorTlsSidecarResources#claims
     */
    readonly claims?: KafkaSpecEntityOperatorTlsSidecarResourcesClaims[];

    /**
     * @schema KafkaSpecEntityOperatorTlsSidecarResources#limits
     */
    readonly limits?: any;

    /**
     * @schema KafkaSpecEntityOperatorTlsSidecarResources#requests
     */
    readonly requests?: any;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTlsSidecarResources' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTlsSidecarResources(obj: KafkaSpecEntityOperatorTlsSidecarResources | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'claims': obj.claims?.map(y => toJson_KafkaSpecEntityOperatorTlsSidecarResourcesClaims(y)),
        'limits': obj.limits,
        'requests': obj.requests,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for Entity Operator `Deployment`.
 *
 * @schema KafkaSpecEntityOperatorTemplateDeployment
 */
export interface KafkaSpecEntityOperatorTemplateDeployment {
    /**
     * Metadata applied to the resource.
     *
     * @schema KafkaSpecEntityOperatorTemplateDeployment#metadata
     */
    readonly metadata?: KafkaSpecEntityOperatorTemplateDeploymentMetadata;

    /**
     * Pod replacement strategy for deployment configuration changes. Valid values are `RollingUpdate` and `Recreate`. Defaults to `RollingUpdate`.
     *
     * @default RollingUpdate`.
     * @schema KafkaSpecEntityOperatorTemplateDeployment#deploymentStrategy
     */
    readonly deploymentStrategy?: KafkaSpecEntityOperatorTemplateDeploymentDeploymentStrategy;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplateDeployment' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplateDeployment(obj: KafkaSpecEntityOperatorTemplateDeployment | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_KafkaSpecEntityOperatorTemplateDeploymentMetadata(obj.metadata),
        'deploymentStrategy': obj.deploymentStrategy,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for Entity Operator `Pods`.
 *
 * @schema KafkaSpecEntityOperatorTemplatePod
 */
export interface KafkaSpecEntityOperatorTemplatePod {
    /**
     * Metadata applied to the resource.
     *
     * @schema KafkaSpecEntityOperatorTemplatePod#metadata
     */
    readonly metadata?: KafkaSpecEntityOperatorTemplatePodMetadata;

    /**
     * List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
     *
     * @schema KafkaSpecEntityOperatorTemplatePod#imagePullSecrets
     */
    readonly imagePullSecrets?: KafkaSpecEntityOperatorTemplatePodImagePullSecrets[];

    /**
     * Configures pod-level security attributes and common container settings.
     *
     * @schema KafkaSpecEntityOperatorTemplatePod#securityContext
     */
    readonly securityContext?: KafkaSpecEntityOperatorTemplatePodSecurityContext;

    /**
     * The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
     *
     * @default 30 seconds.
     * @schema KafkaSpecEntityOperatorTemplatePod#terminationGracePeriodSeconds
     */
    readonly terminationGracePeriodSeconds?: number;

    /**
     * The pod's affinity rules.
     *
     * @schema KafkaSpecEntityOperatorTemplatePod#affinity
     */
    readonly affinity?: KafkaSpecEntityOperatorTemplatePodAffinity;

    /**
     * The pod's tolerations.
     *
     * @schema KafkaSpecEntityOperatorTemplatePod#tolerations
     */
    readonly tolerations?: KafkaSpecEntityOperatorTemplatePodTolerations[];

    /**
     * The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
     *
     * @schema KafkaSpecEntityOperatorTemplatePod#priorityClassName
     */
    readonly priorityClassName?: string;

    /**
     * The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
     *
     * @schema KafkaSpecEntityOperatorTemplatePod#schedulerName
     */
    readonly schedulerName?: string;

    /**
     * The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the Pod's hosts file if specified.
     *
     * @schema KafkaSpecEntityOperatorTemplatePod#hostAliases
     */
    readonly hostAliases?: KafkaSpecEntityOperatorTemplatePodHostAliases[];

    /**
     * Defines the total amount (for example `1Gi`) of local storage required for temporary EmptyDir volume (`/tmp`). Default value is `5Mi`.
     *
     * @schema KafkaSpecEntityOperatorTemplatePod#tmpDirSizeLimit
     */
    readonly tmpDirSizeLimit?: string;

    /**
     * Indicates whether information about services should be injected into Pod's environment variables.
     *
     * @schema KafkaSpecEntityOperatorTemplatePod#enableServiceLinks
     */
    readonly enableServiceLinks?: boolean;

    /**
     * The pod's topology spread constraints.
     *
     * @schema KafkaSpecEntityOperatorTemplatePod#topologySpreadConstraints
     */
    readonly topologySpreadConstraints?: KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraints[];

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePod' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePod(obj: KafkaSpecEntityOperatorTemplatePod | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_KafkaSpecEntityOperatorTemplatePodMetadata(obj.metadata),
        'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_KafkaSpecEntityOperatorTemplatePodImagePullSecrets(y)),
        'securityContext': toJson_KafkaSpecEntityOperatorTemplatePodSecurityContext(obj.securityContext),
        'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
        'affinity': toJson_KafkaSpecEntityOperatorTemplatePodAffinity(obj.affinity),
        'tolerations': obj.tolerations?.map(y => toJson_KafkaSpecEntityOperatorTemplatePodTolerations(y)),
        'priorityClassName': obj.priorityClassName,
        'schedulerName': obj.schedulerName,
        'hostAliases': obj.hostAliases?.map(y => toJson_KafkaSpecEntityOperatorTemplatePodHostAliases(y)),
        'tmpDirSizeLimit': obj.tmpDirSizeLimit,
        'enableServiceLinks': obj.enableServiceLinks,
        'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => toJson_KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraints(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for the Entity Topic Operator container.
 *
 * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainer
 */
export interface KafkaSpecEntityOperatorTemplateTopicOperatorContainer {
    /**
     * Environment variables which should be applied to the container.
     *
     * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainer#env
     */
    readonly env?: KafkaSpecEntityOperatorTemplateTopicOperatorContainerEnv[];

    /**
     * Security context for the container.
     *
     * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainer#securityContext
     */
    readonly securityContext?: KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplateTopicOperatorContainer' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplateTopicOperatorContainer(obj: KafkaSpecEntityOperatorTemplateTopicOperatorContainer | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'env': obj.env?.map(y => toJson_KafkaSpecEntityOperatorTemplateTopicOperatorContainerEnv(y)),
        'securityContext': toJson_KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext(obj.securityContext),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for the Entity User Operator container.
 *
 * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainer
 */
export interface KafkaSpecEntityOperatorTemplateUserOperatorContainer {
    /**
     * Environment variables which should be applied to the container.
     *
     * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainer#env
     */
    readonly env?: KafkaSpecEntityOperatorTemplateUserOperatorContainerEnv[];

    /**
     * Security context for the container.
     *
     * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainer#securityContext
     */
    readonly securityContext?: KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplateUserOperatorContainer' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplateUserOperatorContainer(obj: KafkaSpecEntityOperatorTemplateUserOperatorContainer | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'env': obj.env?.map(y => toJson_KafkaSpecEntityOperatorTemplateUserOperatorContainerEnv(y)),
        'securityContext': toJson_KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext(obj.securityContext),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for the Entity Operator TLS sidecar container.
 *
 * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainer
 */
export interface KafkaSpecEntityOperatorTemplateTlsSidecarContainer {
    /**
     * Environment variables which should be applied to the container.
     *
     * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainer#env
     */
    readonly env?: KafkaSpecEntityOperatorTemplateTlsSidecarContainerEnv[];

    /**
     * Security context for the container.
     *
     * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainer#securityContext
     */
    readonly securityContext?: KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplateTlsSidecarContainer' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplateTlsSidecarContainer(obj: KafkaSpecEntityOperatorTemplateTlsSidecarContainer | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'env': obj.env?.map(y => toJson_KafkaSpecEntityOperatorTemplateTlsSidecarContainerEnv(y)),
        'securityContext': toJson_KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext(obj.securityContext),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for the Entity Operator service account.
 *
 * @schema KafkaSpecEntityOperatorTemplateServiceAccount
 */
export interface KafkaSpecEntityOperatorTemplateServiceAccount {
    /**
     * Metadata applied to the resource.
     *
     * @schema KafkaSpecEntityOperatorTemplateServiceAccount#metadata
     */
    readonly metadata?: KafkaSpecEntityOperatorTemplateServiceAccountMetadata;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplateServiceAccount' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplateServiceAccount(obj: KafkaSpecEntityOperatorTemplateServiceAccount | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_KafkaSpecEntityOperatorTemplateServiceAccountMetadata(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for the Entity Operator Role.
 *
 * @schema KafkaSpecEntityOperatorTemplateEntityOperatorRole
 */
export interface KafkaSpecEntityOperatorTemplateEntityOperatorRole {
    /**
     * Metadata applied to the resource.
     *
     * @schema KafkaSpecEntityOperatorTemplateEntityOperatorRole#metadata
     */
    readonly metadata?: KafkaSpecEntityOperatorTemplateEntityOperatorRoleMetadata;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplateEntityOperatorRole' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplateEntityOperatorRole(obj: KafkaSpecEntityOperatorTemplateEntityOperatorRole | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_KafkaSpecEntityOperatorTemplateEntityOperatorRoleMetadata(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for the Entity Topic Operator RoleBinding.
 *
 * @schema KafkaSpecEntityOperatorTemplateTopicOperatorRoleBinding
 */
export interface KafkaSpecEntityOperatorTemplateTopicOperatorRoleBinding {
    /**
     * Metadata applied to the resource.
     *
     * @schema KafkaSpecEntityOperatorTemplateTopicOperatorRoleBinding#metadata
     */
    readonly metadata?: KafkaSpecEntityOperatorTemplateTopicOperatorRoleBindingMetadata;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplateTopicOperatorRoleBinding' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplateTopicOperatorRoleBinding(obj: KafkaSpecEntityOperatorTemplateTopicOperatorRoleBinding | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_KafkaSpecEntityOperatorTemplateTopicOperatorRoleBindingMetadata(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for the Entity Topic Operator RoleBinding.
 *
 * @schema KafkaSpecEntityOperatorTemplateUserOperatorRoleBinding
 */
export interface KafkaSpecEntityOperatorTemplateUserOperatorRoleBinding {
    /**
     * Metadata applied to the resource.
     *
     * @schema KafkaSpecEntityOperatorTemplateUserOperatorRoleBinding#metadata
     */
    readonly metadata?: KafkaSpecEntityOperatorTemplateUserOperatorRoleBindingMetadata;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplateUserOperatorRoleBinding' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplateUserOperatorRoleBinding(obj: KafkaSpecEntityOperatorTemplateUserOperatorRoleBinding | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_KafkaSpecEntityOperatorTemplateUserOperatorRoleBindingMetadata(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Pod liveness checking.
 *
 * @schema KafkaSpecCruiseControlTlsSidecarLivenessProbe
 */
export interface KafkaSpecCruiseControlTlsSidecarLivenessProbe {
    /**
     * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
     *
     * @default 3. Minimum value is 1.
     * @schema KafkaSpecCruiseControlTlsSidecarLivenessProbe#failureThreshold
     */
    readonly failureThreshold?: number;

    /**
     * The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.
     *
     * @default 15 seconds. Minimum value is 0.
     * @schema KafkaSpecCruiseControlTlsSidecarLivenessProbe#initialDelaySeconds
     */
    readonly initialDelaySeconds?: number;

    /**
     * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
     *
     * @default 10 seconds. Minimum value is 1.
     * @schema KafkaSpecCruiseControlTlsSidecarLivenessProbe#periodSeconds
     */
    readonly periodSeconds?: number;

    /**
     * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
     *
     * @default 1. Must be 1 for liveness. Minimum value is 1.
     * @schema KafkaSpecCruiseControlTlsSidecarLivenessProbe#successThreshold
     */
    readonly successThreshold?: number;

    /**
     * The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.
     *
     * @default 5 seconds. Minimum value is 1.
     * @schema KafkaSpecCruiseControlTlsSidecarLivenessProbe#timeoutSeconds
     */
    readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTlsSidecarLivenessProbe' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTlsSidecarLivenessProbe(obj: KafkaSpecCruiseControlTlsSidecarLivenessProbe | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'failureThreshold': obj.failureThreshold,
        'initialDelaySeconds': obj.initialDelaySeconds,
        'periodSeconds': obj.periodSeconds,
        'successThreshold': obj.successThreshold,
        'timeoutSeconds': obj.timeoutSeconds,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * The log level for the TLS sidecar. Default value is `notice`.
 *
 * @schema KafkaSpecCruiseControlTlsSidecarLogLevel
 */
export enum KafkaSpecCruiseControlTlsSidecarLogLevel {
    /** emerg */
    EMERG = "emerg",
    /** alert */
    ALERT = "alert",
    /** crit */
    CRIT = "crit",
    /** err */
    ERR = "err",
    /** warning */
    WARNING = "warning",
    /** notice */
    NOTICE = "notice",
    /** info */
    INFO = "info",
    /** debug */
    DEBUG = "debug",
}

/**
 * Pod readiness checking.
 *
 * @schema KafkaSpecCruiseControlTlsSidecarReadinessProbe
 */
export interface KafkaSpecCruiseControlTlsSidecarReadinessProbe {
    /**
     * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
     *
     * @default 3. Minimum value is 1.
     * @schema KafkaSpecCruiseControlTlsSidecarReadinessProbe#failureThreshold
     */
    readonly failureThreshold?: number;

    /**
     * The initial delay before first the health is first checked. Default to 15 seconds. Minimum value is 0.
     *
     * @default 15 seconds. Minimum value is 0.
     * @schema KafkaSpecCruiseControlTlsSidecarReadinessProbe#initialDelaySeconds
     */
    readonly initialDelaySeconds?: number;

    /**
     * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
     *
     * @default 10 seconds. Minimum value is 1.
     * @schema KafkaSpecCruiseControlTlsSidecarReadinessProbe#periodSeconds
     */
    readonly periodSeconds?: number;

    /**
     * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
     *
     * @default 1. Must be 1 for liveness. Minimum value is 1.
     * @schema KafkaSpecCruiseControlTlsSidecarReadinessProbe#successThreshold
     */
    readonly successThreshold?: number;

    /**
     * The timeout for each attempted health check. Default to 5 seconds. Minimum value is 1.
     *
     * @default 5 seconds. Minimum value is 1.
     * @schema KafkaSpecCruiseControlTlsSidecarReadinessProbe#timeoutSeconds
     */
    readonly timeoutSeconds?: number;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTlsSidecarReadinessProbe' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTlsSidecarReadinessProbe(obj: KafkaSpecCruiseControlTlsSidecarReadinessProbe | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'failureThreshold': obj.failureThreshold,
        'initialDelaySeconds': obj.initialDelaySeconds,
        'periodSeconds': obj.periodSeconds,
        'successThreshold': obj.successThreshold,
        'timeoutSeconds': obj.timeoutSeconds,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * CPU and memory resources to reserve.
 *
 * @schema KafkaSpecCruiseControlTlsSidecarResources
 */
export interface KafkaSpecCruiseControlTlsSidecarResources {
    /**
     * @schema KafkaSpecCruiseControlTlsSidecarResources#claims
     */
    readonly claims?: KafkaSpecCruiseControlTlsSidecarResourcesClaims[];

    /**
     * @schema KafkaSpecCruiseControlTlsSidecarResources#limits
     */
    readonly limits?: any;

    /**
     * @schema KafkaSpecCruiseControlTlsSidecarResources#requests
     */
    readonly requests?: any;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTlsSidecarResources' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTlsSidecarResources(obj: KafkaSpecCruiseControlTlsSidecarResources | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'claims': obj.claims?.map(y => toJson_KafkaSpecCruiseControlTlsSidecarResourcesClaims(y)),
        'limits': obj.limits,
        'requests': obj.requests,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlResourcesClaims
 */
export interface KafkaSpecCruiseControlResourcesClaims {
    /**
     * @schema KafkaSpecCruiseControlResourcesClaims#name
     */
    readonly name?: string;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlResourcesClaims' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlResourcesClaims(obj: KafkaSpecCruiseControlResourcesClaims | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlJvmOptionsJavaSystemProperties
 */
export interface KafkaSpecCruiseControlJvmOptionsJavaSystemProperties {
    /**
     * The system property name.
     *
     * @schema KafkaSpecCruiseControlJvmOptionsJavaSystemProperties#name
     */
    readonly name?: string;

    /**
     * The system property value.
     *
     * @schema KafkaSpecCruiseControlJvmOptionsJavaSystemProperties#value
     */
    readonly value?: string;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlJvmOptionsJavaSystemProperties' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlJvmOptionsJavaSystemProperties(obj: KafkaSpecCruiseControlJvmOptionsJavaSystemProperties | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Logging type, must be either 'inline' or 'external'.
 *
 * @schema KafkaSpecCruiseControlLoggingType
 */
export enum KafkaSpecCruiseControlLoggingType {
    /** inline */
    INLINE = "inline",
    /** external */
    EXTERNAL = "external",
}

/**
 * `ConfigMap` entry where the logging configuration is stored.
 *
 * @schema KafkaSpecCruiseControlLoggingValueFrom
 */
export interface KafkaSpecCruiseControlLoggingValueFrom {
    /**
     * Reference to the key in the ConfigMap containing the configuration.
     *
     * @schema KafkaSpecCruiseControlLoggingValueFrom#configMapKeyRef
     */
    readonly configMapKeyRef?: KafkaSpecCruiseControlLoggingValueFromConfigMapKeyRef;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlLoggingValueFrom' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlLoggingValueFrom(obj: KafkaSpecCruiseControlLoggingValueFrom | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'configMapKeyRef': toJson_KafkaSpecCruiseControlLoggingValueFromConfigMapKeyRef(obj.configMapKeyRef),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for Cruise Control `Deployment`.
 *
 * @schema KafkaSpecCruiseControlTemplateDeployment
 */
export interface KafkaSpecCruiseControlTemplateDeployment {
    /**
     * Metadata applied to the resource.
     *
     * @schema KafkaSpecCruiseControlTemplateDeployment#metadata
     */
    readonly metadata?: KafkaSpecCruiseControlTemplateDeploymentMetadata;

    /**
     * Pod replacement strategy for deployment configuration changes. Valid values are `RollingUpdate` and `Recreate`. Defaults to `RollingUpdate`.
     *
     * @default RollingUpdate`.
     * @schema KafkaSpecCruiseControlTemplateDeployment#deploymentStrategy
     */
    readonly deploymentStrategy?: KafkaSpecCruiseControlTemplateDeploymentDeploymentStrategy;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplateDeployment' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplateDeployment(obj: KafkaSpecCruiseControlTemplateDeployment | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_KafkaSpecCruiseControlTemplateDeploymentMetadata(obj.metadata),
        'deploymentStrategy': obj.deploymentStrategy,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for Cruise Control `Pods`.
 *
 * @schema KafkaSpecCruiseControlTemplatePod
 */
export interface KafkaSpecCruiseControlTemplatePod {
    /**
     * Metadata applied to the resource.
     *
     * @schema KafkaSpecCruiseControlTemplatePod#metadata
     */
    readonly metadata?: KafkaSpecCruiseControlTemplatePodMetadata;

    /**
     * List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
     *
     * @schema KafkaSpecCruiseControlTemplatePod#imagePullSecrets
     */
    readonly imagePullSecrets?: KafkaSpecCruiseControlTemplatePodImagePullSecrets[];

    /**
     * Configures pod-level security attributes and common container settings.
     *
     * @schema KafkaSpecCruiseControlTemplatePod#securityContext
     */
    readonly securityContext?: KafkaSpecCruiseControlTemplatePodSecurityContext;

    /**
     * The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
     *
     * @default 30 seconds.
     * @schema KafkaSpecCruiseControlTemplatePod#terminationGracePeriodSeconds
     */
    readonly terminationGracePeriodSeconds?: number;

    /**
     * The pod's affinity rules.
     *
     * @schema KafkaSpecCruiseControlTemplatePod#affinity
     */
    readonly affinity?: KafkaSpecCruiseControlTemplatePodAffinity;

    /**
     * The pod's tolerations.
     *
     * @schema KafkaSpecCruiseControlTemplatePod#tolerations
     */
    readonly tolerations?: KafkaSpecCruiseControlTemplatePodTolerations[];

    /**
     * The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
     *
     * @schema KafkaSpecCruiseControlTemplatePod#priorityClassName
     */
    readonly priorityClassName?: string;

    /**
     * The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
     *
     * @schema KafkaSpecCruiseControlTemplatePod#schedulerName
     */
    readonly schedulerName?: string;

    /**
     * The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the Pod's hosts file if specified.
     *
     * @schema KafkaSpecCruiseControlTemplatePod#hostAliases
     */
    readonly hostAliases?: KafkaSpecCruiseControlTemplatePodHostAliases[];

    /**
     * Defines the total amount (for example `1Gi`) of local storage required for temporary EmptyDir volume (`/tmp`). Default value is `5Mi`.
     *
     * @schema KafkaSpecCruiseControlTemplatePod#tmpDirSizeLimit
     */
    readonly tmpDirSizeLimit?: string;

    /**
     * Indicates whether information about services should be injected into Pod's environment variables.
     *
     * @schema KafkaSpecCruiseControlTemplatePod#enableServiceLinks
     */
    readonly enableServiceLinks?: boolean;

    /**
     * The pod's topology spread constraints.
     *
     * @schema KafkaSpecCruiseControlTemplatePod#topologySpreadConstraints
     */
    readonly topologySpreadConstraints?: KafkaSpecCruiseControlTemplatePodTopologySpreadConstraints[];

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePod' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePod(obj: KafkaSpecCruiseControlTemplatePod | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_KafkaSpecCruiseControlTemplatePodMetadata(obj.metadata),
        'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_KafkaSpecCruiseControlTemplatePodImagePullSecrets(y)),
        'securityContext': toJson_KafkaSpecCruiseControlTemplatePodSecurityContext(obj.securityContext),
        'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
        'affinity': toJson_KafkaSpecCruiseControlTemplatePodAffinity(obj.affinity),
        'tolerations': obj.tolerations?.map(y => toJson_KafkaSpecCruiseControlTemplatePodTolerations(y)),
        'priorityClassName': obj.priorityClassName,
        'schedulerName': obj.schedulerName,
        'hostAliases': obj.hostAliases?.map(y => toJson_KafkaSpecCruiseControlTemplatePodHostAliases(y)),
        'tmpDirSizeLimit': obj.tmpDirSizeLimit,
        'enableServiceLinks': obj.enableServiceLinks,
        'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => toJson_KafkaSpecCruiseControlTemplatePodTopologySpreadConstraints(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for Cruise Control API `Service`.
 *
 * @schema KafkaSpecCruiseControlTemplateApiService
 */
export interface KafkaSpecCruiseControlTemplateApiService {
    /**
     * Metadata applied to the resource.
     *
     * @schema KafkaSpecCruiseControlTemplateApiService#metadata
     */
    readonly metadata?: KafkaSpecCruiseControlTemplateApiServiceMetadata;

    /**
     * Specifies the IP Family Policy used by the service. Available options are `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a single IP family. `PreferDualStack` is for two IP families on dual-stack configured clusters or a single IP family on single-stack clusters. `RequireDualStack` fails unless there are two IP families on dual-stack configured clusters. If unspecified, Kubernetes will choose the default value based on the service type. Available on Kubernetes 1.20 and newer.
     *
     * @schema KafkaSpecCruiseControlTemplateApiService#ipFamilyPolicy
     */
    readonly ipFamilyPolicy?: KafkaSpecCruiseControlTemplateApiServiceIpFamilyPolicy;

    /**
     * Specifies the IP Families used by the service. Available options are `IPv4` and `IPv6. If unspecified, Kubernetes will choose the default value based on the `ipFamilyPolicy` setting. Available on Kubernetes 1.20 and newer.
     *
     * @schema KafkaSpecCruiseControlTemplateApiService#ipFamilies
     */
    readonly ipFamilies?: KafkaSpecCruiseControlTemplateApiServiceIpFamilies[];

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplateApiService' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplateApiService(obj: KafkaSpecCruiseControlTemplateApiService | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_KafkaSpecCruiseControlTemplateApiServiceMetadata(obj.metadata),
        'ipFamilyPolicy': obj.ipFamilyPolicy,
        'ipFamilies': obj.ipFamilies?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for Cruise Control `PodDisruptionBudget`.
 *
 * @schema KafkaSpecCruiseControlTemplatePodDisruptionBudget
 */
export interface KafkaSpecCruiseControlTemplatePodDisruptionBudget {
    /**
     * Metadata to apply to the `PodDisruptionBudgetTemplate` resource.
     *
     * @schema KafkaSpecCruiseControlTemplatePodDisruptionBudget#metadata
     */
    readonly metadata?: KafkaSpecCruiseControlTemplatePodDisruptionBudgetMetadata;

    /**
     * Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
     *
     * @default 1.
     * @schema KafkaSpecCruiseControlTemplatePodDisruptionBudget#maxUnavailable
     */
    readonly maxUnavailable?: number;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodDisruptionBudget' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodDisruptionBudget(obj: KafkaSpecCruiseControlTemplatePodDisruptionBudget | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_KafkaSpecCruiseControlTemplatePodDisruptionBudgetMetadata(obj.metadata),
        'maxUnavailable': obj.maxUnavailable,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for the Cruise Control container.
 *
 * @schema KafkaSpecCruiseControlTemplateCruiseControlContainer
 */
export interface KafkaSpecCruiseControlTemplateCruiseControlContainer {
    /**
     * Environment variables which should be applied to the container.
     *
     * @schema KafkaSpecCruiseControlTemplateCruiseControlContainer#env
     */
    readonly env?: KafkaSpecCruiseControlTemplateCruiseControlContainerEnv[];

    /**
     * Security context for the container.
     *
     * @schema KafkaSpecCruiseControlTemplateCruiseControlContainer#securityContext
     */
    readonly securityContext?: KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplateCruiseControlContainer' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplateCruiseControlContainer(obj: KafkaSpecCruiseControlTemplateCruiseControlContainer | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'env': obj.env?.map(y => toJson_KafkaSpecCruiseControlTemplateCruiseControlContainerEnv(y)),
        'securityContext': toJson_KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext(obj.securityContext),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for the Cruise Control TLS sidecar container.
 *
 * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainer
 */
export interface KafkaSpecCruiseControlTemplateTlsSidecarContainer {
    /**
     * Environment variables which should be applied to the container.
     *
     * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainer#env
     */
    readonly env?: KafkaSpecCruiseControlTemplateTlsSidecarContainerEnv[];

    /**
     * Security context for the container.
     *
     * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainer#securityContext
     */
    readonly securityContext?: KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplateTlsSidecarContainer' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplateTlsSidecarContainer(obj: KafkaSpecCruiseControlTemplateTlsSidecarContainer | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'env': obj.env?.map(y => toJson_KafkaSpecCruiseControlTemplateTlsSidecarContainerEnv(y)),
        'securityContext': toJson_KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext(obj.securityContext),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for the Cruise Control service account.
 *
 * @schema KafkaSpecCruiseControlTemplateServiceAccount
 */
export interface KafkaSpecCruiseControlTemplateServiceAccount {
    /**
     * Metadata applied to the resource.
     *
     * @schema KafkaSpecCruiseControlTemplateServiceAccount#metadata
     */
    readonly metadata?: KafkaSpecCruiseControlTemplateServiceAccountMetadata;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplateServiceAccount' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplateServiceAccount(obj: KafkaSpecCruiseControlTemplateServiceAccount | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_KafkaSpecCruiseControlTemplateServiceAccountMetadata(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlBrokerCapacityOverrides
 */
export interface KafkaSpecCruiseControlBrokerCapacityOverrides {
    /**
     * List of Kafka brokers (broker identifiers).
     *
     * @schema KafkaSpecCruiseControlBrokerCapacityOverrides#brokers
     */
    readonly brokers: number[];

    /**
     * Broker capacity for CPU resource in cores or millicores. For example, 1, 1.500, 1500m. For more information on valid CPU resource units see https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#meaning-of-cpu.
     *
     * @schema KafkaSpecCruiseControlBrokerCapacityOverrides#cpu
     */
    readonly cpu?: string;

    /**
     * Broker capacity for inbound network throughput in bytes per second. Use an integer value with standard Kubernetes byte units (K, M, G) or their bibyte (power of two) equivalents (Ki, Mi, Gi) per second. For example, 10000KiB/s.
     *
     * @schema KafkaSpecCruiseControlBrokerCapacityOverrides#inboundNetwork
     */
    readonly inboundNetwork?: string;

    /**
     * Broker capacity for outbound network throughput in bytes per second. Use an integer value with standard Kubernetes byte units (K, M, G) or their bibyte (power of two) equivalents (Ki, Mi, Gi) per second. For example, 10000KiB/s.
     *
     * @schema KafkaSpecCruiseControlBrokerCapacityOverrides#outboundNetwork
     */
    readonly outboundNetwork?: string;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlBrokerCapacityOverrides' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlBrokerCapacityOverrides(obj: KafkaSpecCruiseControlBrokerCapacityOverrides | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'brokers': obj.brokers?.map(y => y),
        'cpu': obj.cpu,
        'inboundNetwork': obj.inboundNetwork,
        'outboundNetwork': obj.outboundNetwork,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Metrics type. Only 'jmxPrometheusExporter' supported currently.
 *
 * @schema KafkaSpecCruiseControlMetricsConfigType
 */
export enum KafkaSpecCruiseControlMetricsConfigType {
    /** jmxPrometheusExporter */
    JMX_PROMETHEUS_EXPORTER = "jmxPrometheusExporter",
}

/**
 * ConfigMap entry where the Prometheus JMX Exporter configuration is stored. For details of the structure of this configuration, see the {JMXExporter}.
 *
 * @schema KafkaSpecCruiseControlMetricsConfigValueFrom
 */
export interface KafkaSpecCruiseControlMetricsConfigValueFrom {
    /**
     * Reference to the key in the ConfigMap containing the configuration.
     *
     * @schema KafkaSpecCruiseControlMetricsConfigValueFrom#configMapKeyRef
     */
    readonly configMapKeyRef?: KafkaSpecCruiseControlMetricsConfigValueFromConfigMapKeyRef;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlMetricsConfigValueFrom' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlMetricsConfigValueFrom(obj: KafkaSpecCruiseControlMetricsConfigValueFrom | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'configMapKeyRef': toJson_KafkaSpecCruiseControlMetricsConfigValueFromConfigMapKeyRef(obj.configMapKeyRef),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransResourcesClaims
 */
export interface KafkaSpecJmxTransResourcesClaims {
    /**
     * @schema KafkaSpecJmxTransResourcesClaims#name
     */
    readonly name?: string;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransResourcesClaims' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransResourcesClaims(obj: KafkaSpecJmxTransResourcesClaims | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for JmxTrans `Deployment`.
 *
 * @schema KafkaSpecJmxTransTemplateDeployment
 */
export interface KafkaSpecJmxTransTemplateDeployment {
    /**
     * Metadata applied to the resource.
     *
     * @schema KafkaSpecJmxTransTemplateDeployment#metadata
     */
    readonly metadata?: KafkaSpecJmxTransTemplateDeploymentMetadata;

    /**
     * Pod replacement strategy for deployment configuration changes. Valid values are `RollingUpdate` and `Recreate`. Defaults to `RollingUpdate`.
     *
     * @default RollingUpdate`.
     * @schema KafkaSpecJmxTransTemplateDeployment#deploymentStrategy
     */
    readonly deploymentStrategy?: KafkaSpecJmxTransTemplateDeploymentDeploymentStrategy;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplateDeployment' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplateDeployment(obj: KafkaSpecJmxTransTemplateDeployment | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_KafkaSpecJmxTransTemplateDeploymentMetadata(obj.metadata),
        'deploymentStrategy': obj.deploymentStrategy,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for JmxTrans `Pods`.
 *
 * @schema KafkaSpecJmxTransTemplatePod
 */
export interface KafkaSpecJmxTransTemplatePod {
    /**
     * Metadata applied to the resource.
     *
     * @schema KafkaSpecJmxTransTemplatePod#metadata
     */
    readonly metadata?: KafkaSpecJmxTransTemplatePodMetadata;

    /**
     * List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
     *
     * @schema KafkaSpecJmxTransTemplatePod#imagePullSecrets
     */
    readonly imagePullSecrets?: KafkaSpecJmxTransTemplatePodImagePullSecrets[];

    /**
     * Configures pod-level security attributes and common container settings.
     *
     * @schema KafkaSpecJmxTransTemplatePod#securityContext
     */
    readonly securityContext?: KafkaSpecJmxTransTemplatePodSecurityContext;

    /**
     * The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
     *
     * @default 30 seconds.
     * @schema KafkaSpecJmxTransTemplatePod#terminationGracePeriodSeconds
     */
    readonly terminationGracePeriodSeconds?: number;

    /**
     * The pod's affinity rules.
     *
     * @schema KafkaSpecJmxTransTemplatePod#affinity
     */
    readonly affinity?: KafkaSpecJmxTransTemplatePodAffinity;

    /**
     * The pod's tolerations.
     *
     * @schema KafkaSpecJmxTransTemplatePod#tolerations
     */
    readonly tolerations?: KafkaSpecJmxTransTemplatePodTolerations[];

    /**
     * The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
     *
     * @schema KafkaSpecJmxTransTemplatePod#priorityClassName
     */
    readonly priorityClassName?: string;

    /**
     * The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
     *
     * @schema KafkaSpecJmxTransTemplatePod#schedulerName
     */
    readonly schedulerName?: string;

    /**
     * The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the Pod's hosts file if specified.
     *
     * @schema KafkaSpecJmxTransTemplatePod#hostAliases
     */
    readonly hostAliases?: KafkaSpecJmxTransTemplatePodHostAliases[];

    /**
     * Defines the total amount (for example `1Gi`) of local storage required for temporary EmptyDir volume (`/tmp`). Default value is `5Mi`.
     *
     * @schema KafkaSpecJmxTransTemplatePod#tmpDirSizeLimit
     */
    readonly tmpDirSizeLimit?: string;

    /**
     * Indicates whether information about services should be injected into Pod's environment variables.
     *
     * @schema KafkaSpecJmxTransTemplatePod#enableServiceLinks
     */
    readonly enableServiceLinks?: boolean;

    /**
     * The pod's topology spread constraints.
     *
     * @schema KafkaSpecJmxTransTemplatePod#topologySpreadConstraints
     */
    readonly topologySpreadConstraints?: KafkaSpecJmxTransTemplatePodTopologySpreadConstraints[];

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePod' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePod(obj: KafkaSpecJmxTransTemplatePod | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_KafkaSpecJmxTransTemplatePodMetadata(obj.metadata),
        'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_KafkaSpecJmxTransTemplatePodImagePullSecrets(y)),
        'securityContext': toJson_KafkaSpecJmxTransTemplatePodSecurityContext(obj.securityContext),
        'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
        'affinity': toJson_KafkaSpecJmxTransTemplatePodAffinity(obj.affinity),
        'tolerations': obj.tolerations?.map(y => toJson_KafkaSpecJmxTransTemplatePodTolerations(y)),
        'priorityClassName': obj.priorityClassName,
        'schedulerName': obj.schedulerName,
        'hostAliases': obj.hostAliases?.map(y => toJson_KafkaSpecJmxTransTemplatePodHostAliases(y)),
        'tmpDirSizeLimit': obj.tmpDirSizeLimit,
        'enableServiceLinks': obj.enableServiceLinks,
        'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => toJson_KafkaSpecJmxTransTemplatePodTopologySpreadConstraints(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for JmxTrans container.
 *
 * @schema KafkaSpecJmxTransTemplateContainer
 */
export interface KafkaSpecJmxTransTemplateContainer {
    /**
     * Environment variables which should be applied to the container.
     *
     * @schema KafkaSpecJmxTransTemplateContainer#env
     */
    readonly env?: KafkaSpecJmxTransTemplateContainerEnv[];

    /**
     * Security context for the container.
     *
     * @schema KafkaSpecJmxTransTemplateContainer#securityContext
     */
    readonly securityContext?: KafkaSpecJmxTransTemplateContainerSecurityContext;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplateContainer' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplateContainer(obj: KafkaSpecJmxTransTemplateContainer | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'env': obj.env?.map(y => toJson_KafkaSpecJmxTransTemplateContainerEnv(y)),
        'securityContext': toJson_KafkaSpecJmxTransTemplateContainerSecurityContext(obj.securityContext),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for the JmxTrans service account.
 *
 * @schema KafkaSpecJmxTransTemplateServiceAccount
 */
export interface KafkaSpecJmxTransTemplateServiceAccount {
    /**
     * Metadata applied to the resource.
     *
     * @schema KafkaSpecJmxTransTemplateServiceAccount#metadata
     */
    readonly metadata?: KafkaSpecJmxTransTemplateServiceAccountMetadata;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplateServiceAccount' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplateServiceAccount(obj: KafkaSpecJmxTransTemplateServiceAccount | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_KafkaSpecJmxTransTemplateServiceAccountMetadata(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterResourcesClaims
 */
export interface KafkaSpecKafkaExporterResourcesClaims {
    /**
     * @schema KafkaSpecKafkaExporterResourcesClaims#name
     */
    readonly name?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterResourcesClaims' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterResourcesClaims(obj: KafkaSpecKafkaExporterResourcesClaims | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka Exporter `Deployment`.
 *
 * @schema KafkaSpecKafkaExporterTemplateDeployment
 */
export interface KafkaSpecKafkaExporterTemplateDeployment {
    /**
     * Metadata applied to the resource.
     *
     * @schema KafkaSpecKafkaExporterTemplateDeployment#metadata
     */
    readonly metadata?: KafkaSpecKafkaExporterTemplateDeploymentMetadata;

    /**
     * Pod replacement strategy for deployment configuration changes. Valid values are `RollingUpdate` and `Recreate`. Defaults to `RollingUpdate`.
     *
     * @default RollingUpdate`.
     * @schema KafkaSpecKafkaExporterTemplateDeployment#deploymentStrategy
     */
    readonly deploymentStrategy?: KafkaSpecKafkaExporterTemplateDeploymentDeploymentStrategy;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplateDeployment' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplateDeployment(obj: KafkaSpecKafkaExporterTemplateDeployment | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_KafkaSpecKafkaExporterTemplateDeploymentMetadata(obj.metadata),
        'deploymentStrategy': obj.deploymentStrategy,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka Exporter `Pods`.
 *
 * @schema KafkaSpecKafkaExporterTemplatePod
 */
export interface KafkaSpecKafkaExporterTemplatePod {
    /**
     * Metadata applied to the resource.
     *
     * @schema KafkaSpecKafkaExporterTemplatePod#metadata
     */
    readonly metadata?: KafkaSpecKafkaExporterTemplatePodMetadata;

    /**
     * List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
     *
     * @schema KafkaSpecKafkaExporterTemplatePod#imagePullSecrets
     */
    readonly imagePullSecrets?: KafkaSpecKafkaExporterTemplatePodImagePullSecrets[];

    /**
     * Configures pod-level security attributes and common container settings.
     *
     * @schema KafkaSpecKafkaExporterTemplatePod#securityContext
     */
    readonly securityContext?: KafkaSpecKafkaExporterTemplatePodSecurityContext;

    /**
     * The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
     *
     * @default 30 seconds.
     * @schema KafkaSpecKafkaExporterTemplatePod#terminationGracePeriodSeconds
     */
    readonly terminationGracePeriodSeconds?: number;

    /**
     * The pod's affinity rules.
     *
     * @schema KafkaSpecKafkaExporterTemplatePod#affinity
     */
    readonly affinity?: KafkaSpecKafkaExporterTemplatePodAffinity;

    /**
     * The pod's tolerations.
     *
     * @schema KafkaSpecKafkaExporterTemplatePod#tolerations
     */
    readonly tolerations?: KafkaSpecKafkaExporterTemplatePodTolerations[];

    /**
     * The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
     *
     * @schema KafkaSpecKafkaExporterTemplatePod#priorityClassName
     */
    readonly priorityClassName?: string;

    /**
     * The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
     *
     * @schema KafkaSpecKafkaExporterTemplatePod#schedulerName
     */
    readonly schedulerName?: string;

    /**
     * The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the Pod's hosts file if specified.
     *
     * @schema KafkaSpecKafkaExporterTemplatePod#hostAliases
     */
    readonly hostAliases?: KafkaSpecKafkaExporterTemplatePodHostAliases[];

    /**
     * Defines the total amount (for example `1Gi`) of local storage required for temporary EmptyDir volume (`/tmp`). Default value is `5Mi`.
     *
     * @schema KafkaSpecKafkaExporterTemplatePod#tmpDirSizeLimit
     */
    readonly tmpDirSizeLimit?: string;

    /**
     * Indicates whether information about services should be injected into Pod's environment variables.
     *
     * @schema KafkaSpecKafkaExporterTemplatePod#enableServiceLinks
     */
    readonly enableServiceLinks?: boolean;

    /**
     * The pod's topology spread constraints.
     *
     * @schema KafkaSpecKafkaExporterTemplatePod#topologySpreadConstraints
     */
    readonly topologySpreadConstraints?: KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraints[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePod' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePod(obj: KafkaSpecKafkaExporterTemplatePod | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_KafkaSpecKafkaExporterTemplatePodMetadata(obj.metadata),
        'imagePullSecrets': obj.imagePullSecrets?.map(y => toJson_KafkaSpecKafkaExporterTemplatePodImagePullSecrets(y)),
        'securityContext': toJson_KafkaSpecKafkaExporterTemplatePodSecurityContext(obj.securityContext),
        'terminationGracePeriodSeconds': obj.terminationGracePeriodSeconds,
        'affinity': toJson_KafkaSpecKafkaExporterTemplatePodAffinity(obj.affinity),
        'tolerations': obj.tolerations?.map(y => toJson_KafkaSpecKafkaExporterTemplatePodTolerations(y)),
        'priorityClassName': obj.priorityClassName,
        'schedulerName': obj.schedulerName,
        'hostAliases': obj.hostAliases?.map(y => toJson_KafkaSpecKafkaExporterTemplatePodHostAliases(y)),
        'tmpDirSizeLimit': obj.tmpDirSizeLimit,
        'enableServiceLinks': obj.enableServiceLinks,
        'topologySpreadConstraints': obj.topologySpreadConstraints?.map(y => toJson_KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraints(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for Kafka Exporter `Service`.
 *
 * @schema KafkaSpecKafkaExporterTemplateService
 */
export interface KafkaSpecKafkaExporterTemplateService {
    /**
     * Metadata applied to the resource.
     *
     * @schema KafkaSpecKafkaExporterTemplateService#metadata
     */
    readonly metadata?: KafkaSpecKafkaExporterTemplateServiceMetadata;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplateService' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplateService(obj: KafkaSpecKafkaExporterTemplateService | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_KafkaSpecKafkaExporterTemplateServiceMetadata(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for the Kafka Exporter container.
 *
 * @schema KafkaSpecKafkaExporterTemplateContainer
 */
export interface KafkaSpecKafkaExporterTemplateContainer {
    /**
     * Environment variables which should be applied to the container.
     *
     * @schema KafkaSpecKafkaExporterTemplateContainer#env
     */
    readonly env?: KafkaSpecKafkaExporterTemplateContainerEnv[];

    /**
     * Security context for the container.
     *
     * @schema KafkaSpecKafkaExporterTemplateContainer#securityContext
     */
    readonly securityContext?: KafkaSpecKafkaExporterTemplateContainerSecurityContext;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplateContainer' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplateContainer(obj: KafkaSpecKafkaExporterTemplateContainer | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'env': obj.env?.map(y => toJson_KafkaSpecKafkaExporterTemplateContainerEnv(y)),
        'securityContext': toJson_KafkaSpecKafkaExporterTemplateContainerSecurityContext(obj.securityContext),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Template for the Kafka Exporter service account.
 *
 * @schema KafkaSpecKafkaExporterTemplateServiceAccount
 */
export interface KafkaSpecKafkaExporterTemplateServiceAccount {
    /**
     * Metadata applied to the resource.
     *
     * @schema KafkaSpecKafkaExporterTemplateServiceAccount#metadata
     */
    readonly metadata?: KafkaSpecKafkaExporterTemplateServiceAccountMetadata;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplateServiceAccount' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplateServiceAccount(obj: KafkaSpecKafkaExporterTemplateServiceAccount | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'metadata': toJson_KafkaSpecKafkaExporterTemplateServiceAccountMetadata(obj.metadata),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Link to Kubernetes Secret containing the OAuth client secret which the Kafka broker can use to authenticate against the authorization server and use the introspect endpoint URI.
 *
 * @schema KafkaSpecKafkaListenersAuthenticationClientSecret
 */
export interface KafkaSpecKafkaListenersAuthenticationClientSecret {
    /**
     * The key under which the secret value is stored in the Kubernetes Secret.
     *
     * @schema KafkaSpecKafkaListenersAuthenticationClientSecret#key
     */
    readonly key: string;

    /**
     * The name of the Kubernetes Secret containing the secret value.
     *
     * @schema KafkaSpecKafkaListenersAuthenticationClientSecret#secretName
     */
    readonly secretName: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaListenersAuthenticationClientSecret' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaListenersAuthenticationClientSecret(obj: KafkaSpecKafkaListenersAuthenticationClientSecret | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'secretName': obj.secretName,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaListenersAuthenticationSecrets
 */
export interface KafkaSpecKafkaListenersAuthenticationSecrets {
    /**
     * The key under which the secret value is stored in the Kubernetes Secret.
     *
     * @schema KafkaSpecKafkaListenersAuthenticationSecrets#key
     */
    readonly key: string;

    /**
     * The name of the Kubernetes Secret containing the secret value.
     *
     * @schema KafkaSpecKafkaListenersAuthenticationSecrets#secretName
     */
    readonly secretName: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaListenersAuthenticationSecrets' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaListenersAuthenticationSecrets(obj: KafkaSpecKafkaListenersAuthenticationSecrets | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'secretName': obj.secretName,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaListenersAuthenticationTlsTrustedCertificates
 */
export interface KafkaSpecKafkaListenersAuthenticationTlsTrustedCertificates {
    /**
     * The name of the file certificate in the Secret.
     *
     * @schema KafkaSpecKafkaListenersAuthenticationTlsTrustedCertificates#certificate
     */
    readonly certificate: string;

    /**
     * The name of the Secret containing the certificate.
     *
     * @schema KafkaSpecKafkaListenersAuthenticationTlsTrustedCertificates#secretName
     */
    readonly secretName: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaListenersAuthenticationTlsTrustedCertificates' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaListenersAuthenticationTlsTrustedCertificates(obj: KafkaSpecKafkaListenersAuthenticationTlsTrustedCertificates | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'certificate': obj.certificate,
        'secretName': obj.secretName,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Authentication type. `oauth` type uses SASL OAUTHBEARER Authentication. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `tls` type uses TLS Client Authentication. `tls` type is supported only on TLS listeners.`custom` type allows for any authentication type to be used.
 *
 * @schema KafkaSpecKafkaListenersAuthenticationType
 */
export enum KafkaSpecKafkaListenersAuthenticationType {
    /** tls */
    TLS = "tls",
    /** scram-sha-512 */
    SCRAM_SHA_512 = "scram-sha-512",
    /** oauth */
    OAUTH = "oauth",
    /** custom */
    CUSTOM = "custom",
}

/**
 * Reference to the `Secret` which holds the certificate and private key pair which will be used for this listener. The certificate can optionally contain the whole chain. This field can be used only with listeners with enabled TLS encryption.
 *
 * @schema KafkaSpecKafkaListenersConfigurationBrokerCertChainAndKey
 */
export interface KafkaSpecKafkaListenersConfigurationBrokerCertChainAndKey {
    /**
     * The name of the file certificate in the Secret.
     *
     * @schema KafkaSpecKafkaListenersConfigurationBrokerCertChainAndKey#certificate
     */
    readonly certificate: string;

    /**
     * The name of the private key in the Secret.
     *
     * @schema KafkaSpecKafkaListenersConfigurationBrokerCertChainAndKey#key
     */
    readonly key: string;

    /**
     * The name of the Secret containing the certificate.
     *
     * @schema KafkaSpecKafkaListenersConfigurationBrokerCertChainAndKey#secretName
     */
    readonly secretName: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaListenersConfigurationBrokerCertChainAndKey' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaListenersConfigurationBrokerCertChainAndKey(obj: KafkaSpecKafkaListenersConfigurationBrokerCertChainAndKey | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'certificate': obj.certificate,
        'key': obj.key,
        'secretName': obj.secretName,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Specifies whether the service routes external traffic to node-local or cluster-wide endpoints. `Cluster` may cause a second hop to another node and obscures the client source IP. `Local` avoids a second hop for LoadBalancer and Nodeport type services and preserves the client source IP (when supported by the infrastructure). If unspecified, Kubernetes will use `Cluster` as the default.This field can be used only with `loadbalancer` or `nodeport` type listener.
 *
 * @schema KafkaSpecKafkaListenersConfigurationExternalTrafficPolicy
 */
export enum KafkaSpecKafkaListenersConfigurationExternalTrafficPolicy {
    /** Local */
    LOCAL = "Local",
    /** Cluster */
    CLUSTER = "Cluster",
}

/**
 * Bootstrap configuration.
 *
 * @schema KafkaSpecKafkaListenersConfigurationBootstrap
 */
export interface KafkaSpecKafkaListenersConfigurationBootstrap {
    /**
     * Additional alternative names for the bootstrap service. The alternative names will be added to the list of subject alternative names of the TLS certificates.
     *
     * @schema KafkaSpecKafkaListenersConfigurationBootstrap#alternativeNames
     */
    readonly alternativeNames?: string[];

    /**
     * The bootstrap host. This field will be used in the Ingress resource or in the Route resource to specify the desired hostname. This field can be used only with `route` (optional) or `ingress` (required) type listeners.
     *
     * @schema KafkaSpecKafkaListenersConfigurationBootstrap#host
     */
    readonly host?: string;

    /**
     * Node port for the bootstrap service. This field can be used only with `nodeport` type listener.
     *
     * @schema KafkaSpecKafkaListenersConfigurationBootstrap#nodePort
     */
    readonly nodePort?: number;

    /**
     * The loadbalancer is requested with the IP address specified in this field. This feature depends on whether the underlying cloud provider supports specifying the `loadBalancerIP` when a load balancer is created. This field is ignored if the cloud provider does not support the feature.This field can be used only with `loadbalancer` type listener.
     *
     * @schema KafkaSpecKafkaListenersConfigurationBootstrap#loadBalancerIP
     */
    readonly loadBalancerIp?: string;

    /**
     * Annotations that will be added to the `Ingress`, `Route`, or `Service` resource. You can use this field to configure DNS providers such as External DNS. This field can be used only with `loadbalancer`, `nodeport`, `route`, or `ingress` type listeners.
     *
     * @schema KafkaSpecKafkaListenersConfigurationBootstrap#annotations
     */
    readonly annotations?: any;

    /**
     * Labels that will be added to the `Ingress`, `Route`, or `Service` resource. This field can be used only with `loadbalancer`, `nodeport`, `route`, or `ingress` type listeners.
     *
     * @schema KafkaSpecKafkaListenersConfigurationBootstrap#labels
     */
    readonly labels?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaListenersConfigurationBootstrap' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaListenersConfigurationBootstrap(obj: KafkaSpecKafkaListenersConfigurationBootstrap | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'alternativeNames': obj.alternativeNames?.map(y => y),
        'host': obj.host,
        'nodePort': obj.nodePort,
        'loadBalancerIP': obj.loadBalancerIp,
        'annotations': obj.annotations,
        'labels': obj.labels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaListenersConfigurationBrokers
 */
export interface KafkaSpecKafkaListenersConfigurationBrokers {
    /**
     * ID of the kafka broker (broker identifier). Broker IDs start from 0 and correspond to the number of broker replicas.
     *
     * @schema KafkaSpecKafkaListenersConfigurationBrokers#broker
     */
    readonly broker: number;

    /**
     * The host name which will be used in the brokers' `advertised.brokers`.
     *
     * @schema KafkaSpecKafkaListenersConfigurationBrokers#advertisedHost
     */
    readonly advertisedHost?: string;

    /**
     * The port number which will be used in the brokers' `advertised.brokers`.
     *
     * @schema KafkaSpecKafkaListenersConfigurationBrokers#advertisedPort
     */
    readonly advertisedPort?: number;

    /**
     * The broker host. This field will be used in the Ingress resource or in the Route resource to specify the desired hostname. This field can be used only with `route` (optional) or `ingress` (required) type listeners.
     *
     * @schema KafkaSpecKafkaListenersConfigurationBrokers#host
     */
    readonly host?: string;

    /**
     * Node port for the per-broker service. This field can be used only with `nodeport` type listener.
     *
     * @schema KafkaSpecKafkaListenersConfigurationBrokers#nodePort
     */
    readonly nodePort?: number;

    /**
     * The loadbalancer is requested with the IP address specified in this field. This feature depends on whether the underlying cloud provider supports specifying the `loadBalancerIP` when a load balancer is created. This field is ignored if the cloud provider does not support the feature.This field can be used only with `loadbalancer` type listener.
     *
     * @schema KafkaSpecKafkaListenersConfigurationBrokers#loadBalancerIP
     */
    readonly loadBalancerIp?: string;

    /**
     * Annotations that will be added to the `Ingress` or `Service` resource. You can use this field to configure DNS providers such as External DNS. This field can be used only with `loadbalancer`, `nodeport`, or `ingress` type listeners.
     *
     * @schema KafkaSpecKafkaListenersConfigurationBrokers#annotations
     */
    readonly annotations?: any;

    /**
     * Labels that will be added to the `Ingress`, `Route`, or `Service` resource. This field can be used only with `loadbalancer`, `nodeport`, `route`, or `ingress` type listeners.
     *
     * @schema KafkaSpecKafkaListenersConfigurationBrokers#labels
     */
    readonly labels?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaListenersConfigurationBrokers' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaListenersConfigurationBrokers(obj: KafkaSpecKafkaListenersConfigurationBrokers | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'broker': obj.broker,
        'advertisedHost': obj.advertisedHost,
        'advertisedPort': obj.advertisedPort,
        'host': obj.host,
        'nodePort': obj.nodePort,
        'loadBalancerIP': obj.loadBalancerIp,
        'annotations': obj.annotations,
        'labels': obj.labels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Specifies the IP Family Policy used by the service. Available options are `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a single IP family. `PreferDualStack` is for two IP families on dual-stack configured clusters or a single IP family on single-stack clusters. `RequireDualStack` fails unless there are two IP families on dual-stack configured clusters. If unspecified, Kubernetes will choose the default value based on the service type. Available on Kubernetes 1.20 and newer.
 *
 * @schema KafkaSpecKafkaListenersConfigurationIpFamilyPolicy
 */
export enum KafkaSpecKafkaListenersConfigurationIpFamilyPolicy {
    /** SingleStack */
    SINGLE_STACK = "SingleStack",
    /** PreferDualStack */
    PREFER_DUAL_STACK = "PreferDualStack",
    /** RequireDualStack */
    REQUIRE_DUAL_STACK = "RequireDualStack",
}

/**
 * @schema KafkaSpecKafkaListenersConfigurationIpFamilies
 */
export enum KafkaSpecKafkaListenersConfigurationIpFamilies {
    /** IPv4 */
    I_PV4 = "IPv4",
    /** IPv6 */
    I_PV6 = "IPv6",
}

/**
 * Defines which address type should be used as the node address. Available types are: `ExternalDNS`, `ExternalIP`, `InternalDNS`, `InternalIP` and `Hostname`. By default, the addresses will be used in the following order (the first one found will be used):
 *
 * * `ExternalDNS`
 * * `ExternalIP`
 * * `InternalDNS`
 * * `InternalIP`
 * * `Hostname`
 *
 * This field is used to select the preferred address type, which is checked first. If no address is found for this address type, the other types are checked in the default order. This field can only be used with `nodeport` type listener.
 *
 * @schema KafkaSpecKafkaListenersConfigurationPreferredNodePortAddressType
 */
export enum KafkaSpecKafkaListenersConfigurationPreferredNodePortAddressType {
    /** ExternalIP */
    EXTERNAL_IP = "ExternalIP",
    /** ExternalDNS */
    EXTERNAL_DNS = "ExternalDNS",
    /** InternalIP */
    INTERNAL_IP = "InternalIP",
    /** InternalDNS */
    INTERNAL_DNS = "InternalDNS",
    /** Hostname */
    HOSTNAME = "Hostname",
}

/**
 * @schema KafkaSpecKafkaListenersNetworkPolicyPeersIpBlock
 */
export interface KafkaSpecKafkaListenersNetworkPolicyPeersIpBlock {
    /**
     * @schema KafkaSpecKafkaListenersNetworkPolicyPeersIpBlock#cidr
     */
    readonly cidr?: string;

    /**
     * @schema KafkaSpecKafkaListenersNetworkPolicyPeersIpBlock#except
     */
    readonly except?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaListenersNetworkPolicyPeersIpBlock' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaListenersNetworkPolicyPeersIpBlock(obj: KafkaSpecKafkaListenersNetworkPolicyPeersIpBlock | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'cidr': obj.cidr,
        'except': obj.except?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaListenersNetworkPolicyPeersNamespaceSelector
 */
export interface KafkaSpecKafkaListenersNetworkPolicyPeersNamespaceSelector {
    /**
     * @schema KafkaSpecKafkaListenersNetworkPolicyPeersNamespaceSelector#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecKafkaListenersNetworkPolicyPeersNamespaceSelectorMatchExpressions[];

    /**
     * @schema KafkaSpecKafkaListenersNetworkPolicyPeersNamespaceSelector#matchLabels
     */
    readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaListenersNetworkPolicyPeersNamespaceSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaListenersNetworkPolicyPeersNamespaceSelector(obj: KafkaSpecKafkaListenersNetworkPolicyPeersNamespaceSelector | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecKafkaListenersNetworkPolicyPeersNamespaceSelectorMatchExpressions(y)),
        'matchLabels': obj.matchLabels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaListenersNetworkPolicyPeersPodSelector
 */
export interface KafkaSpecKafkaListenersNetworkPolicyPeersPodSelector {
    /**
     * @schema KafkaSpecKafkaListenersNetworkPolicyPeersPodSelector#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecKafkaListenersNetworkPolicyPeersPodSelectorMatchExpressions[];

    /**
     * @schema KafkaSpecKafkaListenersNetworkPolicyPeersPodSelector#matchLabels
     */
    readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaListenersNetworkPolicyPeersPodSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaListenersNetworkPolicyPeersPodSelector(obj: KafkaSpecKafkaListenersNetworkPolicyPeersPodSelector | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecKafkaListenersNetworkPolicyPeersPodSelectorMatchExpressions(y)),
        'matchLabels': obj.matchLabels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaStorageVolumesOverrides
 */
export interface KafkaSpecKafkaStorageVolumesOverrides {
    /**
     * The storage class to use for dynamic volume allocation for this broker.
     *
     * @schema KafkaSpecKafkaStorageVolumesOverrides#class
     */
    readonly class?: string;

    /**
     * Id of the kafka broker (broker identifier).
     *
     * @schema KafkaSpecKafkaStorageVolumesOverrides#broker
     */
    readonly broker?: number;

}

/**
 * Converts an object of type 'KafkaSpecKafkaStorageVolumesOverrides' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaStorageVolumesOverrides(obj: KafkaSpecKafkaStorageVolumesOverrides | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'class': obj.class,
        'broker': obj.broker,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Storage type, must be either 'ephemeral' or 'persistent-claim'.
 *
 * @schema KafkaSpecKafkaStorageVolumesType
 */
export enum KafkaSpecKafkaStorageVolumesType {
    /** ephemeral */
    EPHEMERAL = "ephemeral",
    /** persistent-claim */
    PERSISTENT_CLAIM = "persistent-claim",
}

/**
 * Authentication type. Currently the only supported types are `password`.`password` type creates a username and protected port with no TLS.
 *
 * @schema KafkaSpecKafkaJmxOptionsAuthenticationType
 */
export enum KafkaSpecKafkaJmxOptionsAuthenticationType {
    /** password */
    PASSWORD = "password",
}

/**
 * Reference to the key in the ConfigMap containing the configuration.
 *
 * @schema KafkaSpecKafkaMetricsConfigValueFromConfigMapKeyRef
 */
export interface KafkaSpecKafkaMetricsConfigValueFromConfigMapKeyRef {
    /**
     * @schema KafkaSpecKafkaMetricsConfigValueFromConfigMapKeyRef#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecKafkaMetricsConfigValueFromConfigMapKeyRef#name
     */
    readonly name?: string;

    /**
     * @schema KafkaSpecKafkaMetricsConfigValueFromConfigMapKeyRef#optional
     */
    readonly optional?: boolean;

}

/**
 * Converts an object of type 'KafkaSpecKafkaMetricsConfigValueFromConfigMapKeyRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaMetricsConfigValueFromConfigMapKeyRef(obj: KafkaSpecKafkaMetricsConfigValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'name': obj.name,
        'optional': obj.optional,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Reference to the key in the ConfigMap containing the configuration.
 *
 * @schema KafkaSpecKafkaLoggingValueFromConfigMapKeyRef
 */
export interface KafkaSpecKafkaLoggingValueFromConfigMapKeyRef {
    /**
     * @schema KafkaSpecKafkaLoggingValueFromConfigMapKeyRef#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecKafkaLoggingValueFromConfigMapKeyRef#name
     */
    readonly name?: string;

    /**
     * @schema KafkaSpecKafkaLoggingValueFromConfigMapKeyRef#optional
     */
    readonly optional?: boolean;

}

/**
 * Converts an object of type 'KafkaSpecKafkaLoggingValueFromConfigMapKeyRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaLoggingValueFromConfigMapKeyRef(obj: KafkaSpecKafkaLoggingValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'name': obj.name,
        'optional': obj.optional,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaTemplateStatefulsetMetadata
 */
export interface KafkaSpecKafkaTemplateStatefulsetMetadata {
    /**
     * Labels added to the Kubernetes resource.
     *
     * @schema KafkaSpecKafkaTemplateStatefulsetMetadata#labels
     */
    readonly labels?: any;

    /**
     * Annotations added to the Kubernetes resource.
     *
     * @schema KafkaSpecKafkaTemplateStatefulsetMetadata#annotations
     */
    readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateStatefulsetMetadata' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateStatefulsetMetadata(obj: KafkaSpecKafkaTemplateStatefulsetMetadata | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labels': obj.labels,
        'annotations': obj.annotations,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * PodManagementPolicy which will be used for this StatefulSet. Valid values are `Parallel` and `OrderedReady`. Defaults to `Parallel`.
 *
 * @default Parallel`.
 * @schema KafkaSpecKafkaTemplateStatefulsetPodManagementPolicy
 */
export enum KafkaSpecKafkaTemplateStatefulsetPodManagementPolicy {
    /** OrderedReady */
    ORDERED_READY = "OrderedReady",
    /** Parallel */
    PARALLEL = "Parallel",
}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaTemplatePodMetadata
 */
export interface KafkaSpecKafkaTemplatePodMetadata {
    /**
     * Labels added to the Kubernetes resource.
     *
     * @schema KafkaSpecKafkaTemplatePodMetadata#labels
     */
    readonly labels?: any;

    /**
     * Annotations added to the Kubernetes resource.
     *
     * @schema KafkaSpecKafkaTemplatePodMetadata#annotations
     */
    readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodMetadata' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodMetadata(obj: KafkaSpecKafkaTemplatePodMetadata | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labels': obj.labels,
        'annotations': obj.annotations,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodImagePullSecrets
 */
export interface KafkaSpecKafkaTemplatePodImagePullSecrets {
    /**
     * @schema KafkaSpecKafkaTemplatePodImagePullSecrets#name
     */
    readonly name?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodImagePullSecrets' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodImagePullSecrets(obj: KafkaSpecKafkaTemplatePodImagePullSecrets | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Configures pod-level security attributes and common container settings.
 *
 * @schema KafkaSpecKafkaTemplatePodSecurityContext
 */
export interface KafkaSpecKafkaTemplatePodSecurityContext {
    /**
     * @schema KafkaSpecKafkaTemplatePodSecurityContext#fsGroup
     */
    readonly fsGroup?: number;

    /**
     * @schema KafkaSpecKafkaTemplatePodSecurityContext#fsGroupChangePolicy
     */
    readonly fsGroupChangePolicy?: string;

    /**
     * @schema KafkaSpecKafkaTemplatePodSecurityContext#runAsGroup
     */
    readonly runAsGroup?: number;

    /**
     * @schema KafkaSpecKafkaTemplatePodSecurityContext#runAsNonRoot
     */
    readonly runAsNonRoot?: boolean;

    /**
     * @schema KafkaSpecKafkaTemplatePodSecurityContext#runAsUser
     */
    readonly runAsUser?: number;

    /**
     * @schema KafkaSpecKafkaTemplatePodSecurityContext#seLinuxOptions
     */
    readonly seLinuxOptions?: KafkaSpecKafkaTemplatePodSecurityContextSeLinuxOptions;

    /**
     * @schema KafkaSpecKafkaTemplatePodSecurityContext#seccompProfile
     */
    readonly seccompProfile?: KafkaSpecKafkaTemplatePodSecurityContextSeccompProfile;

    /**
     * @schema KafkaSpecKafkaTemplatePodSecurityContext#supplementalGroups
     */
    readonly supplementalGroups?: number[];

    /**
     * @schema KafkaSpecKafkaTemplatePodSecurityContext#sysctls
     */
    readonly sysctls?: KafkaSpecKafkaTemplatePodSecurityContextSysctls[];

    /**
     * @schema KafkaSpecKafkaTemplatePodSecurityContext#windowsOptions
     */
    readonly windowsOptions?: KafkaSpecKafkaTemplatePodSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodSecurityContext' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodSecurityContext(obj: KafkaSpecKafkaTemplatePodSecurityContext | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'fsGroup': obj.fsGroup,
        'fsGroupChangePolicy': obj.fsGroupChangePolicy,
        'runAsGroup': obj.runAsGroup,
        'runAsNonRoot': obj.runAsNonRoot,
        'runAsUser': obj.runAsUser,
        'seLinuxOptions': toJson_KafkaSpecKafkaTemplatePodSecurityContextSeLinuxOptions(obj.seLinuxOptions),
        'seccompProfile': toJson_KafkaSpecKafkaTemplatePodSecurityContextSeccompProfile(obj.seccompProfile),
        'supplementalGroups': obj.supplementalGroups?.map(y => y),
        'sysctls': obj.sysctls?.map(y => toJson_KafkaSpecKafkaTemplatePodSecurityContextSysctls(y)),
        'windowsOptions': toJson_KafkaSpecKafkaTemplatePodSecurityContextWindowsOptions(obj.windowsOptions),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * The pod's affinity rules.
 *
 * @schema KafkaSpecKafkaTemplatePodAffinity
 */
export interface KafkaSpecKafkaTemplatePodAffinity {
    /**
     * @schema KafkaSpecKafkaTemplatePodAffinity#nodeAffinity
     */
    readonly nodeAffinity?: KafkaSpecKafkaTemplatePodAffinityNodeAffinity;

    /**
     * @schema KafkaSpecKafkaTemplatePodAffinity#podAffinity
     */
    readonly podAffinity?: KafkaSpecKafkaTemplatePodAffinityPodAffinity;

    /**
     * @schema KafkaSpecKafkaTemplatePodAffinity#podAntiAffinity
     */
    readonly podAntiAffinity?: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinity;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinity' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinity(obj: KafkaSpecKafkaTemplatePodAffinity | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'nodeAffinity': toJson_KafkaSpecKafkaTemplatePodAffinityNodeAffinity(obj.nodeAffinity),
        'podAffinity': toJson_KafkaSpecKafkaTemplatePodAffinityPodAffinity(obj.podAffinity),
        'podAntiAffinity': toJson_KafkaSpecKafkaTemplatePodAffinityPodAntiAffinity(obj.podAntiAffinity),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodTolerations
 */
export interface KafkaSpecKafkaTemplatePodTolerations {
    /**
     * @schema KafkaSpecKafkaTemplatePodTolerations#effect
     */
    readonly effect?: string;

    /**
     * @schema KafkaSpecKafkaTemplatePodTolerations#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecKafkaTemplatePodTolerations#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecKafkaTemplatePodTolerations#tolerationSeconds
     */
    readonly tolerationSeconds?: number;

    /**
     * @schema KafkaSpecKafkaTemplatePodTolerations#value
     */
    readonly value?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodTolerations' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodTolerations(obj: KafkaSpecKafkaTemplatePodTolerations | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'effect': obj.effect,
        'key': obj.key,
        'operator': obj.operator,
        'tolerationSeconds': obj.tolerationSeconds,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodHostAliases
 */
export interface KafkaSpecKafkaTemplatePodHostAliases {
    /**
     * @schema KafkaSpecKafkaTemplatePodHostAliases#hostnames
     */
    readonly hostnames?: string[];

    /**
     * @schema KafkaSpecKafkaTemplatePodHostAliases#ip
     */
    readonly ip?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodHostAliases' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodHostAliases(obj: KafkaSpecKafkaTemplatePodHostAliases | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'hostnames': obj.hostnames?.map(y => y),
        'ip': obj.ip,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodTopologySpreadConstraints
 */
export interface KafkaSpecKafkaTemplatePodTopologySpreadConstraints {
    /**
     * @schema KafkaSpecKafkaTemplatePodTopologySpreadConstraints#labelSelector
     */
    readonly labelSelector?: KafkaSpecKafkaTemplatePodTopologySpreadConstraintsLabelSelector;

    /**
     * @schema KafkaSpecKafkaTemplatePodTopologySpreadConstraints#matchLabelKeys
     */
    readonly matchLabelKeys?: string[];

    /**
     * @schema KafkaSpecKafkaTemplatePodTopologySpreadConstraints#maxSkew
     */
    readonly maxSkew?: number;

    /**
     * @schema KafkaSpecKafkaTemplatePodTopologySpreadConstraints#minDomains
     */
    readonly minDomains?: number;

    /**
     * @schema KafkaSpecKafkaTemplatePodTopologySpreadConstraints#nodeAffinityPolicy
     */
    readonly nodeAffinityPolicy?: string;

    /**
     * @schema KafkaSpecKafkaTemplatePodTopologySpreadConstraints#nodeTaintsPolicy
     */
    readonly nodeTaintsPolicy?: string;

    /**
     * @schema KafkaSpecKafkaTemplatePodTopologySpreadConstraints#topologyKey
     */
    readonly topologyKey?: string;

    /**
     * @schema KafkaSpecKafkaTemplatePodTopologySpreadConstraints#whenUnsatisfiable
     */
    readonly whenUnsatisfiable?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodTopologySpreadConstraints' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodTopologySpreadConstraints(obj: KafkaSpecKafkaTemplatePodTopologySpreadConstraints | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labelSelector': toJson_KafkaSpecKafkaTemplatePodTopologySpreadConstraintsLabelSelector(obj.labelSelector),
        'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
        'maxSkew': obj.maxSkew,
        'minDomains': obj.minDomains,
        'nodeAffinityPolicy': obj.nodeAffinityPolicy,
        'nodeTaintsPolicy': obj.nodeTaintsPolicy,
        'topologyKey': obj.topologyKey,
        'whenUnsatisfiable': obj.whenUnsatisfiable,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaTemplateBootstrapServiceMetadata
 */
export interface KafkaSpecKafkaTemplateBootstrapServiceMetadata {
    /**
     * Labels added to the Kubernetes resource.
     *
     * @schema KafkaSpecKafkaTemplateBootstrapServiceMetadata#labels
     */
    readonly labels?: any;

    /**
     * Annotations added to the Kubernetes resource.
     *
     * @schema KafkaSpecKafkaTemplateBootstrapServiceMetadata#annotations
     */
    readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateBootstrapServiceMetadata' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateBootstrapServiceMetadata(obj: KafkaSpecKafkaTemplateBootstrapServiceMetadata | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labels': obj.labels,
        'annotations': obj.annotations,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Specifies the IP Family Policy used by the service. Available options are `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a single IP family. `PreferDualStack` is for two IP families on dual-stack configured clusters or a single IP family on single-stack clusters. `RequireDualStack` fails unless there are two IP families on dual-stack configured clusters. If unspecified, Kubernetes will choose the default value based on the service type. Available on Kubernetes 1.20 and newer.
 *
 * @schema KafkaSpecKafkaTemplateBootstrapServiceIpFamilyPolicy
 */
export enum KafkaSpecKafkaTemplateBootstrapServiceIpFamilyPolicy {
    /** SingleStack */
    SINGLE_STACK = "SingleStack",
    /** PreferDualStack */
    PREFER_DUAL_STACK = "PreferDualStack",
    /** RequireDualStack */
    REQUIRE_DUAL_STACK = "RequireDualStack",
}

/**
 * @schema KafkaSpecKafkaTemplateBootstrapServiceIpFamilies
 */
export enum KafkaSpecKafkaTemplateBootstrapServiceIpFamilies {
    /** IPv4 */
    I_PV4 = "IPv4",
    /** IPv6 */
    I_PV6 = "IPv6",
}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaTemplateBrokersServiceMetadata
 */
export interface KafkaSpecKafkaTemplateBrokersServiceMetadata {
    /**
     * Labels added to the Kubernetes resource.
     *
     * @schema KafkaSpecKafkaTemplateBrokersServiceMetadata#labels
     */
    readonly labels?: any;

    /**
     * Annotations added to the Kubernetes resource.
     *
     * @schema KafkaSpecKafkaTemplateBrokersServiceMetadata#annotations
     */
    readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateBrokersServiceMetadata' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateBrokersServiceMetadata(obj: KafkaSpecKafkaTemplateBrokersServiceMetadata | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labels': obj.labels,
        'annotations': obj.annotations,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Specifies the IP Family Policy used by the service. Available options are `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a single IP family. `PreferDualStack` is for two IP families on dual-stack configured clusters or a single IP family on single-stack clusters. `RequireDualStack` fails unless there are two IP families on dual-stack configured clusters. If unspecified, Kubernetes will choose the default value based on the service type. Available on Kubernetes 1.20 and newer.
 *
 * @schema KafkaSpecKafkaTemplateBrokersServiceIpFamilyPolicy
 */
export enum KafkaSpecKafkaTemplateBrokersServiceIpFamilyPolicy {
    /** SingleStack */
    SINGLE_STACK = "SingleStack",
    /** PreferDualStack */
    PREFER_DUAL_STACK = "PreferDualStack",
    /** RequireDualStack */
    REQUIRE_DUAL_STACK = "RequireDualStack",
}

/**
 * @schema KafkaSpecKafkaTemplateBrokersServiceIpFamilies
 */
export enum KafkaSpecKafkaTemplateBrokersServiceIpFamilies {
    /** IPv4 */
    I_PV4 = "IPv4",
    /** IPv6 */
    I_PV6 = "IPv6",
}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaTemplateExternalBootstrapServiceMetadata
 */
export interface KafkaSpecKafkaTemplateExternalBootstrapServiceMetadata {
    /**
     * Labels added to the Kubernetes resource.
     *
     * @schema KafkaSpecKafkaTemplateExternalBootstrapServiceMetadata#labels
     */
    readonly labels?: any;

    /**
     * Annotations added to the Kubernetes resource.
     *
     * @schema KafkaSpecKafkaTemplateExternalBootstrapServiceMetadata#annotations
     */
    readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateExternalBootstrapServiceMetadata' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateExternalBootstrapServiceMetadata(obj: KafkaSpecKafkaTemplateExternalBootstrapServiceMetadata | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labels': obj.labels,
        'annotations': obj.annotations,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaTemplatePerPodServiceMetadata
 */
export interface KafkaSpecKafkaTemplatePerPodServiceMetadata {
    /**
     * Labels added to the Kubernetes resource.
     *
     * @schema KafkaSpecKafkaTemplatePerPodServiceMetadata#labels
     */
    readonly labels?: any;

    /**
     * Annotations added to the Kubernetes resource.
     *
     * @schema KafkaSpecKafkaTemplatePerPodServiceMetadata#annotations
     */
    readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePerPodServiceMetadata' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePerPodServiceMetadata(obj: KafkaSpecKafkaTemplatePerPodServiceMetadata | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labels': obj.labels,
        'annotations': obj.annotations,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaTemplateExternalBootstrapRouteMetadata
 */
export interface KafkaSpecKafkaTemplateExternalBootstrapRouteMetadata {
    /**
     * Labels added to the Kubernetes resource.
     *
     * @schema KafkaSpecKafkaTemplateExternalBootstrapRouteMetadata#labels
     */
    readonly labels?: any;

    /**
     * Annotations added to the Kubernetes resource.
     *
     * @schema KafkaSpecKafkaTemplateExternalBootstrapRouteMetadata#annotations
     */
    readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateExternalBootstrapRouteMetadata' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateExternalBootstrapRouteMetadata(obj: KafkaSpecKafkaTemplateExternalBootstrapRouteMetadata | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labels': obj.labels,
        'annotations': obj.annotations,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaTemplatePerPodRouteMetadata
 */
export interface KafkaSpecKafkaTemplatePerPodRouteMetadata {
    /**
     * Labels added to the Kubernetes resource.
     *
     * @schema KafkaSpecKafkaTemplatePerPodRouteMetadata#labels
     */
    readonly labels?: any;

    /**
     * Annotations added to the Kubernetes resource.
     *
     * @schema KafkaSpecKafkaTemplatePerPodRouteMetadata#annotations
     */
    readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePerPodRouteMetadata' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePerPodRouteMetadata(obj: KafkaSpecKafkaTemplatePerPodRouteMetadata | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labels': obj.labels,
        'annotations': obj.annotations,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaTemplateExternalBootstrapIngressMetadata
 */
export interface KafkaSpecKafkaTemplateExternalBootstrapIngressMetadata {
    /**
     * Labels added to the Kubernetes resource.
     *
     * @schema KafkaSpecKafkaTemplateExternalBootstrapIngressMetadata#labels
     */
    readonly labels?: any;

    /**
     * Annotations added to the Kubernetes resource.
     *
     * @schema KafkaSpecKafkaTemplateExternalBootstrapIngressMetadata#annotations
     */
    readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateExternalBootstrapIngressMetadata' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateExternalBootstrapIngressMetadata(obj: KafkaSpecKafkaTemplateExternalBootstrapIngressMetadata | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labels': obj.labels,
        'annotations': obj.annotations,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaTemplatePerPodIngressMetadata
 */
export interface KafkaSpecKafkaTemplatePerPodIngressMetadata {
    /**
     * Labels added to the Kubernetes resource.
     *
     * @schema KafkaSpecKafkaTemplatePerPodIngressMetadata#labels
     */
    readonly labels?: any;

    /**
     * Annotations added to the Kubernetes resource.
     *
     * @schema KafkaSpecKafkaTemplatePerPodIngressMetadata#annotations
     */
    readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePerPodIngressMetadata' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePerPodIngressMetadata(obj: KafkaSpecKafkaTemplatePerPodIngressMetadata | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labels': obj.labels,
        'annotations': obj.annotations,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaTemplatePersistentVolumeClaimMetadata
 */
export interface KafkaSpecKafkaTemplatePersistentVolumeClaimMetadata {
    /**
     * Labels added to the Kubernetes resource.
     *
     * @schema KafkaSpecKafkaTemplatePersistentVolumeClaimMetadata#labels
     */
    readonly labels?: any;

    /**
     * Annotations added to the Kubernetes resource.
     *
     * @schema KafkaSpecKafkaTemplatePersistentVolumeClaimMetadata#annotations
     */
    readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePersistentVolumeClaimMetadata' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePersistentVolumeClaimMetadata(obj: KafkaSpecKafkaTemplatePersistentVolumeClaimMetadata | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labels': obj.labels,
        'annotations': obj.annotations,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Metadata to apply to the `PodDisruptionBudgetTemplate` resource.
 *
 * @schema KafkaSpecKafkaTemplatePodDisruptionBudgetMetadata
 */
export interface KafkaSpecKafkaTemplatePodDisruptionBudgetMetadata {
    /**
     * Labels added to the Kubernetes resource.
     *
     * @schema KafkaSpecKafkaTemplatePodDisruptionBudgetMetadata#labels
     */
    readonly labels?: any;

    /**
     * Annotations added to the Kubernetes resource.
     *
     * @schema KafkaSpecKafkaTemplatePodDisruptionBudgetMetadata#annotations
     */
    readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodDisruptionBudgetMetadata' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodDisruptionBudgetMetadata(obj: KafkaSpecKafkaTemplatePodDisruptionBudgetMetadata | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labels': obj.labels,
        'annotations': obj.annotations,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplateKafkaContainerEnv
 */
export interface KafkaSpecKafkaTemplateKafkaContainerEnv {
    /**
     * The environment variable key.
     *
     * @schema KafkaSpecKafkaTemplateKafkaContainerEnv#name
     */
    readonly name?: string;

    /**
     * The environment variable value.
     *
     * @schema KafkaSpecKafkaTemplateKafkaContainerEnv#value
     */
    readonly value?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateKafkaContainerEnv' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateKafkaContainerEnv(obj: KafkaSpecKafkaTemplateKafkaContainerEnv | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Security context for the container.
 *
 * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContext
 */
export interface KafkaSpecKafkaTemplateKafkaContainerSecurityContext {
    /**
     * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContext#allowPrivilegeEscalation
     */
    readonly allowPrivilegeEscalation?: boolean;

    /**
     * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContext#capabilities
     */
    readonly capabilities?: KafkaSpecKafkaTemplateKafkaContainerSecurityContextCapabilities;

    /**
     * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContext#privileged
     */
    readonly privileged?: boolean;

    /**
     * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContext#procMount
     */
    readonly procMount?: string;

    /**
     * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContext#readOnlyRootFilesystem
     */
    readonly readOnlyRootFilesystem?: boolean;

    /**
     * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContext#runAsGroup
     */
    readonly runAsGroup?: number;

    /**
     * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContext#runAsNonRoot
     */
    readonly runAsNonRoot?: boolean;

    /**
     * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContext#runAsUser
     */
    readonly runAsUser?: number;

    /**
     * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContext#seLinuxOptions
     */
    readonly seLinuxOptions?: KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeLinuxOptions;

    /**
     * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContext#seccompProfile
     */
    readonly seccompProfile?: KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeccompProfile;

    /**
     * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContext#windowsOptions
     */
    readonly windowsOptions?: KafkaSpecKafkaTemplateKafkaContainerSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateKafkaContainerSecurityContext' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateKafkaContainerSecurityContext(obj: KafkaSpecKafkaTemplateKafkaContainerSecurityContext | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
        'capabilities': toJson_KafkaSpecKafkaTemplateKafkaContainerSecurityContextCapabilities(obj.capabilities),
        'privileged': obj.privileged,
        'procMount': obj.procMount,
        'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
        'runAsGroup': obj.runAsGroup,
        'runAsNonRoot': obj.runAsNonRoot,
        'runAsUser': obj.runAsUser,
        'seLinuxOptions': toJson_KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeLinuxOptions(obj.seLinuxOptions),
        'seccompProfile': toJson_KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeccompProfile(obj.seccompProfile),
        'windowsOptions': toJson_KafkaSpecKafkaTemplateKafkaContainerSecurityContextWindowsOptions(obj.windowsOptions),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplateInitContainerEnv
 */
export interface KafkaSpecKafkaTemplateInitContainerEnv {
    /**
     * The environment variable key.
     *
     * @schema KafkaSpecKafkaTemplateInitContainerEnv#name
     */
    readonly name?: string;

    /**
     * The environment variable value.
     *
     * @schema KafkaSpecKafkaTemplateInitContainerEnv#value
     */
    readonly value?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateInitContainerEnv' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateInitContainerEnv(obj: KafkaSpecKafkaTemplateInitContainerEnv | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Security context for the container.
 *
 * @schema KafkaSpecKafkaTemplateInitContainerSecurityContext
 */
export interface KafkaSpecKafkaTemplateInitContainerSecurityContext {
    /**
     * @schema KafkaSpecKafkaTemplateInitContainerSecurityContext#allowPrivilegeEscalation
     */
    readonly allowPrivilegeEscalation?: boolean;

    /**
     * @schema KafkaSpecKafkaTemplateInitContainerSecurityContext#capabilities
     */
    readonly capabilities?: KafkaSpecKafkaTemplateInitContainerSecurityContextCapabilities;

    /**
     * @schema KafkaSpecKafkaTemplateInitContainerSecurityContext#privileged
     */
    readonly privileged?: boolean;

    /**
     * @schema KafkaSpecKafkaTemplateInitContainerSecurityContext#procMount
     */
    readonly procMount?: string;

    /**
     * @schema KafkaSpecKafkaTemplateInitContainerSecurityContext#readOnlyRootFilesystem
     */
    readonly readOnlyRootFilesystem?: boolean;

    /**
     * @schema KafkaSpecKafkaTemplateInitContainerSecurityContext#runAsGroup
     */
    readonly runAsGroup?: number;

    /**
     * @schema KafkaSpecKafkaTemplateInitContainerSecurityContext#runAsNonRoot
     */
    readonly runAsNonRoot?: boolean;

    /**
     * @schema KafkaSpecKafkaTemplateInitContainerSecurityContext#runAsUser
     */
    readonly runAsUser?: number;

    /**
     * @schema KafkaSpecKafkaTemplateInitContainerSecurityContext#seLinuxOptions
     */
    readonly seLinuxOptions?: KafkaSpecKafkaTemplateInitContainerSecurityContextSeLinuxOptions;

    /**
     * @schema KafkaSpecKafkaTemplateInitContainerSecurityContext#seccompProfile
     */
    readonly seccompProfile?: KafkaSpecKafkaTemplateInitContainerSecurityContextSeccompProfile;

    /**
     * @schema KafkaSpecKafkaTemplateInitContainerSecurityContext#windowsOptions
     */
    readonly windowsOptions?: KafkaSpecKafkaTemplateInitContainerSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateInitContainerSecurityContext' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateInitContainerSecurityContext(obj: KafkaSpecKafkaTemplateInitContainerSecurityContext | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
        'capabilities': toJson_KafkaSpecKafkaTemplateInitContainerSecurityContextCapabilities(obj.capabilities),
        'privileged': obj.privileged,
        'procMount': obj.procMount,
        'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
        'runAsGroup': obj.runAsGroup,
        'runAsNonRoot': obj.runAsNonRoot,
        'runAsUser': obj.runAsUser,
        'seLinuxOptions': toJson_KafkaSpecKafkaTemplateInitContainerSecurityContextSeLinuxOptions(obj.seLinuxOptions),
        'seccompProfile': toJson_KafkaSpecKafkaTemplateInitContainerSecurityContextSeccompProfile(obj.seccompProfile),
        'windowsOptions': toJson_KafkaSpecKafkaTemplateInitContainerSecurityContextWindowsOptions(obj.windowsOptions),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaTemplateClusterCaCertMetadata
 */
export interface KafkaSpecKafkaTemplateClusterCaCertMetadata {
    /**
     * Labels added to the Kubernetes resource.
     *
     * @schema KafkaSpecKafkaTemplateClusterCaCertMetadata#labels
     */
    readonly labels?: any;

    /**
     * Annotations added to the Kubernetes resource.
     *
     * @schema KafkaSpecKafkaTemplateClusterCaCertMetadata#annotations
     */
    readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateClusterCaCertMetadata' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateClusterCaCertMetadata(obj: KafkaSpecKafkaTemplateClusterCaCertMetadata | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labels': obj.labels,
        'annotations': obj.annotations,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaTemplateServiceAccountMetadata
 */
export interface KafkaSpecKafkaTemplateServiceAccountMetadata {
    /**
     * Labels added to the Kubernetes resource.
     *
     * @schema KafkaSpecKafkaTemplateServiceAccountMetadata#labels
     */
    readonly labels?: any;

    /**
     * Annotations added to the Kubernetes resource.
     *
     * @schema KafkaSpecKafkaTemplateServiceAccountMetadata#annotations
     */
    readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateServiceAccountMetadata' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateServiceAccountMetadata(obj: KafkaSpecKafkaTemplateServiceAccountMetadata | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labels': obj.labels,
        'annotations': obj.annotations,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaTemplateJmxSecretMetadata
 */
export interface KafkaSpecKafkaTemplateJmxSecretMetadata {
    /**
     * Labels added to the Kubernetes resource.
     *
     * @schema KafkaSpecKafkaTemplateJmxSecretMetadata#labels
     */
    readonly labels?: any;

    /**
     * Annotations added to the Kubernetes resource.
     *
     * @schema KafkaSpecKafkaTemplateJmxSecretMetadata#annotations
     */
    readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateJmxSecretMetadata' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateJmxSecretMetadata(obj: KafkaSpecKafkaTemplateJmxSecretMetadata | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labels': obj.labels,
        'annotations': obj.annotations,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaTemplateClusterRoleBindingMetadata
 */
export interface KafkaSpecKafkaTemplateClusterRoleBindingMetadata {
    /**
     * Labels added to the Kubernetes resource.
     *
     * @schema KafkaSpecKafkaTemplateClusterRoleBindingMetadata#labels
     */
    readonly labels?: any;

    /**
     * Annotations added to the Kubernetes resource.
     *
     * @schema KafkaSpecKafkaTemplateClusterRoleBindingMetadata#annotations
     */
    readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateClusterRoleBindingMetadata' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateClusterRoleBindingMetadata(obj: KafkaSpecKafkaTemplateClusterRoleBindingMetadata | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labels': obj.labels,
        'annotations': obj.annotations,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaTemplatePodSetMetadata
 */
export interface KafkaSpecKafkaTemplatePodSetMetadata {
    /**
     * Labels added to the Kubernetes resource.
     *
     * @schema KafkaSpecKafkaTemplatePodSetMetadata#labels
     */
    readonly labels?: any;

    /**
     * Annotations added to the Kubernetes resource.
     *
     * @schema KafkaSpecKafkaTemplatePodSetMetadata#annotations
     */
    readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodSetMetadata' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodSetMetadata(obj: KafkaSpecKafkaTemplatePodSetMetadata | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labels': obj.labels,
        'annotations': obj.annotations,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Authentication type. Currently the only supported types are `password`.`password` type creates a username and protected port with no TLS.
 *
 * @schema KafkaSpecZookeeperJmxOptionsAuthenticationType
 */
export enum KafkaSpecZookeeperJmxOptionsAuthenticationType {
    /** password */
    PASSWORD = "password",
}

/**
 * Reference to the key in the ConfigMap containing the configuration.
 *
 * @schema KafkaSpecZookeeperMetricsConfigValueFromConfigMapKeyRef
 */
export interface KafkaSpecZookeeperMetricsConfigValueFromConfigMapKeyRef {
    /**
     * @schema KafkaSpecZookeeperMetricsConfigValueFromConfigMapKeyRef#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecZookeeperMetricsConfigValueFromConfigMapKeyRef#name
     */
    readonly name?: string;

    /**
     * @schema KafkaSpecZookeeperMetricsConfigValueFromConfigMapKeyRef#optional
     */
    readonly optional?: boolean;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperMetricsConfigValueFromConfigMapKeyRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperMetricsConfigValueFromConfigMapKeyRef(obj: KafkaSpecZookeeperMetricsConfigValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'name': obj.name,
        'optional': obj.optional,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Reference to the key in the ConfigMap containing the configuration.
 *
 * @schema KafkaSpecZookeeperLoggingValueFromConfigMapKeyRef
 */
export interface KafkaSpecZookeeperLoggingValueFromConfigMapKeyRef {
    /**
     * @schema KafkaSpecZookeeperLoggingValueFromConfigMapKeyRef#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecZookeeperLoggingValueFromConfigMapKeyRef#name
     */
    readonly name?: string;

    /**
     * @schema KafkaSpecZookeeperLoggingValueFromConfigMapKeyRef#optional
     */
    readonly optional?: boolean;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperLoggingValueFromConfigMapKeyRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperLoggingValueFromConfigMapKeyRef(obj: KafkaSpecZookeeperLoggingValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'name': obj.name,
        'optional': obj.optional,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecZookeeperTemplateStatefulsetMetadata
 */
export interface KafkaSpecZookeeperTemplateStatefulsetMetadata {
    /**
     * Labels added to the Kubernetes resource.
     *
     * @schema KafkaSpecZookeeperTemplateStatefulsetMetadata#labels
     */
    readonly labels?: any;

    /**
     * Annotations added to the Kubernetes resource.
     *
     * @schema KafkaSpecZookeeperTemplateStatefulsetMetadata#annotations
     */
    readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplateStatefulsetMetadata' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplateStatefulsetMetadata(obj: KafkaSpecZookeeperTemplateStatefulsetMetadata | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labels': obj.labels,
        'annotations': obj.annotations,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * PodManagementPolicy which will be used for this StatefulSet. Valid values are `Parallel` and `OrderedReady`. Defaults to `Parallel`.
 *
 * @default Parallel`.
 * @schema KafkaSpecZookeeperTemplateStatefulsetPodManagementPolicy
 */
export enum KafkaSpecZookeeperTemplateStatefulsetPodManagementPolicy {
    /** OrderedReady */
    ORDERED_READY = "OrderedReady",
    /** Parallel */
    PARALLEL = "Parallel",
}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecZookeeperTemplatePodMetadata
 */
export interface KafkaSpecZookeeperTemplatePodMetadata {
    /**
     * Labels added to the Kubernetes resource.
     *
     * @schema KafkaSpecZookeeperTemplatePodMetadata#labels
     */
    readonly labels?: any;

    /**
     * Annotations added to the Kubernetes resource.
     *
     * @schema KafkaSpecZookeeperTemplatePodMetadata#annotations
     */
    readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodMetadata' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodMetadata(obj: KafkaSpecZookeeperTemplatePodMetadata | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labels': obj.labels,
        'annotations': obj.annotations,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodImagePullSecrets
 */
export interface KafkaSpecZookeeperTemplatePodImagePullSecrets {
    /**
     * @schema KafkaSpecZookeeperTemplatePodImagePullSecrets#name
     */
    readonly name?: string;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodImagePullSecrets' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodImagePullSecrets(obj: KafkaSpecZookeeperTemplatePodImagePullSecrets | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Configures pod-level security attributes and common container settings.
 *
 * @schema KafkaSpecZookeeperTemplatePodSecurityContext
 */
export interface KafkaSpecZookeeperTemplatePodSecurityContext {
    /**
     * @schema KafkaSpecZookeeperTemplatePodSecurityContext#fsGroup
     */
    readonly fsGroup?: number;

    /**
     * @schema KafkaSpecZookeeperTemplatePodSecurityContext#fsGroupChangePolicy
     */
    readonly fsGroupChangePolicy?: string;

    /**
     * @schema KafkaSpecZookeeperTemplatePodSecurityContext#runAsGroup
     */
    readonly runAsGroup?: number;

    /**
     * @schema KafkaSpecZookeeperTemplatePodSecurityContext#runAsNonRoot
     */
    readonly runAsNonRoot?: boolean;

    /**
     * @schema KafkaSpecZookeeperTemplatePodSecurityContext#runAsUser
     */
    readonly runAsUser?: number;

    /**
     * @schema KafkaSpecZookeeperTemplatePodSecurityContext#seLinuxOptions
     */
    readonly seLinuxOptions?: KafkaSpecZookeeperTemplatePodSecurityContextSeLinuxOptions;

    /**
     * @schema KafkaSpecZookeeperTemplatePodSecurityContext#seccompProfile
     */
    readonly seccompProfile?: KafkaSpecZookeeperTemplatePodSecurityContextSeccompProfile;

    /**
     * @schema KafkaSpecZookeeperTemplatePodSecurityContext#supplementalGroups
     */
    readonly supplementalGroups?: number[];

    /**
     * @schema KafkaSpecZookeeperTemplatePodSecurityContext#sysctls
     */
    readonly sysctls?: KafkaSpecZookeeperTemplatePodSecurityContextSysctls[];

    /**
     * @schema KafkaSpecZookeeperTemplatePodSecurityContext#windowsOptions
     */
    readonly windowsOptions?: KafkaSpecZookeeperTemplatePodSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodSecurityContext' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodSecurityContext(obj: KafkaSpecZookeeperTemplatePodSecurityContext | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'fsGroup': obj.fsGroup,
        'fsGroupChangePolicy': obj.fsGroupChangePolicy,
        'runAsGroup': obj.runAsGroup,
        'runAsNonRoot': obj.runAsNonRoot,
        'runAsUser': obj.runAsUser,
        'seLinuxOptions': toJson_KafkaSpecZookeeperTemplatePodSecurityContextSeLinuxOptions(obj.seLinuxOptions),
        'seccompProfile': toJson_KafkaSpecZookeeperTemplatePodSecurityContextSeccompProfile(obj.seccompProfile),
        'supplementalGroups': obj.supplementalGroups?.map(y => y),
        'sysctls': obj.sysctls?.map(y => toJson_KafkaSpecZookeeperTemplatePodSecurityContextSysctls(y)),
        'windowsOptions': toJson_KafkaSpecZookeeperTemplatePodSecurityContextWindowsOptions(obj.windowsOptions),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * The pod's affinity rules.
 *
 * @schema KafkaSpecZookeeperTemplatePodAffinity
 */
export interface KafkaSpecZookeeperTemplatePodAffinity {
    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinity#nodeAffinity
     */
    readonly nodeAffinity?: KafkaSpecZookeeperTemplatePodAffinityNodeAffinity;

    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinity#podAffinity
     */
    readonly podAffinity?: KafkaSpecZookeeperTemplatePodAffinityPodAffinity;

    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinity#podAntiAffinity
     */
    readonly podAntiAffinity?: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinity;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinity' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinity(obj: KafkaSpecZookeeperTemplatePodAffinity | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'nodeAffinity': toJson_KafkaSpecZookeeperTemplatePodAffinityNodeAffinity(obj.nodeAffinity),
        'podAffinity': toJson_KafkaSpecZookeeperTemplatePodAffinityPodAffinity(obj.podAffinity),
        'podAntiAffinity': toJson_KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinity(obj.podAntiAffinity),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodTolerations
 */
export interface KafkaSpecZookeeperTemplatePodTolerations {
    /**
     * @schema KafkaSpecZookeeperTemplatePodTolerations#effect
     */
    readonly effect?: string;

    /**
     * @schema KafkaSpecZookeeperTemplatePodTolerations#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecZookeeperTemplatePodTolerations#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecZookeeperTemplatePodTolerations#tolerationSeconds
     */
    readonly tolerationSeconds?: number;

    /**
     * @schema KafkaSpecZookeeperTemplatePodTolerations#value
     */
    readonly value?: string;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodTolerations' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodTolerations(obj: KafkaSpecZookeeperTemplatePodTolerations | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'effect': obj.effect,
        'key': obj.key,
        'operator': obj.operator,
        'tolerationSeconds': obj.tolerationSeconds,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodHostAliases
 */
export interface KafkaSpecZookeeperTemplatePodHostAliases {
    /**
     * @schema KafkaSpecZookeeperTemplatePodHostAliases#hostnames
     */
    readonly hostnames?: string[];

    /**
     * @schema KafkaSpecZookeeperTemplatePodHostAliases#ip
     */
    readonly ip?: string;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodHostAliases' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodHostAliases(obj: KafkaSpecZookeeperTemplatePodHostAliases | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'hostnames': obj.hostnames?.map(y => y),
        'ip': obj.ip,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodTopologySpreadConstraints
 */
export interface KafkaSpecZookeeperTemplatePodTopologySpreadConstraints {
    /**
     * @schema KafkaSpecZookeeperTemplatePodTopologySpreadConstraints#labelSelector
     */
    readonly labelSelector?: KafkaSpecZookeeperTemplatePodTopologySpreadConstraintsLabelSelector;

    /**
     * @schema KafkaSpecZookeeperTemplatePodTopologySpreadConstraints#matchLabelKeys
     */
    readonly matchLabelKeys?: string[];

    /**
     * @schema KafkaSpecZookeeperTemplatePodTopologySpreadConstraints#maxSkew
     */
    readonly maxSkew?: number;

    /**
     * @schema KafkaSpecZookeeperTemplatePodTopologySpreadConstraints#minDomains
     */
    readonly minDomains?: number;

    /**
     * @schema KafkaSpecZookeeperTemplatePodTopologySpreadConstraints#nodeAffinityPolicy
     */
    readonly nodeAffinityPolicy?: string;

    /**
     * @schema KafkaSpecZookeeperTemplatePodTopologySpreadConstraints#nodeTaintsPolicy
     */
    readonly nodeTaintsPolicy?: string;

    /**
     * @schema KafkaSpecZookeeperTemplatePodTopologySpreadConstraints#topologyKey
     */
    readonly topologyKey?: string;

    /**
     * @schema KafkaSpecZookeeperTemplatePodTopologySpreadConstraints#whenUnsatisfiable
     */
    readonly whenUnsatisfiable?: string;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodTopologySpreadConstraints' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodTopologySpreadConstraints(obj: KafkaSpecZookeeperTemplatePodTopologySpreadConstraints | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labelSelector': toJson_KafkaSpecZookeeperTemplatePodTopologySpreadConstraintsLabelSelector(obj.labelSelector),
        'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
        'maxSkew': obj.maxSkew,
        'minDomains': obj.minDomains,
        'nodeAffinityPolicy': obj.nodeAffinityPolicy,
        'nodeTaintsPolicy': obj.nodeTaintsPolicy,
        'topologyKey': obj.topologyKey,
        'whenUnsatisfiable': obj.whenUnsatisfiable,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecZookeeperTemplateClientServiceMetadata
 */
export interface KafkaSpecZookeeperTemplateClientServiceMetadata {
    /**
     * Labels added to the Kubernetes resource.
     *
     * @schema KafkaSpecZookeeperTemplateClientServiceMetadata#labels
     */
    readonly labels?: any;

    /**
     * Annotations added to the Kubernetes resource.
     *
     * @schema KafkaSpecZookeeperTemplateClientServiceMetadata#annotations
     */
    readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplateClientServiceMetadata' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplateClientServiceMetadata(obj: KafkaSpecZookeeperTemplateClientServiceMetadata | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labels': obj.labels,
        'annotations': obj.annotations,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Specifies the IP Family Policy used by the service. Available options are `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a single IP family. `PreferDualStack` is for two IP families on dual-stack configured clusters or a single IP family on single-stack clusters. `RequireDualStack` fails unless there are two IP families on dual-stack configured clusters. If unspecified, Kubernetes will choose the default value based on the service type. Available on Kubernetes 1.20 and newer.
 *
 * @schema KafkaSpecZookeeperTemplateClientServiceIpFamilyPolicy
 */
export enum KafkaSpecZookeeperTemplateClientServiceIpFamilyPolicy {
    /** SingleStack */
    SINGLE_STACK = "SingleStack",
    /** PreferDualStack */
    PREFER_DUAL_STACK = "PreferDualStack",
    /** RequireDualStack */
    REQUIRE_DUAL_STACK = "RequireDualStack",
}

/**
 * @schema KafkaSpecZookeeperTemplateClientServiceIpFamilies
 */
export enum KafkaSpecZookeeperTemplateClientServiceIpFamilies {
    /** IPv4 */
    I_PV4 = "IPv4",
    /** IPv6 */
    I_PV6 = "IPv6",
}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecZookeeperTemplateNodesServiceMetadata
 */
export interface KafkaSpecZookeeperTemplateNodesServiceMetadata {
    /**
     * Labels added to the Kubernetes resource.
     *
     * @schema KafkaSpecZookeeperTemplateNodesServiceMetadata#labels
     */
    readonly labels?: any;

    /**
     * Annotations added to the Kubernetes resource.
     *
     * @schema KafkaSpecZookeeperTemplateNodesServiceMetadata#annotations
     */
    readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplateNodesServiceMetadata' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplateNodesServiceMetadata(obj: KafkaSpecZookeeperTemplateNodesServiceMetadata | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labels': obj.labels,
        'annotations': obj.annotations,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Specifies the IP Family Policy used by the service. Available options are `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a single IP family. `PreferDualStack` is for two IP families on dual-stack configured clusters or a single IP family on single-stack clusters. `RequireDualStack` fails unless there are two IP families on dual-stack configured clusters. If unspecified, Kubernetes will choose the default value based on the service type. Available on Kubernetes 1.20 and newer.
 *
 * @schema KafkaSpecZookeeperTemplateNodesServiceIpFamilyPolicy
 */
export enum KafkaSpecZookeeperTemplateNodesServiceIpFamilyPolicy {
    /** SingleStack */
    SINGLE_STACK = "SingleStack",
    /** PreferDualStack */
    PREFER_DUAL_STACK = "PreferDualStack",
    /** RequireDualStack */
    REQUIRE_DUAL_STACK = "RequireDualStack",
}

/**
 * @schema KafkaSpecZookeeperTemplateNodesServiceIpFamilies
 */
export enum KafkaSpecZookeeperTemplateNodesServiceIpFamilies {
    /** IPv4 */
    I_PV4 = "IPv4",
    /** IPv6 */
    I_PV6 = "IPv6",
}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecZookeeperTemplatePersistentVolumeClaimMetadata
 */
export interface KafkaSpecZookeeperTemplatePersistentVolumeClaimMetadata {
    /**
     * Labels added to the Kubernetes resource.
     *
     * @schema KafkaSpecZookeeperTemplatePersistentVolumeClaimMetadata#labels
     */
    readonly labels?: any;

    /**
     * Annotations added to the Kubernetes resource.
     *
     * @schema KafkaSpecZookeeperTemplatePersistentVolumeClaimMetadata#annotations
     */
    readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePersistentVolumeClaimMetadata' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePersistentVolumeClaimMetadata(obj: KafkaSpecZookeeperTemplatePersistentVolumeClaimMetadata | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labels': obj.labels,
        'annotations': obj.annotations,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Metadata to apply to the `PodDisruptionBudgetTemplate` resource.
 *
 * @schema KafkaSpecZookeeperTemplatePodDisruptionBudgetMetadata
 */
export interface KafkaSpecZookeeperTemplatePodDisruptionBudgetMetadata {
    /**
     * Labels added to the Kubernetes resource.
     *
     * @schema KafkaSpecZookeeperTemplatePodDisruptionBudgetMetadata#labels
     */
    readonly labels?: any;

    /**
     * Annotations added to the Kubernetes resource.
     *
     * @schema KafkaSpecZookeeperTemplatePodDisruptionBudgetMetadata#annotations
     */
    readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodDisruptionBudgetMetadata' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodDisruptionBudgetMetadata(obj: KafkaSpecZookeeperTemplatePodDisruptionBudgetMetadata | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labels': obj.labels,
        'annotations': obj.annotations,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplateZookeeperContainerEnv
 */
export interface KafkaSpecZookeeperTemplateZookeeperContainerEnv {
    /**
     * The environment variable key.
     *
     * @schema KafkaSpecZookeeperTemplateZookeeperContainerEnv#name
     */
    readonly name?: string;

    /**
     * The environment variable value.
     *
     * @schema KafkaSpecZookeeperTemplateZookeeperContainerEnv#value
     */
    readonly value?: string;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplateZookeeperContainerEnv' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplateZookeeperContainerEnv(obj: KafkaSpecZookeeperTemplateZookeeperContainerEnv | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Security context for the container.
 *
 * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext
 */
export interface KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext {
    /**
     * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext#allowPrivilegeEscalation
     */
    readonly allowPrivilegeEscalation?: boolean;

    /**
     * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext#capabilities
     */
    readonly capabilities?: KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextCapabilities;

    /**
     * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext#privileged
     */
    readonly privileged?: boolean;

    /**
     * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext#procMount
     */
    readonly procMount?: string;

    /**
     * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext#readOnlyRootFilesystem
     */
    readonly readOnlyRootFilesystem?: boolean;

    /**
     * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext#runAsGroup
     */
    readonly runAsGroup?: number;

    /**
     * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext#runAsNonRoot
     */
    readonly runAsNonRoot?: boolean;

    /**
     * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext#runAsUser
     */
    readonly runAsUser?: number;

    /**
     * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext#seLinuxOptions
     */
    readonly seLinuxOptions?: KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeLinuxOptions;

    /**
     * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext#seccompProfile
     */
    readonly seccompProfile?: KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeccompProfile;

    /**
     * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext#windowsOptions
     */
    readonly windowsOptions?: KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext(obj: KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
        'capabilities': toJson_KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextCapabilities(obj.capabilities),
        'privileged': obj.privileged,
        'procMount': obj.procMount,
        'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
        'runAsGroup': obj.runAsGroup,
        'runAsNonRoot': obj.runAsNonRoot,
        'runAsUser': obj.runAsUser,
        'seLinuxOptions': toJson_KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeLinuxOptions(obj.seLinuxOptions),
        'seccompProfile': toJson_KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeccompProfile(obj.seccompProfile),
        'windowsOptions': toJson_KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextWindowsOptions(obj.windowsOptions),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecZookeeperTemplateServiceAccountMetadata
 */
export interface KafkaSpecZookeeperTemplateServiceAccountMetadata {
    /**
     * Labels added to the Kubernetes resource.
     *
     * @schema KafkaSpecZookeeperTemplateServiceAccountMetadata#labels
     */
    readonly labels?: any;

    /**
     * Annotations added to the Kubernetes resource.
     *
     * @schema KafkaSpecZookeeperTemplateServiceAccountMetadata#annotations
     */
    readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplateServiceAccountMetadata' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplateServiceAccountMetadata(obj: KafkaSpecZookeeperTemplateServiceAccountMetadata | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labels': obj.labels,
        'annotations': obj.annotations,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecZookeeperTemplateJmxSecretMetadata
 */
export interface KafkaSpecZookeeperTemplateJmxSecretMetadata {
    /**
     * Labels added to the Kubernetes resource.
     *
     * @schema KafkaSpecZookeeperTemplateJmxSecretMetadata#labels
     */
    readonly labels?: any;

    /**
     * Annotations added to the Kubernetes resource.
     *
     * @schema KafkaSpecZookeeperTemplateJmxSecretMetadata#annotations
     */
    readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplateJmxSecretMetadata' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplateJmxSecretMetadata(obj: KafkaSpecZookeeperTemplateJmxSecretMetadata | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labels': obj.labels,
        'annotations': obj.annotations,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecZookeeperTemplatePodSetMetadata
 */
export interface KafkaSpecZookeeperTemplatePodSetMetadata {
    /**
     * Labels added to the Kubernetes resource.
     *
     * @schema KafkaSpecZookeeperTemplatePodSetMetadata#labels
     */
    readonly labels?: any;

    /**
     * Annotations added to the Kubernetes resource.
     *
     * @schema KafkaSpecZookeeperTemplatePodSetMetadata#annotations
     */
    readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodSetMetadata' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodSetMetadata(obj: KafkaSpecZookeeperTemplatePodSetMetadata | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labels': obj.labels,
        'annotations': obj.annotations,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTopicOperatorResourcesClaims
 */
export interface KafkaSpecEntityOperatorTopicOperatorResourcesClaims {
    /**
     * @schema KafkaSpecEntityOperatorTopicOperatorResourcesClaims#name
     */
    readonly name?: string;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTopicOperatorResourcesClaims' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTopicOperatorResourcesClaims(obj: KafkaSpecEntityOperatorTopicOperatorResourcesClaims | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Logging type, must be either 'inline' or 'external'.
 *
 * @schema KafkaSpecEntityOperatorTopicOperatorLoggingType
 */
export enum KafkaSpecEntityOperatorTopicOperatorLoggingType {
    /** inline */
    INLINE = "inline",
    /** external */
    EXTERNAL = "external",
}

/**
 * `ConfigMap` entry where the logging configuration is stored.
 *
 * @schema KafkaSpecEntityOperatorTopicOperatorLoggingValueFrom
 */
export interface KafkaSpecEntityOperatorTopicOperatorLoggingValueFrom {
    /**
     * Reference to the key in the ConfigMap containing the configuration.
     *
     * @schema KafkaSpecEntityOperatorTopicOperatorLoggingValueFrom#configMapKeyRef
     */
    readonly configMapKeyRef?: KafkaSpecEntityOperatorTopicOperatorLoggingValueFromConfigMapKeyRef;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTopicOperatorLoggingValueFrom' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTopicOperatorLoggingValueFrom(obj: KafkaSpecEntityOperatorTopicOperatorLoggingValueFrom | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'configMapKeyRef': toJson_KafkaSpecEntityOperatorTopicOperatorLoggingValueFromConfigMapKeyRef(obj.configMapKeyRef),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTopicOperatorJvmOptionsJavaSystemProperties
 */
export interface KafkaSpecEntityOperatorTopicOperatorJvmOptionsJavaSystemProperties {
    /**
     * The system property name.
     *
     * @schema KafkaSpecEntityOperatorTopicOperatorJvmOptionsJavaSystemProperties#name
     */
    readonly name?: string;

    /**
     * The system property value.
     *
     * @schema KafkaSpecEntityOperatorTopicOperatorJvmOptionsJavaSystemProperties#value
     */
    readonly value?: string;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTopicOperatorJvmOptionsJavaSystemProperties' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTopicOperatorJvmOptionsJavaSystemProperties(obj: KafkaSpecEntityOperatorTopicOperatorJvmOptionsJavaSystemProperties | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorUserOperatorResourcesClaims
 */
export interface KafkaSpecEntityOperatorUserOperatorResourcesClaims {
    /**
     * @schema KafkaSpecEntityOperatorUserOperatorResourcesClaims#name
     */
    readonly name?: string;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorUserOperatorResourcesClaims' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorUserOperatorResourcesClaims(obj: KafkaSpecEntityOperatorUserOperatorResourcesClaims | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Logging type, must be either 'inline' or 'external'.
 *
 * @schema KafkaSpecEntityOperatorUserOperatorLoggingType
 */
export enum KafkaSpecEntityOperatorUserOperatorLoggingType {
    /** inline */
    INLINE = "inline",
    /** external */
    EXTERNAL = "external",
}

/**
 * `ConfigMap` entry where the logging configuration is stored.
 *
 * @schema KafkaSpecEntityOperatorUserOperatorLoggingValueFrom
 */
export interface KafkaSpecEntityOperatorUserOperatorLoggingValueFrom {
    /**
     * Reference to the key in the ConfigMap containing the configuration.
     *
     * @schema KafkaSpecEntityOperatorUserOperatorLoggingValueFrom#configMapKeyRef
     */
    readonly configMapKeyRef?: KafkaSpecEntityOperatorUserOperatorLoggingValueFromConfigMapKeyRef;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorUserOperatorLoggingValueFrom' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorUserOperatorLoggingValueFrom(obj: KafkaSpecEntityOperatorUserOperatorLoggingValueFrom | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'configMapKeyRef': toJson_KafkaSpecEntityOperatorUserOperatorLoggingValueFromConfigMapKeyRef(obj.configMapKeyRef),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorUserOperatorJvmOptionsJavaSystemProperties
 */
export interface KafkaSpecEntityOperatorUserOperatorJvmOptionsJavaSystemProperties {
    /**
     * The system property name.
     *
     * @schema KafkaSpecEntityOperatorUserOperatorJvmOptionsJavaSystemProperties#name
     */
    readonly name?: string;

    /**
     * The system property value.
     *
     * @schema KafkaSpecEntityOperatorUserOperatorJvmOptionsJavaSystemProperties#value
     */
    readonly value?: string;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorUserOperatorJvmOptionsJavaSystemProperties' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorUserOperatorJvmOptionsJavaSystemProperties(obj: KafkaSpecEntityOperatorUserOperatorJvmOptionsJavaSystemProperties | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTlsSidecarResourcesClaims
 */
export interface KafkaSpecEntityOperatorTlsSidecarResourcesClaims {
    /**
     * @schema KafkaSpecEntityOperatorTlsSidecarResourcesClaims#name
     */
    readonly name?: string;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTlsSidecarResourcesClaims' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTlsSidecarResourcesClaims(obj: KafkaSpecEntityOperatorTlsSidecarResourcesClaims | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecEntityOperatorTemplateDeploymentMetadata
 */
export interface KafkaSpecEntityOperatorTemplateDeploymentMetadata {
    /**
     * Labels added to the Kubernetes resource.
     *
     * @schema KafkaSpecEntityOperatorTemplateDeploymentMetadata#labels
     */
    readonly labels?: any;

    /**
     * Annotations added to the Kubernetes resource.
     *
     * @schema KafkaSpecEntityOperatorTemplateDeploymentMetadata#annotations
     */
    readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplateDeploymentMetadata' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplateDeploymentMetadata(obj: KafkaSpecEntityOperatorTemplateDeploymentMetadata | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labels': obj.labels,
        'annotations': obj.annotations,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Pod replacement strategy for deployment configuration changes. Valid values are `RollingUpdate` and `Recreate`. Defaults to `RollingUpdate`.
 *
 * @default RollingUpdate`.
 * @schema KafkaSpecEntityOperatorTemplateDeploymentDeploymentStrategy
 */
export enum KafkaSpecEntityOperatorTemplateDeploymentDeploymentStrategy {
    /** RollingUpdate */
    ROLLING_UPDATE = "RollingUpdate",
    /** Recreate */
    RECREATE = "Recreate",
}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecEntityOperatorTemplatePodMetadata
 */
export interface KafkaSpecEntityOperatorTemplatePodMetadata {
    /**
     * Labels added to the Kubernetes resource.
     *
     * @schema KafkaSpecEntityOperatorTemplatePodMetadata#labels
     */
    readonly labels?: any;

    /**
     * Annotations added to the Kubernetes resource.
     *
     * @schema KafkaSpecEntityOperatorTemplatePodMetadata#annotations
     */
    readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodMetadata' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodMetadata(obj: KafkaSpecEntityOperatorTemplatePodMetadata | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labels': obj.labels,
        'annotations': obj.annotations,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodImagePullSecrets
 */
export interface KafkaSpecEntityOperatorTemplatePodImagePullSecrets {
    /**
     * @schema KafkaSpecEntityOperatorTemplatePodImagePullSecrets#name
     */
    readonly name?: string;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodImagePullSecrets' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodImagePullSecrets(obj: KafkaSpecEntityOperatorTemplatePodImagePullSecrets | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Configures pod-level security attributes and common container settings.
 *
 * @schema KafkaSpecEntityOperatorTemplatePodSecurityContext
 */
export interface KafkaSpecEntityOperatorTemplatePodSecurityContext {
    /**
     * @schema KafkaSpecEntityOperatorTemplatePodSecurityContext#fsGroup
     */
    readonly fsGroup?: number;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodSecurityContext#fsGroupChangePolicy
     */
    readonly fsGroupChangePolicy?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodSecurityContext#runAsGroup
     */
    readonly runAsGroup?: number;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodSecurityContext#runAsNonRoot
     */
    readonly runAsNonRoot?: boolean;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodSecurityContext#runAsUser
     */
    readonly runAsUser?: number;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodSecurityContext#seLinuxOptions
     */
    readonly seLinuxOptions?: KafkaSpecEntityOperatorTemplatePodSecurityContextSeLinuxOptions;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodSecurityContext#seccompProfile
     */
    readonly seccompProfile?: KafkaSpecEntityOperatorTemplatePodSecurityContextSeccompProfile;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodSecurityContext#supplementalGroups
     */
    readonly supplementalGroups?: number[];

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodSecurityContext#sysctls
     */
    readonly sysctls?: KafkaSpecEntityOperatorTemplatePodSecurityContextSysctls[];

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodSecurityContext#windowsOptions
     */
    readonly windowsOptions?: KafkaSpecEntityOperatorTemplatePodSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodSecurityContext' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodSecurityContext(obj: KafkaSpecEntityOperatorTemplatePodSecurityContext | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'fsGroup': obj.fsGroup,
        'fsGroupChangePolicy': obj.fsGroupChangePolicy,
        'runAsGroup': obj.runAsGroup,
        'runAsNonRoot': obj.runAsNonRoot,
        'runAsUser': obj.runAsUser,
        'seLinuxOptions': toJson_KafkaSpecEntityOperatorTemplatePodSecurityContextSeLinuxOptions(obj.seLinuxOptions),
        'seccompProfile': toJson_KafkaSpecEntityOperatorTemplatePodSecurityContextSeccompProfile(obj.seccompProfile),
        'supplementalGroups': obj.supplementalGroups?.map(y => y),
        'sysctls': obj.sysctls?.map(y => toJson_KafkaSpecEntityOperatorTemplatePodSecurityContextSysctls(y)),
        'windowsOptions': toJson_KafkaSpecEntityOperatorTemplatePodSecurityContextWindowsOptions(obj.windowsOptions),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * The pod's affinity rules.
 *
 * @schema KafkaSpecEntityOperatorTemplatePodAffinity
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinity {
    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinity#nodeAffinity
     */
    readonly nodeAffinity?: KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinity;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinity#podAffinity
     */
    readonly podAffinity?: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinity;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinity#podAntiAffinity
     */
    readonly podAntiAffinity?: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinity;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinity' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinity(obj: KafkaSpecEntityOperatorTemplatePodAffinity | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'nodeAffinity': toJson_KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinity(obj.nodeAffinity),
        'podAffinity': toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAffinity(obj.podAffinity),
        'podAntiAffinity': toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinity(obj.podAntiAffinity),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodTolerations
 */
export interface KafkaSpecEntityOperatorTemplatePodTolerations {
    /**
     * @schema KafkaSpecEntityOperatorTemplatePodTolerations#effect
     */
    readonly effect?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodTolerations#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodTolerations#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodTolerations#tolerationSeconds
     */
    readonly tolerationSeconds?: number;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodTolerations#value
     */
    readonly value?: string;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodTolerations' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodTolerations(obj: KafkaSpecEntityOperatorTemplatePodTolerations | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'effect': obj.effect,
        'key': obj.key,
        'operator': obj.operator,
        'tolerationSeconds': obj.tolerationSeconds,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodHostAliases
 */
export interface KafkaSpecEntityOperatorTemplatePodHostAliases {
    /**
     * @schema KafkaSpecEntityOperatorTemplatePodHostAliases#hostnames
     */
    readonly hostnames?: string[];

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodHostAliases#ip
     */
    readonly ip?: string;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodHostAliases' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodHostAliases(obj: KafkaSpecEntityOperatorTemplatePodHostAliases | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'hostnames': obj.hostnames?.map(y => y),
        'ip': obj.ip,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraints
 */
export interface KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraints {
    /**
     * @schema KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraints#labelSelector
     */
    readonly labelSelector?: KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraintsLabelSelector;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraints#matchLabelKeys
     */
    readonly matchLabelKeys?: string[];

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraints#maxSkew
     */
    readonly maxSkew?: number;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraints#minDomains
     */
    readonly minDomains?: number;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraints#nodeAffinityPolicy
     */
    readonly nodeAffinityPolicy?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraints#nodeTaintsPolicy
     */
    readonly nodeTaintsPolicy?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraints#topologyKey
     */
    readonly topologyKey?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraints#whenUnsatisfiable
     */
    readonly whenUnsatisfiable?: string;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraints' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraints(obj: KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraints | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labelSelector': toJson_KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraintsLabelSelector(obj.labelSelector),
        'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
        'maxSkew': obj.maxSkew,
        'minDomains': obj.minDomains,
        'nodeAffinityPolicy': obj.nodeAffinityPolicy,
        'nodeTaintsPolicy': obj.nodeTaintsPolicy,
        'topologyKey': obj.topologyKey,
        'whenUnsatisfiable': obj.whenUnsatisfiable,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerEnv
 */
export interface KafkaSpecEntityOperatorTemplateTopicOperatorContainerEnv {
    /**
     * The environment variable key.
     *
     * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerEnv#name
     */
    readonly name?: string;

    /**
     * The environment variable value.
     *
     * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerEnv#value
     */
    readonly value?: string;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplateTopicOperatorContainerEnv' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplateTopicOperatorContainerEnv(obj: KafkaSpecEntityOperatorTemplateTopicOperatorContainerEnv | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Security context for the container.
 *
 * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext
 */
export interface KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext {
    /**
     * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext#allowPrivilegeEscalation
     */
    readonly allowPrivilegeEscalation?: boolean;

    /**
     * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext#capabilities
     */
    readonly capabilities?: KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextCapabilities;

    /**
     * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext#privileged
     */
    readonly privileged?: boolean;

    /**
     * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext#procMount
     */
    readonly procMount?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext#readOnlyRootFilesystem
     */
    readonly readOnlyRootFilesystem?: boolean;

    /**
     * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext#runAsGroup
     */
    readonly runAsGroup?: number;

    /**
     * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext#runAsNonRoot
     */
    readonly runAsNonRoot?: boolean;

    /**
     * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext#runAsUser
     */
    readonly runAsUser?: number;

    /**
     * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext#seLinuxOptions
     */
    readonly seLinuxOptions?: KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeLinuxOptions;

    /**
     * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext#seccompProfile
     */
    readonly seccompProfile?: KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeccompProfile;

    /**
     * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext#windowsOptions
     */
    readonly windowsOptions?: KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext(obj: KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
        'capabilities': toJson_KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextCapabilities(obj.capabilities),
        'privileged': obj.privileged,
        'procMount': obj.procMount,
        'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
        'runAsGroup': obj.runAsGroup,
        'runAsNonRoot': obj.runAsNonRoot,
        'runAsUser': obj.runAsUser,
        'seLinuxOptions': toJson_KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeLinuxOptions(obj.seLinuxOptions),
        'seccompProfile': toJson_KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeccompProfile(obj.seccompProfile),
        'windowsOptions': toJson_KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextWindowsOptions(obj.windowsOptions),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerEnv
 */
export interface KafkaSpecEntityOperatorTemplateUserOperatorContainerEnv {
    /**
     * The environment variable key.
     *
     * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerEnv#name
     */
    readonly name?: string;

    /**
     * The environment variable value.
     *
     * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerEnv#value
     */
    readonly value?: string;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplateUserOperatorContainerEnv' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplateUserOperatorContainerEnv(obj: KafkaSpecEntityOperatorTemplateUserOperatorContainerEnv | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Security context for the container.
 *
 * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext
 */
export interface KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext {
    /**
     * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext#allowPrivilegeEscalation
     */
    readonly allowPrivilegeEscalation?: boolean;

    /**
     * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext#capabilities
     */
    readonly capabilities?: KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextCapabilities;

    /**
     * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext#privileged
     */
    readonly privileged?: boolean;

    /**
     * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext#procMount
     */
    readonly procMount?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext#readOnlyRootFilesystem
     */
    readonly readOnlyRootFilesystem?: boolean;

    /**
     * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext#runAsGroup
     */
    readonly runAsGroup?: number;

    /**
     * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext#runAsNonRoot
     */
    readonly runAsNonRoot?: boolean;

    /**
     * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext#runAsUser
     */
    readonly runAsUser?: number;

    /**
     * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext#seLinuxOptions
     */
    readonly seLinuxOptions?: KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeLinuxOptions;

    /**
     * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext#seccompProfile
     */
    readonly seccompProfile?: KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeccompProfile;

    /**
     * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext#windowsOptions
     */
    readonly windowsOptions?: KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext(obj: KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
        'capabilities': toJson_KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextCapabilities(obj.capabilities),
        'privileged': obj.privileged,
        'procMount': obj.procMount,
        'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
        'runAsGroup': obj.runAsGroup,
        'runAsNonRoot': obj.runAsNonRoot,
        'runAsUser': obj.runAsUser,
        'seLinuxOptions': toJson_KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeLinuxOptions(obj.seLinuxOptions),
        'seccompProfile': toJson_KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeccompProfile(obj.seccompProfile),
        'windowsOptions': toJson_KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextWindowsOptions(obj.windowsOptions),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerEnv
 */
export interface KafkaSpecEntityOperatorTemplateTlsSidecarContainerEnv {
    /**
     * The environment variable key.
     *
     * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerEnv#name
     */
    readonly name?: string;

    /**
     * The environment variable value.
     *
     * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerEnv#value
     */
    readonly value?: string;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplateTlsSidecarContainerEnv' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplateTlsSidecarContainerEnv(obj: KafkaSpecEntityOperatorTemplateTlsSidecarContainerEnv | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Security context for the container.
 *
 * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext
 */
export interface KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext {
    /**
     * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext#allowPrivilegeEscalation
     */
    readonly allowPrivilegeEscalation?: boolean;

    /**
     * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext#capabilities
     */
    readonly capabilities?: KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextCapabilities;

    /**
     * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext#privileged
     */
    readonly privileged?: boolean;

    /**
     * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext#procMount
     */
    readonly procMount?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext#readOnlyRootFilesystem
     */
    readonly readOnlyRootFilesystem?: boolean;

    /**
     * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext#runAsGroup
     */
    readonly runAsGroup?: number;

    /**
     * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext#runAsNonRoot
     */
    readonly runAsNonRoot?: boolean;

    /**
     * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext#runAsUser
     */
    readonly runAsUser?: number;

    /**
     * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext#seLinuxOptions
     */
    readonly seLinuxOptions?: KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeLinuxOptions;

    /**
     * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext#seccompProfile
     */
    readonly seccompProfile?: KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeccompProfile;

    /**
     * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext#windowsOptions
     */
    readonly windowsOptions?: KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext(obj: KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
        'capabilities': toJson_KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextCapabilities(obj.capabilities),
        'privileged': obj.privileged,
        'procMount': obj.procMount,
        'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
        'runAsGroup': obj.runAsGroup,
        'runAsNonRoot': obj.runAsNonRoot,
        'runAsUser': obj.runAsUser,
        'seLinuxOptions': toJson_KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeLinuxOptions(obj.seLinuxOptions),
        'seccompProfile': toJson_KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeccompProfile(obj.seccompProfile),
        'windowsOptions': toJson_KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextWindowsOptions(obj.windowsOptions),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecEntityOperatorTemplateServiceAccountMetadata
 */
export interface KafkaSpecEntityOperatorTemplateServiceAccountMetadata {
    /**
     * Labels added to the Kubernetes resource.
     *
     * @schema KafkaSpecEntityOperatorTemplateServiceAccountMetadata#labels
     */
    readonly labels?: any;

    /**
     * Annotations added to the Kubernetes resource.
     *
     * @schema KafkaSpecEntityOperatorTemplateServiceAccountMetadata#annotations
     */
    readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplateServiceAccountMetadata' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplateServiceAccountMetadata(obj: KafkaSpecEntityOperatorTemplateServiceAccountMetadata | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labels': obj.labels,
        'annotations': obj.annotations,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecEntityOperatorTemplateEntityOperatorRoleMetadata
 */
export interface KafkaSpecEntityOperatorTemplateEntityOperatorRoleMetadata {
    /**
     * Labels added to the Kubernetes resource.
     *
     * @schema KafkaSpecEntityOperatorTemplateEntityOperatorRoleMetadata#labels
     */
    readonly labels?: any;

    /**
     * Annotations added to the Kubernetes resource.
     *
     * @schema KafkaSpecEntityOperatorTemplateEntityOperatorRoleMetadata#annotations
     */
    readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplateEntityOperatorRoleMetadata' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplateEntityOperatorRoleMetadata(obj: KafkaSpecEntityOperatorTemplateEntityOperatorRoleMetadata | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labels': obj.labels,
        'annotations': obj.annotations,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecEntityOperatorTemplateTopicOperatorRoleBindingMetadata
 */
export interface KafkaSpecEntityOperatorTemplateTopicOperatorRoleBindingMetadata {
    /**
     * Labels added to the Kubernetes resource.
     *
     * @schema KafkaSpecEntityOperatorTemplateTopicOperatorRoleBindingMetadata#labels
     */
    readonly labels?: any;

    /**
     * Annotations added to the Kubernetes resource.
     *
     * @schema KafkaSpecEntityOperatorTemplateTopicOperatorRoleBindingMetadata#annotations
     */
    readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplateTopicOperatorRoleBindingMetadata' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplateTopicOperatorRoleBindingMetadata(obj: KafkaSpecEntityOperatorTemplateTopicOperatorRoleBindingMetadata | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labels': obj.labels,
        'annotations': obj.annotations,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecEntityOperatorTemplateUserOperatorRoleBindingMetadata
 */
export interface KafkaSpecEntityOperatorTemplateUserOperatorRoleBindingMetadata {
    /**
     * Labels added to the Kubernetes resource.
     *
     * @schema KafkaSpecEntityOperatorTemplateUserOperatorRoleBindingMetadata#labels
     */
    readonly labels?: any;

    /**
     * Annotations added to the Kubernetes resource.
     *
     * @schema KafkaSpecEntityOperatorTemplateUserOperatorRoleBindingMetadata#annotations
     */
    readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplateUserOperatorRoleBindingMetadata' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplateUserOperatorRoleBindingMetadata(obj: KafkaSpecEntityOperatorTemplateUserOperatorRoleBindingMetadata | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labels': obj.labels,
        'annotations': obj.annotations,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTlsSidecarResourcesClaims
 */
export interface KafkaSpecCruiseControlTlsSidecarResourcesClaims {
    /**
     * @schema KafkaSpecCruiseControlTlsSidecarResourcesClaims#name
     */
    readonly name?: string;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTlsSidecarResourcesClaims' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTlsSidecarResourcesClaims(obj: KafkaSpecCruiseControlTlsSidecarResourcesClaims | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Reference to the key in the ConfigMap containing the configuration.
 *
 * @schema KafkaSpecCruiseControlLoggingValueFromConfigMapKeyRef
 */
export interface KafkaSpecCruiseControlLoggingValueFromConfigMapKeyRef {
    /**
     * @schema KafkaSpecCruiseControlLoggingValueFromConfigMapKeyRef#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecCruiseControlLoggingValueFromConfigMapKeyRef#name
     */
    readonly name?: string;

    /**
     * @schema KafkaSpecCruiseControlLoggingValueFromConfigMapKeyRef#optional
     */
    readonly optional?: boolean;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlLoggingValueFromConfigMapKeyRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlLoggingValueFromConfigMapKeyRef(obj: KafkaSpecCruiseControlLoggingValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'name': obj.name,
        'optional': obj.optional,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecCruiseControlTemplateDeploymentMetadata
 */
export interface KafkaSpecCruiseControlTemplateDeploymentMetadata {
    /**
     * Labels added to the Kubernetes resource.
     *
     * @schema KafkaSpecCruiseControlTemplateDeploymentMetadata#labels
     */
    readonly labels?: any;

    /**
     * Annotations added to the Kubernetes resource.
     *
     * @schema KafkaSpecCruiseControlTemplateDeploymentMetadata#annotations
     */
    readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplateDeploymentMetadata' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplateDeploymentMetadata(obj: KafkaSpecCruiseControlTemplateDeploymentMetadata | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labels': obj.labels,
        'annotations': obj.annotations,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Pod replacement strategy for deployment configuration changes. Valid values are `RollingUpdate` and `Recreate`. Defaults to `RollingUpdate`.
 *
 * @default RollingUpdate`.
 * @schema KafkaSpecCruiseControlTemplateDeploymentDeploymentStrategy
 */
export enum KafkaSpecCruiseControlTemplateDeploymentDeploymentStrategy {
    /** RollingUpdate */
    ROLLING_UPDATE = "RollingUpdate",
    /** Recreate */
    RECREATE = "Recreate",
}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecCruiseControlTemplatePodMetadata
 */
export interface KafkaSpecCruiseControlTemplatePodMetadata {
    /**
     * Labels added to the Kubernetes resource.
     *
     * @schema KafkaSpecCruiseControlTemplatePodMetadata#labels
     */
    readonly labels?: any;

    /**
     * Annotations added to the Kubernetes resource.
     *
     * @schema KafkaSpecCruiseControlTemplatePodMetadata#annotations
     */
    readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodMetadata' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodMetadata(obj: KafkaSpecCruiseControlTemplatePodMetadata | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labels': obj.labels,
        'annotations': obj.annotations,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodImagePullSecrets
 */
export interface KafkaSpecCruiseControlTemplatePodImagePullSecrets {
    /**
     * @schema KafkaSpecCruiseControlTemplatePodImagePullSecrets#name
     */
    readonly name?: string;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodImagePullSecrets' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodImagePullSecrets(obj: KafkaSpecCruiseControlTemplatePodImagePullSecrets | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Configures pod-level security attributes and common container settings.
 *
 * @schema KafkaSpecCruiseControlTemplatePodSecurityContext
 */
export interface KafkaSpecCruiseControlTemplatePodSecurityContext {
    /**
     * @schema KafkaSpecCruiseControlTemplatePodSecurityContext#fsGroup
     */
    readonly fsGroup?: number;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodSecurityContext#fsGroupChangePolicy
     */
    readonly fsGroupChangePolicy?: string;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodSecurityContext#runAsGroup
     */
    readonly runAsGroup?: number;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodSecurityContext#runAsNonRoot
     */
    readonly runAsNonRoot?: boolean;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodSecurityContext#runAsUser
     */
    readonly runAsUser?: number;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodSecurityContext#seLinuxOptions
     */
    readonly seLinuxOptions?: KafkaSpecCruiseControlTemplatePodSecurityContextSeLinuxOptions;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodSecurityContext#seccompProfile
     */
    readonly seccompProfile?: KafkaSpecCruiseControlTemplatePodSecurityContextSeccompProfile;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodSecurityContext#supplementalGroups
     */
    readonly supplementalGroups?: number[];

    /**
     * @schema KafkaSpecCruiseControlTemplatePodSecurityContext#sysctls
     */
    readonly sysctls?: KafkaSpecCruiseControlTemplatePodSecurityContextSysctls[];

    /**
     * @schema KafkaSpecCruiseControlTemplatePodSecurityContext#windowsOptions
     */
    readonly windowsOptions?: KafkaSpecCruiseControlTemplatePodSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodSecurityContext' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodSecurityContext(obj: KafkaSpecCruiseControlTemplatePodSecurityContext | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'fsGroup': obj.fsGroup,
        'fsGroupChangePolicy': obj.fsGroupChangePolicy,
        'runAsGroup': obj.runAsGroup,
        'runAsNonRoot': obj.runAsNonRoot,
        'runAsUser': obj.runAsUser,
        'seLinuxOptions': toJson_KafkaSpecCruiseControlTemplatePodSecurityContextSeLinuxOptions(obj.seLinuxOptions),
        'seccompProfile': toJson_KafkaSpecCruiseControlTemplatePodSecurityContextSeccompProfile(obj.seccompProfile),
        'supplementalGroups': obj.supplementalGroups?.map(y => y),
        'sysctls': obj.sysctls?.map(y => toJson_KafkaSpecCruiseControlTemplatePodSecurityContextSysctls(y)),
        'windowsOptions': toJson_KafkaSpecCruiseControlTemplatePodSecurityContextWindowsOptions(obj.windowsOptions),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * The pod's affinity rules.
 *
 * @schema KafkaSpecCruiseControlTemplatePodAffinity
 */
export interface KafkaSpecCruiseControlTemplatePodAffinity {
    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinity#nodeAffinity
     */
    readonly nodeAffinity?: KafkaSpecCruiseControlTemplatePodAffinityNodeAffinity;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinity#podAffinity
     */
    readonly podAffinity?: KafkaSpecCruiseControlTemplatePodAffinityPodAffinity;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinity#podAntiAffinity
     */
    readonly podAntiAffinity?: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinity;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinity' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinity(obj: KafkaSpecCruiseControlTemplatePodAffinity | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'nodeAffinity': toJson_KafkaSpecCruiseControlTemplatePodAffinityNodeAffinity(obj.nodeAffinity),
        'podAffinity': toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAffinity(obj.podAffinity),
        'podAntiAffinity': toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinity(obj.podAntiAffinity),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodTolerations
 */
export interface KafkaSpecCruiseControlTemplatePodTolerations {
    /**
     * @schema KafkaSpecCruiseControlTemplatePodTolerations#effect
     */
    readonly effect?: string;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodTolerations#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodTolerations#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodTolerations#tolerationSeconds
     */
    readonly tolerationSeconds?: number;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodTolerations#value
     */
    readonly value?: string;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodTolerations' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodTolerations(obj: KafkaSpecCruiseControlTemplatePodTolerations | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'effect': obj.effect,
        'key': obj.key,
        'operator': obj.operator,
        'tolerationSeconds': obj.tolerationSeconds,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodHostAliases
 */
export interface KafkaSpecCruiseControlTemplatePodHostAliases {
    /**
     * @schema KafkaSpecCruiseControlTemplatePodHostAliases#hostnames
     */
    readonly hostnames?: string[];

    /**
     * @schema KafkaSpecCruiseControlTemplatePodHostAliases#ip
     */
    readonly ip?: string;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodHostAliases' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodHostAliases(obj: KafkaSpecCruiseControlTemplatePodHostAliases | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'hostnames': obj.hostnames?.map(y => y),
        'ip': obj.ip,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodTopologySpreadConstraints
 */
export interface KafkaSpecCruiseControlTemplatePodTopologySpreadConstraints {
    /**
     * @schema KafkaSpecCruiseControlTemplatePodTopologySpreadConstraints#labelSelector
     */
    readonly labelSelector?: KafkaSpecCruiseControlTemplatePodTopologySpreadConstraintsLabelSelector;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodTopologySpreadConstraints#matchLabelKeys
     */
    readonly matchLabelKeys?: string[];

    /**
     * @schema KafkaSpecCruiseControlTemplatePodTopologySpreadConstraints#maxSkew
     */
    readonly maxSkew?: number;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodTopologySpreadConstraints#minDomains
     */
    readonly minDomains?: number;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodTopologySpreadConstraints#nodeAffinityPolicy
     */
    readonly nodeAffinityPolicy?: string;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodTopologySpreadConstraints#nodeTaintsPolicy
     */
    readonly nodeTaintsPolicy?: string;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodTopologySpreadConstraints#topologyKey
     */
    readonly topologyKey?: string;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodTopologySpreadConstraints#whenUnsatisfiable
     */
    readonly whenUnsatisfiable?: string;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodTopologySpreadConstraints' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodTopologySpreadConstraints(obj: KafkaSpecCruiseControlTemplatePodTopologySpreadConstraints | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labelSelector': toJson_KafkaSpecCruiseControlTemplatePodTopologySpreadConstraintsLabelSelector(obj.labelSelector),
        'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
        'maxSkew': obj.maxSkew,
        'minDomains': obj.minDomains,
        'nodeAffinityPolicy': obj.nodeAffinityPolicy,
        'nodeTaintsPolicy': obj.nodeTaintsPolicy,
        'topologyKey': obj.topologyKey,
        'whenUnsatisfiable': obj.whenUnsatisfiable,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecCruiseControlTemplateApiServiceMetadata
 */
export interface KafkaSpecCruiseControlTemplateApiServiceMetadata {
    /**
     * Labels added to the Kubernetes resource.
     *
     * @schema KafkaSpecCruiseControlTemplateApiServiceMetadata#labels
     */
    readonly labels?: any;

    /**
     * Annotations added to the Kubernetes resource.
     *
     * @schema KafkaSpecCruiseControlTemplateApiServiceMetadata#annotations
     */
    readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplateApiServiceMetadata' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplateApiServiceMetadata(obj: KafkaSpecCruiseControlTemplateApiServiceMetadata | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labels': obj.labels,
        'annotations': obj.annotations,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Specifies the IP Family Policy used by the service. Available options are `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a single IP family. `PreferDualStack` is for two IP families on dual-stack configured clusters or a single IP family on single-stack clusters. `RequireDualStack` fails unless there are two IP families on dual-stack configured clusters. If unspecified, Kubernetes will choose the default value based on the service type. Available on Kubernetes 1.20 and newer.
 *
 * @schema KafkaSpecCruiseControlTemplateApiServiceIpFamilyPolicy
 */
export enum KafkaSpecCruiseControlTemplateApiServiceIpFamilyPolicy {
    /** SingleStack */
    SINGLE_STACK = "SingleStack",
    /** PreferDualStack */
    PREFER_DUAL_STACK = "PreferDualStack",
    /** RequireDualStack */
    REQUIRE_DUAL_STACK = "RequireDualStack",
}

/**
 * @schema KafkaSpecCruiseControlTemplateApiServiceIpFamilies
 */
export enum KafkaSpecCruiseControlTemplateApiServiceIpFamilies {
    /** IPv4 */
    I_PV4 = "IPv4",
    /** IPv6 */
    I_PV6 = "IPv6",
}

/**
 * Metadata to apply to the `PodDisruptionBudgetTemplate` resource.
 *
 * @schema KafkaSpecCruiseControlTemplatePodDisruptionBudgetMetadata
 */
export interface KafkaSpecCruiseControlTemplatePodDisruptionBudgetMetadata {
    /**
     * Labels added to the Kubernetes resource.
     *
     * @schema KafkaSpecCruiseControlTemplatePodDisruptionBudgetMetadata#labels
     */
    readonly labels?: any;

    /**
     * Annotations added to the Kubernetes resource.
     *
     * @schema KafkaSpecCruiseControlTemplatePodDisruptionBudgetMetadata#annotations
     */
    readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodDisruptionBudgetMetadata' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodDisruptionBudgetMetadata(obj: KafkaSpecCruiseControlTemplatePodDisruptionBudgetMetadata | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labels': obj.labels,
        'annotations': obj.annotations,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerEnv
 */
export interface KafkaSpecCruiseControlTemplateCruiseControlContainerEnv {
    /**
     * The environment variable key.
     *
     * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerEnv#name
     */
    readonly name?: string;

    /**
     * The environment variable value.
     *
     * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerEnv#value
     */
    readonly value?: string;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplateCruiseControlContainerEnv' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplateCruiseControlContainerEnv(obj: KafkaSpecCruiseControlTemplateCruiseControlContainerEnv | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Security context for the container.
 *
 * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext
 */
export interface KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext {
    /**
     * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext#allowPrivilegeEscalation
     */
    readonly allowPrivilegeEscalation?: boolean;

    /**
     * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext#capabilities
     */
    readonly capabilities?: KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextCapabilities;

    /**
     * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext#privileged
     */
    readonly privileged?: boolean;

    /**
     * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext#procMount
     */
    readonly procMount?: string;

    /**
     * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext#readOnlyRootFilesystem
     */
    readonly readOnlyRootFilesystem?: boolean;

    /**
     * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext#runAsGroup
     */
    readonly runAsGroup?: number;

    /**
     * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext#runAsNonRoot
     */
    readonly runAsNonRoot?: boolean;

    /**
     * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext#runAsUser
     */
    readonly runAsUser?: number;

    /**
     * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext#seLinuxOptions
     */
    readonly seLinuxOptions?: KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeLinuxOptions;

    /**
     * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext#seccompProfile
     */
    readonly seccompProfile?: KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeccompProfile;

    /**
     * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext#windowsOptions
     */
    readonly windowsOptions?: KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext(obj: KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
        'capabilities': toJson_KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextCapabilities(obj.capabilities),
        'privileged': obj.privileged,
        'procMount': obj.procMount,
        'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
        'runAsGroup': obj.runAsGroup,
        'runAsNonRoot': obj.runAsNonRoot,
        'runAsUser': obj.runAsUser,
        'seLinuxOptions': toJson_KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeLinuxOptions(obj.seLinuxOptions),
        'seccompProfile': toJson_KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeccompProfile(obj.seccompProfile),
        'windowsOptions': toJson_KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextWindowsOptions(obj.windowsOptions),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerEnv
 */
export interface KafkaSpecCruiseControlTemplateTlsSidecarContainerEnv {
    /**
     * The environment variable key.
     *
     * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerEnv#name
     */
    readonly name?: string;

    /**
     * The environment variable value.
     *
     * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerEnv#value
     */
    readonly value?: string;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplateTlsSidecarContainerEnv' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplateTlsSidecarContainerEnv(obj: KafkaSpecCruiseControlTemplateTlsSidecarContainerEnv | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Security context for the container.
 *
 * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext
 */
export interface KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext {
    /**
     * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext#allowPrivilegeEscalation
     */
    readonly allowPrivilegeEscalation?: boolean;

    /**
     * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext#capabilities
     */
    readonly capabilities?: KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextCapabilities;

    /**
     * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext#privileged
     */
    readonly privileged?: boolean;

    /**
     * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext#procMount
     */
    readonly procMount?: string;

    /**
     * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext#readOnlyRootFilesystem
     */
    readonly readOnlyRootFilesystem?: boolean;

    /**
     * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext#runAsGroup
     */
    readonly runAsGroup?: number;

    /**
     * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext#runAsNonRoot
     */
    readonly runAsNonRoot?: boolean;

    /**
     * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext#runAsUser
     */
    readonly runAsUser?: number;

    /**
     * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext#seLinuxOptions
     */
    readonly seLinuxOptions?: KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeLinuxOptions;

    /**
     * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext#seccompProfile
     */
    readonly seccompProfile?: KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeccompProfile;

    /**
     * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext#windowsOptions
     */
    readonly windowsOptions?: KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext(obj: KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
        'capabilities': toJson_KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextCapabilities(obj.capabilities),
        'privileged': obj.privileged,
        'procMount': obj.procMount,
        'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
        'runAsGroup': obj.runAsGroup,
        'runAsNonRoot': obj.runAsNonRoot,
        'runAsUser': obj.runAsUser,
        'seLinuxOptions': toJson_KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeLinuxOptions(obj.seLinuxOptions),
        'seccompProfile': toJson_KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeccompProfile(obj.seccompProfile),
        'windowsOptions': toJson_KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextWindowsOptions(obj.windowsOptions),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecCruiseControlTemplateServiceAccountMetadata
 */
export interface KafkaSpecCruiseControlTemplateServiceAccountMetadata {
    /**
     * Labels added to the Kubernetes resource.
     *
     * @schema KafkaSpecCruiseControlTemplateServiceAccountMetadata#labels
     */
    readonly labels?: any;

    /**
     * Annotations added to the Kubernetes resource.
     *
     * @schema KafkaSpecCruiseControlTemplateServiceAccountMetadata#annotations
     */
    readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplateServiceAccountMetadata' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplateServiceAccountMetadata(obj: KafkaSpecCruiseControlTemplateServiceAccountMetadata | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labels': obj.labels,
        'annotations': obj.annotations,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Reference to the key in the ConfigMap containing the configuration.
 *
 * @schema KafkaSpecCruiseControlMetricsConfigValueFromConfigMapKeyRef
 */
export interface KafkaSpecCruiseControlMetricsConfigValueFromConfigMapKeyRef {
    /**
     * @schema KafkaSpecCruiseControlMetricsConfigValueFromConfigMapKeyRef#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecCruiseControlMetricsConfigValueFromConfigMapKeyRef#name
     */
    readonly name?: string;

    /**
     * @schema KafkaSpecCruiseControlMetricsConfigValueFromConfigMapKeyRef#optional
     */
    readonly optional?: boolean;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlMetricsConfigValueFromConfigMapKeyRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlMetricsConfigValueFromConfigMapKeyRef(obj: KafkaSpecCruiseControlMetricsConfigValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'name': obj.name,
        'optional': obj.optional,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecJmxTransTemplateDeploymentMetadata
 */
export interface KafkaSpecJmxTransTemplateDeploymentMetadata {
    /**
     * Labels added to the Kubernetes resource.
     *
     * @schema KafkaSpecJmxTransTemplateDeploymentMetadata#labels
     */
    readonly labels?: any;

    /**
     * Annotations added to the Kubernetes resource.
     *
     * @schema KafkaSpecJmxTransTemplateDeploymentMetadata#annotations
     */
    readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplateDeploymentMetadata' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplateDeploymentMetadata(obj: KafkaSpecJmxTransTemplateDeploymentMetadata | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labels': obj.labels,
        'annotations': obj.annotations,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Pod replacement strategy for deployment configuration changes. Valid values are `RollingUpdate` and `Recreate`. Defaults to `RollingUpdate`.
 *
 * @default RollingUpdate`.
 * @schema KafkaSpecJmxTransTemplateDeploymentDeploymentStrategy
 */
export enum KafkaSpecJmxTransTemplateDeploymentDeploymentStrategy {
    /** RollingUpdate */
    ROLLING_UPDATE = "RollingUpdate",
    /** Recreate */
    RECREATE = "Recreate",
}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecJmxTransTemplatePodMetadata
 */
export interface KafkaSpecJmxTransTemplatePodMetadata {
    /**
     * Labels added to the Kubernetes resource.
     *
     * @schema KafkaSpecJmxTransTemplatePodMetadata#labels
     */
    readonly labels?: any;

    /**
     * Annotations added to the Kubernetes resource.
     *
     * @schema KafkaSpecJmxTransTemplatePodMetadata#annotations
     */
    readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodMetadata' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodMetadata(obj: KafkaSpecJmxTransTemplatePodMetadata | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labels': obj.labels,
        'annotations': obj.annotations,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodImagePullSecrets
 */
export interface KafkaSpecJmxTransTemplatePodImagePullSecrets {
    /**
     * @schema KafkaSpecJmxTransTemplatePodImagePullSecrets#name
     */
    readonly name?: string;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodImagePullSecrets' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodImagePullSecrets(obj: KafkaSpecJmxTransTemplatePodImagePullSecrets | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Configures pod-level security attributes and common container settings.
 *
 * @schema KafkaSpecJmxTransTemplatePodSecurityContext
 */
export interface KafkaSpecJmxTransTemplatePodSecurityContext {
    /**
     * @schema KafkaSpecJmxTransTemplatePodSecurityContext#fsGroup
     */
    readonly fsGroup?: number;

    /**
     * @schema KafkaSpecJmxTransTemplatePodSecurityContext#fsGroupChangePolicy
     */
    readonly fsGroupChangePolicy?: string;

    /**
     * @schema KafkaSpecJmxTransTemplatePodSecurityContext#runAsGroup
     */
    readonly runAsGroup?: number;

    /**
     * @schema KafkaSpecJmxTransTemplatePodSecurityContext#runAsNonRoot
     */
    readonly runAsNonRoot?: boolean;

    /**
     * @schema KafkaSpecJmxTransTemplatePodSecurityContext#runAsUser
     */
    readonly runAsUser?: number;

    /**
     * @schema KafkaSpecJmxTransTemplatePodSecurityContext#seLinuxOptions
     */
    readonly seLinuxOptions?: KafkaSpecJmxTransTemplatePodSecurityContextSeLinuxOptions;

    /**
     * @schema KafkaSpecJmxTransTemplatePodSecurityContext#seccompProfile
     */
    readonly seccompProfile?: KafkaSpecJmxTransTemplatePodSecurityContextSeccompProfile;

    /**
     * @schema KafkaSpecJmxTransTemplatePodSecurityContext#supplementalGroups
     */
    readonly supplementalGroups?: number[];

    /**
     * @schema KafkaSpecJmxTransTemplatePodSecurityContext#sysctls
     */
    readonly sysctls?: KafkaSpecJmxTransTemplatePodSecurityContextSysctls[];

    /**
     * @schema KafkaSpecJmxTransTemplatePodSecurityContext#windowsOptions
     */
    readonly windowsOptions?: KafkaSpecJmxTransTemplatePodSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodSecurityContext' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodSecurityContext(obj: KafkaSpecJmxTransTemplatePodSecurityContext | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'fsGroup': obj.fsGroup,
        'fsGroupChangePolicy': obj.fsGroupChangePolicy,
        'runAsGroup': obj.runAsGroup,
        'runAsNonRoot': obj.runAsNonRoot,
        'runAsUser': obj.runAsUser,
        'seLinuxOptions': toJson_KafkaSpecJmxTransTemplatePodSecurityContextSeLinuxOptions(obj.seLinuxOptions),
        'seccompProfile': toJson_KafkaSpecJmxTransTemplatePodSecurityContextSeccompProfile(obj.seccompProfile),
        'supplementalGroups': obj.supplementalGroups?.map(y => y),
        'sysctls': obj.sysctls?.map(y => toJson_KafkaSpecJmxTransTemplatePodSecurityContextSysctls(y)),
        'windowsOptions': toJson_KafkaSpecJmxTransTemplatePodSecurityContextWindowsOptions(obj.windowsOptions),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * The pod's affinity rules.
 *
 * @schema KafkaSpecJmxTransTemplatePodAffinity
 */
export interface KafkaSpecJmxTransTemplatePodAffinity {
    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinity#nodeAffinity
     */
    readonly nodeAffinity?: KafkaSpecJmxTransTemplatePodAffinityNodeAffinity;

    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinity#podAffinity
     */
    readonly podAffinity?: KafkaSpecJmxTransTemplatePodAffinityPodAffinity;

    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinity#podAntiAffinity
     */
    readonly podAntiAffinity?: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinity;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinity' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinity(obj: KafkaSpecJmxTransTemplatePodAffinity | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'nodeAffinity': toJson_KafkaSpecJmxTransTemplatePodAffinityNodeAffinity(obj.nodeAffinity),
        'podAffinity': toJson_KafkaSpecJmxTransTemplatePodAffinityPodAffinity(obj.podAffinity),
        'podAntiAffinity': toJson_KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinity(obj.podAntiAffinity),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodTolerations
 */
export interface KafkaSpecJmxTransTemplatePodTolerations {
    /**
     * @schema KafkaSpecJmxTransTemplatePodTolerations#effect
     */
    readonly effect?: string;

    /**
     * @schema KafkaSpecJmxTransTemplatePodTolerations#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecJmxTransTemplatePodTolerations#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecJmxTransTemplatePodTolerations#tolerationSeconds
     */
    readonly tolerationSeconds?: number;

    /**
     * @schema KafkaSpecJmxTransTemplatePodTolerations#value
     */
    readonly value?: string;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodTolerations' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodTolerations(obj: KafkaSpecJmxTransTemplatePodTolerations | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'effect': obj.effect,
        'key': obj.key,
        'operator': obj.operator,
        'tolerationSeconds': obj.tolerationSeconds,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodHostAliases
 */
export interface KafkaSpecJmxTransTemplatePodHostAliases {
    /**
     * @schema KafkaSpecJmxTransTemplatePodHostAliases#hostnames
     */
    readonly hostnames?: string[];

    /**
     * @schema KafkaSpecJmxTransTemplatePodHostAliases#ip
     */
    readonly ip?: string;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodHostAliases' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodHostAliases(obj: KafkaSpecJmxTransTemplatePodHostAliases | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'hostnames': obj.hostnames?.map(y => y),
        'ip': obj.ip,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodTopologySpreadConstraints
 */
export interface KafkaSpecJmxTransTemplatePodTopologySpreadConstraints {
    /**
     * @schema KafkaSpecJmxTransTemplatePodTopologySpreadConstraints#labelSelector
     */
    readonly labelSelector?: KafkaSpecJmxTransTemplatePodTopologySpreadConstraintsLabelSelector;

    /**
     * @schema KafkaSpecJmxTransTemplatePodTopologySpreadConstraints#matchLabelKeys
     */
    readonly matchLabelKeys?: string[];

    /**
     * @schema KafkaSpecJmxTransTemplatePodTopologySpreadConstraints#maxSkew
     */
    readonly maxSkew?: number;

    /**
     * @schema KafkaSpecJmxTransTemplatePodTopologySpreadConstraints#minDomains
     */
    readonly minDomains?: number;

    /**
     * @schema KafkaSpecJmxTransTemplatePodTopologySpreadConstraints#nodeAffinityPolicy
     */
    readonly nodeAffinityPolicy?: string;

    /**
     * @schema KafkaSpecJmxTransTemplatePodTopologySpreadConstraints#nodeTaintsPolicy
     */
    readonly nodeTaintsPolicy?: string;

    /**
     * @schema KafkaSpecJmxTransTemplatePodTopologySpreadConstraints#topologyKey
     */
    readonly topologyKey?: string;

    /**
     * @schema KafkaSpecJmxTransTemplatePodTopologySpreadConstraints#whenUnsatisfiable
     */
    readonly whenUnsatisfiable?: string;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodTopologySpreadConstraints' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodTopologySpreadConstraints(obj: KafkaSpecJmxTransTemplatePodTopologySpreadConstraints | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labelSelector': toJson_KafkaSpecJmxTransTemplatePodTopologySpreadConstraintsLabelSelector(obj.labelSelector),
        'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
        'maxSkew': obj.maxSkew,
        'minDomains': obj.minDomains,
        'nodeAffinityPolicy': obj.nodeAffinityPolicy,
        'nodeTaintsPolicy': obj.nodeTaintsPolicy,
        'topologyKey': obj.topologyKey,
        'whenUnsatisfiable': obj.whenUnsatisfiable,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplateContainerEnv
 */
export interface KafkaSpecJmxTransTemplateContainerEnv {
    /**
     * The environment variable key.
     *
     * @schema KafkaSpecJmxTransTemplateContainerEnv#name
     */
    readonly name?: string;

    /**
     * The environment variable value.
     *
     * @schema KafkaSpecJmxTransTemplateContainerEnv#value
     */
    readonly value?: string;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplateContainerEnv' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplateContainerEnv(obj: KafkaSpecJmxTransTemplateContainerEnv | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Security context for the container.
 *
 * @schema KafkaSpecJmxTransTemplateContainerSecurityContext
 */
export interface KafkaSpecJmxTransTemplateContainerSecurityContext {
    /**
     * @schema KafkaSpecJmxTransTemplateContainerSecurityContext#allowPrivilegeEscalation
     */
    readonly allowPrivilegeEscalation?: boolean;

    /**
     * @schema KafkaSpecJmxTransTemplateContainerSecurityContext#capabilities
     */
    readonly capabilities?: KafkaSpecJmxTransTemplateContainerSecurityContextCapabilities;

    /**
     * @schema KafkaSpecJmxTransTemplateContainerSecurityContext#privileged
     */
    readonly privileged?: boolean;

    /**
     * @schema KafkaSpecJmxTransTemplateContainerSecurityContext#procMount
     */
    readonly procMount?: string;

    /**
     * @schema KafkaSpecJmxTransTemplateContainerSecurityContext#readOnlyRootFilesystem
     */
    readonly readOnlyRootFilesystem?: boolean;

    /**
     * @schema KafkaSpecJmxTransTemplateContainerSecurityContext#runAsGroup
     */
    readonly runAsGroup?: number;

    /**
     * @schema KafkaSpecJmxTransTemplateContainerSecurityContext#runAsNonRoot
     */
    readonly runAsNonRoot?: boolean;

    /**
     * @schema KafkaSpecJmxTransTemplateContainerSecurityContext#runAsUser
     */
    readonly runAsUser?: number;

    /**
     * @schema KafkaSpecJmxTransTemplateContainerSecurityContext#seLinuxOptions
     */
    readonly seLinuxOptions?: KafkaSpecJmxTransTemplateContainerSecurityContextSeLinuxOptions;

    /**
     * @schema KafkaSpecJmxTransTemplateContainerSecurityContext#seccompProfile
     */
    readonly seccompProfile?: KafkaSpecJmxTransTemplateContainerSecurityContextSeccompProfile;

    /**
     * @schema KafkaSpecJmxTransTemplateContainerSecurityContext#windowsOptions
     */
    readonly windowsOptions?: KafkaSpecJmxTransTemplateContainerSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplateContainerSecurityContext' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplateContainerSecurityContext(obj: KafkaSpecJmxTransTemplateContainerSecurityContext | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
        'capabilities': toJson_KafkaSpecJmxTransTemplateContainerSecurityContextCapabilities(obj.capabilities),
        'privileged': obj.privileged,
        'procMount': obj.procMount,
        'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
        'runAsGroup': obj.runAsGroup,
        'runAsNonRoot': obj.runAsNonRoot,
        'runAsUser': obj.runAsUser,
        'seLinuxOptions': toJson_KafkaSpecJmxTransTemplateContainerSecurityContextSeLinuxOptions(obj.seLinuxOptions),
        'seccompProfile': toJson_KafkaSpecJmxTransTemplateContainerSecurityContextSeccompProfile(obj.seccompProfile),
        'windowsOptions': toJson_KafkaSpecJmxTransTemplateContainerSecurityContextWindowsOptions(obj.windowsOptions),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecJmxTransTemplateServiceAccountMetadata
 */
export interface KafkaSpecJmxTransTemplateServiceAccountMetadata {
    /**
     * Labels added to the Kubernetes resource.
     *
     * @schema KafkaSpecJmxTransTemplateServiceAccountMetadata#labels
     */
    readonly labels?: any;

    /**
     * Annotations added to the Kubernetes resource.
     *
     * @schema KafkaSpecJmxTransTemplateServiceAccountMetadata#annotations
     */
    readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplateServiceAccountMetadata' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplateServiceAccountMetadata(obj: KafkaSpecJmxTransTemplateServiceAccountMetadata | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labels': obj.labels,
        'annotations': obj.annotations,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaExporterTemplateDeploymentMetadata
 */
export interface KafkaSpecKafkaExporterTemplateDeploymentMetadata {
    /**
     * Labels added to the Kubernetes resource.
     *
     * @schema KafkaSpecKafkaExporterTemplateDeploymentMetadata#labels
     */
    readonly labels?: any;

    /**
     * Annotations added to the Kubernetes resource.
     *
     * @schema KafkaSpecKafkaExporterTemplateDeploymentMetadata#annotations
     */
    readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplateDeploymentMetadata' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplateDeploymentMetadata(obj: KafkaSpecKafkaExporterTemplateDeploymentMetadata | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labels': obj.labels,
        'annotations': obj.annotations,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Pod replacement strategy for deployment configuration changes. Valid values are `RollingUpdate` and `Recreate`. Defaults to `RollingUpdate`.
 *
 * @default RollingUpdate`.
 * @schema KafkaSpecKafkaExporterTemplateDeploymentDeploymentStrategy
 */
export enum KafkaSpecKafkaExporterTemplateDeploymentDeploymentStrategy {
    /** RollingUpdate */
    ROLLING_UPDATE = "RollingUpdate",
    /** Recreate */
    RECREATE = "Recreate",
}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaExporterTemplatePodMetadata
 */
export interface KafkaSpecKafkaExporterTemplatePodMetadata {
    /**
     * Labels added to the Kubernetes resource.
     *
     * @schema KafkaSpecKafkaExporterTemplatePodMetadata#labels
     */
    readonly labels?: any;

    /**
     * Annotations added to the Kubernetes resource.
     *
     * @schema KafkaSpecKafkaExporterTemplatePodMetadata#annotations
     */
    readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodMetadata' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodMetadata(obj: KafkaSpecKafkaExporterTemplatePodMetadata | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labels': obj.labels,
        'annotations': obj.annotations,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodImagePullSecrets
 */
export interface KafkaSpecKafkaExporterTemplatePodImagePullSecrets {
    /**
     * @schema KafkaSpecKafkaExporterTemplatePodImagePullSecrets#name
     */
    readonly name?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodImagePullSecrets' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodImagePullSecrets(obj: KafkaSpecKafkaExporterTemplatePodImagePullSecrets | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Configures pod-level security attributes and common container settings.
 *
 * @schema KafkaSpecKafkaExporterTemplatePodSecurityContext
 */
export interface KafkaSpecKafkaExporterTemplatePodSecurityContext {
    /**
     * @schema KafkaSpecKafkaExporterTemplatePodSecurityContext#fsGroup
     */
    readonly fsGroup?: number;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodSecurityContext#fsGroupChangePolicy
     */
    readonly fsGroupChangePolicy?: string;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodSecurityContext#runAsGroup
     */
    readonly runAsGroup?: number;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodSecurityContext#runAsNonRoot
     */
    readonly runAsNonRoot?: boolean;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodSecurityContext#runAsUser
     */
    readonly runAsUser?: number;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodSecurityContext#seLinuxOptions
     */
    readonly seLinuxOptions?: KafkaSpecKafkaExporterTemplatePodSecurityContextSeLinuxOptions;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodSecurityContext#seccompProfile
     */
    readonly seccompProfile?: KafkaSpecKafkaExporterTemplatePodSecurityContextSeccompProfile;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodSecurityContext#supplementalGroups
     */
    readonly supplementalGroups?: number[];

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodSecurityContext#sysctls
     */
    readonly sysctls?: KafkaSpecKafkaExporterTemplatePodSecurityContextSysctls[];

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodSecurityContext#windowsOptions
     */
    readonly windowsOptions?: KafkaSpecKafkaExporterTemplatePodSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodSecurityContext' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodSecurityContext(obj: KafkaSpecKafkaExporterTemplatePodSecurityContext | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'fsGroup': obj.fsGroup,
        'fsGroupChangePolicy': obj.fsGroupChangePolicy,
        'runAsGroup': obj.runAsGroup,
        'runAsNonRoot': obj.runAsNonRoot,
        'runAsUser': obj.runAsUser,
        'seLinuxOptions': toJson_KafkaSpecKafkaExporterTemplatePodSecurityContextSeLinuxOptions(obj.seLinuxOptions),
        'seccompProfile': toJson_KafkaSpecKafkaExporterTemplatePodSecurityContextSeccompProfile(obj.seccompProfile),
        'supplementalGroups': obj.supplementalGroups?.map(y => y),
        'sysctls': obj.sysctls?.map(y => toJson_KafkaSpecKafkaExporterTemplatePodSecurityContextSysctls(y)),
        'windowsOptions': toJson_KafkaSpecKafkaExporterTemplatePodSecurityContextWindowsOptions(obj.windowsOptions),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * The pod's affinity rules.
 *
 * @schema KafkaSpecKafkaExporterTemplatePodAffinity
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinity {
    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinity#nodeAffinity
     */
    readonly nodeAffinity?: KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinity;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinity#podAffinity
     */
    readonly podAffinity?: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinity;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinity#podAntiAffinity
     */
    readonly podAntiAffinity?: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinity;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinity' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinity(obj: KafkaSpecKafkaExporterTemplatePodAffinity | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'nodeAffinity': toJson_KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinity(obj.nodeAffinity),
        'podAffinity': toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAffinity(obj.podAffinity),
        'podAntiAffinity': toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinity(obj.podAntiAffinity),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodTolerations
 */
export interface KafkaSpecKafkaExporterTemplatePodTolerations {
    /**
     * @schema KafkaSpecKafkaExporterTemplatePodTolerations#effect
     */
    readonly effect?: string;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodTolerations#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodTolerations#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodTolerations#tolerationSeconds
     */
    readonly tolerationSeconds?: number;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodTolerations#value
     */
    readonly value?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodTolerations' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodTolerations(obj: KafkaSpecKafkaExporterTemplatePodTolerations | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'effect': obj.effect,
        'key': obj.key,
        'operator': obj.operator,
        'tolerationSeconds': obj.tolerationSeconds,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodHostAliases
 */
export interface KafkaSpecKafkaExporterTemplatePodHostAliases {
    /**
     * @schema KafkaSpecKafkaExporterTemplatePodHostAliases#hostnames
     */
    readonly hostnames?: string[];

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodHostAliases#ip
     */
    readonly ip?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodHostAliases' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodHostAliases(obj: KafkaSpecKafkaExporterTemplatePodHostAliases | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'hostnames': obj.hostnames?.map(y => y),
        'ip': obj.ip,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraints
 */
export interface KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraints {
    /**
     * @schema KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraints#labelSelector
     */
    readonly labelSelector?: KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraintsLabelSelector;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraints#matchLabelKeys
     */
    readonly matchLabelKeys?: string[];

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraints#maxSkew
     */
    readonly maxSkew?: number;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraints#minDomains
     */
    readonly minDomains?: number;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraints#nodeAffinityPolicy
     */
    readonly nodeAffinityPolicy?: string;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraints#nodeTaintsPolicy
     */
    readonly nodeTaintsPolicy?: string;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraints#topologyKey
     */
    readonly topologyKey?: string;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraints#whenUnsatisfiable
     */
    readonly whenUnsatisfiable?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraints' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraints(obj: KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraints | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labelSelector': toJson_KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraintsLabelSelector(obj.labelSelector),
        'matchLabelKeys': obj.matchLabelKeys?.map(y => y),
        'maxSkew': obj.maxSkew,
        'minDomains': obj.minDomains,
        'nodeAffinityPolicy': obj.nodeAffinityPolicy,
        'nodeTaintsPolicy': obj.nodeTaintsPolicy,
        'topologyKey': obj.topologyKey,
        'whenUnsatisfiable': obj.whenUnsatisfiable,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaExporterTemplateServiceMetadata
 */
export interface KafkaSpecKafkaExporterTemplateServiceMetadata {
    /**
     * Labels added to the Kubernetes resource.
     *
     * @schema KafkaSpecKafkaExporterTemplateServiceMetadata#labels
     */
    readonly labels?: any;

    /**
     * Annotations added to the Kubernetes resource.
     *
     * @schema KafkaSpecKafkaExporterTemplateServiceMetadata#annotations
     */
    readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplateServiceMetadata' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplateServiceMetadata(obj: KafkaSpecKafkaExporterTemplateServiceMetadata | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labels': obj.labels,
        'annotations': obj.annotations,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplateContainerEnv
 */
export interface KafkaSpecKafkaExporterTemplateContainerEnv {
    /**
     * The environment variable key.
     *
     * @schema KafkaSpecKafkaExporterTemplateContainerEnv#name
     */
    readonly name?: string;

    /**
     * The environment variable value.
     *
     * @schema KafkaSpecKafkaExporterTemplateContainerEnv#value
     */
    readonly value?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplateContainerEnv' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplateContainerEnv(obj: KafkaSpecKafkaExporterTemplateContainerEnv | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Security context for the container.
 *
 * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContext
 */
export interface KafkaSpecKafkaExporterTemplateContainerSecurityContext {
    /**
     * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContext#allowPrivilegeEscalation
     */
    readonly allowPrivilegeEscalation?: boolean;

    /**
     * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContext#capabilities
     */
    readonly capabilities?: KafkaSpecKafkaExporterTemplateContainerSecurityContextCapabilities;

    /**
     * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContext#privileged
     */
    readonly privileged?: boolean;

    /**
     * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContext#procMount
     */
    readonly procMount?: string;

    /**
     * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContext#readOnlyRootFilesystem
     */
    readonly readOnlyRootFilesystem?: boolean;

    /**
     * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContext#runAsGroup
     */
    readonly runAsGroup?: number;

    /**
     * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContext#runAsNonRoot
     */
    readonly runAsNonRoot?: boolean;

    /**
     * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContext#runAsUser
     */
    readonly runAsUser?: number;

    /**
     * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContext#seLinuxOptions
     */
    readonly seLinuxOptions?: KafkaSpecKafkaExporterTemplateContainerSecurityContextSeLinuxOptions;

    /**
     * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContext#seccompProfile
     */
    readonly seccompProfile?: KafkaSpecKafkaExporterTemplateContainerSecurityContextSeccompProfile;

    /**
     * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContext#windowsOptions
     */
    readonly windowsOptions?: KafkaSpecKafkaExporterTemplateContainerSecurityContextWindowsOptions;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplateContainerSecurityContext' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplateContainerSecurityContext(obj: KafkaSpecKafkaExporterTemplateContainerSecurityContext | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'allowPrivilegeEscalation': obj.allowPrivilegeEscalation,
        'capabilities': toJson_KafkaSpecKafkaExporterTemplateContainerSecurityContextCapabilities(obj.capabilities),
        'privileged': obj.privileged,
        'procMount': obj.procMount,
        'readOnlyRootFilesystem': obj.readOnlyRootFilesystem,
        'runAsGroup': obj.runAsGroup,
        'runAsNonRoot': obj.runAsNonRoot,
        'runAsUser': obj.runAsUser,
        'seLinuxOptions': toJson_KafkaSpecKafkaExporterTemplateContainerSecurityContextSeLinuxOptions(obj.seLinuxOptions),
        'seccompProfile': toJson_KafkaSpecKafkaExporterTemplateContainerSecurityContextSeccompProfile(obj.seccompProfile),
        'windowsOptions': toJson_KafkaSpecKafkaExporterTemplateContainerSecurityContextWindowsOptions(obj.windowsOptions),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaExporterTemplateServiceAccountMetadata
 */
export interface KafkaSpecKafkaExporterTemplateServiceAccountMetadata {
    /**
     * Labels added to the Kubernetes resource.
     *
     * @schema KafkaSpecKafkaExporterTemplateServiceAccountMetadata#labels
     */
    readonly labels?: any;

    /**
     * Annotations added to the Kubernetes resource.
     *
     * @schema KafkaSpecKafkaExporterTemplateServiceAccountMetadata#annotations
     */
    readonly annotations?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplateServiceAccountMetadata' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplateServiceAccountMetadata(obj: KafkaSpecKafkaExporterTemplateServiceAccountMetadata | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labels': obj.labels,
        'annotations': obj.annotations,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaListenersNetworkPolicyPeersNamespaceSelectorMatchExpressions
 */
export interface KafkaSpecKafkaListenersNetworkPolicyPeersNamespaceSelectorMatchExpressions {
    /**
     * @schema KafkaSpecKafkaListenersNetworkPolicyPeersNamespaceSelectorMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecKafkaListenersNetworkPolicyPeersNamespaceSelectorMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecKafkaListenersNetworkPolicyPeersNamespaceSelectorMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaListenersNetworkPolicyPeersNamespaceSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaListenersNetworkPolicyPeersNamespaceSelectorMatchExpressions(obj: KafkaSpecKafkaListenersNetworkPolicyPeersNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaListenersNetworkPolicyPeersPodSelectorMatchExpressions
 */
export interface KafkaSpecKafkaListenersNetworkPolicyPeersPodSelectorMatchExpressions {
    /**
     * @schema KafkaSpecKafkaListenersNetworkPolicyPeersPodSelectorMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecKafkaListenersNetworkPolicyPeersPodSelectorMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecKafkaListenersNetworkPolicyPeersPodSelectorMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaListenersNetworkPolicyPeersPodSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaListenersNetworkPolicyPeersPodSelectorMatchExpressions(obj: KafkaSpecKafkaListenersNetworkPolicyPeersPodSelectorMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodSecurityContextSeLinuxOptions
 */
export interface KafkaSpecKafkaTemplatePodSecurityContextSeLinuxOptions {
    /**
     * @schema KafkaSpecKafkaTemplatePodSecurityContextSeLinuxOptions#level
     */
    readonly level?: string;

    /**
     * @schema KafkaSpecKafkaTemplatePodSecurityContextSeLinuxOptions#role
     */
    readonly role?: string;

    /**
     * @schema KafkaSpecKafkaTemplatePodSecurityContextSeLinuxOptions#type
     */
    readonly type?: string;

    /**
     * @schema KafkaSpecKafkaTemplatePodSecurityContextSeLinuxOptions#user
     */
    readonly user?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodSecurityContextSeLinuxOptions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodSecurityContextSeLinuxOptions(obj: KafkaSpecKafkaTemplatePodSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'level': obj.level,
        'role': obj.role,
        'type': obj.type,
        'user': obj.user,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodSecurityContextSeccompProfile
 */
export interface KafkaSpecKafkaTemplatePodSecurityContextSeccompProfile {
    /**
     * @schema KafkaSpecKafkaTemplatePodSecurityContextSeccompProfile#localhostProfile
     */
    readonly localhostProfile?: string;

    /**
     * @schema KafkaSpecKafkaTemplatePodSecurityContextSeccompProfile#type
     */
    readonly type?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodSecurityContextSeccompProfile' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodSecurityContextSeccompProfile(obj: KafkaSpecKafkaTemplatePodSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'localhostProfile': obj.localhostProfile,
        'type': obj.type,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodSecurityContextSysctls
 */
export interface KafkaSpecKafkaTemplatePodSecurityContextSysctls {
    /**
     * @schema KafkaSpecKafkaTemplatePodSecurityContextSysctls#name
     */
    readonly name?: string;

    /**
     * @schema KafkaSpecKafkaTemplatePodSecurityContextSysctls#value
     */
    readonly value?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodSecurityContextSysctls' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodSecurityContextSysctls(obj: KafkaSpecKafkaTemplatePodSecurityContextSysctls | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodSecurityContextWindowsOptions
 */
export interface KafkaSpecKafkaTemplatePodSecurityContextWindowsOptions {
    /**
     * @schema KafkaSpecKafkaTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpec
     */
    readonly gmsaCredentialSpec?: string;

    /**
     * @schema KafkaSpecKafkaTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpecName
     */
    readonly gmsaCredentialSpecName?: string;

    /**
     * @schema KafkaSpecKafkaTemplatePodSecurityContextWindowsOptions#hostProcess
     */
    readonly hostProcess?: boolean;

    /**
     * @schema KafkaSpecKafkaTemplatePodSecurityContextWindowsOptions#runAsUserName
     */
    readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodSecurityContextWindowsOptions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodSecurityContextWindowsOptions(obj: KafkaSpecKafkaTemplatePodSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'gmsaCredentialSpec': obj.gmsaCredentialSpec,
        'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
        'hostProcess': obj.hostProcess,
        'runAsUserName': obj.runAsUserName,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinity
 */
export interface KafkaSpecKafkaTemplatePodAffinityNodeAffinity {
    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
     */
    readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
     */
    readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityNodeAffinity' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityNodeAffinity(obj: KafkaSpecKafkaTemplatePodAffinityNodeAffinity | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
        'requiredDuringSchedulingIgnoredDuringExecution': toJson_KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj.requiredDuringSchedulingIgnoredDuringExecution),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinity
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAffinity {
    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
     */
    readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
     */
    readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityPodAffinity' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityPodAffinity(obj: KafkaSpecKafkaTemplatePodAffinityPodAffinity | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
        'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinity
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAntiAffinity {
    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
     */
    readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
     */
    readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityPodAntiAffinity' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityPodAntiAffinity(obj: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinity | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
        'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodTopologySpreadConstraintsLabelSelector
 */
export interface KafkaSpecKafkaTemplatePodTopologySpreadConstraintsLabelSelector {
    /**
     * @schema KafkaSpecKafkaTemplatePodTopologySpreadConstraintsLabelSelector#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecKafkaTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions[];

    /**
     * @schema KafkaSpecKafkaTemplatePodTopologySpreadConstraintsLabelSelector#matchLabels
     */
    readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodTopologySpreadConstraintsLabelSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodTopologySpreadConstraintsLabelSelector(obj: KafkaSpecKafkaTemplatePodTopologySpreadConstraintsLabelSelector | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecKafkaTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions(y)),
        'matchLabels': obj.matchLabels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContextCapabilities
 */
export interface KafkaSpecKafkaTemplateKafkaContainerSecurityContextCapabilities {
    /**
     * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContextCapabilities#add
     */
    readonly add?: string[];

    /**
     * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContextCapabilities#drop
     */
    readonly drop?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateKafkaContainerSecurityContextCapabilities' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateKafkaContainerSecurityContextCapabilities(obj: KafkaSpecKafkaTemplateKafkaContainerSecurityContextCapabilities | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'add': obj.add?.map(y => y),
        'drop': obj.drop?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeLinuxOptions
 */
export interface KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeLinuxOptions {
    /**
     * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeLinuxOptions#level
     */
    readonly level?: string;

    /**
     * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeLinuxOptions#role
     */
    readonly role?: string;

    /**
     * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeLinuxOptions#type
     */
    readonly type?: string;

    /**
     * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeLinuxOptions#user
     */
    readonly user?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeLinuxOptions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeLinuxOptions(obj: KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'level': obj.level,
        'role': obj.role,
        'type': obj.type,
        'user': obj.user,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeccompProfile
 */
export interface KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeccompProfile {
    /**
     * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeccompProfile#localhostProfile
     */
    readonly localhostProfile?: string;

    /**
     * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeccompProfile#type
     */
    readonly type?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeccompProfile' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeccompProfile(obj: KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'localhostProfile': obj.localhostProfile,
        'type': obj.type,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContextWindowsOptions
 */
export interface KafkaSpecKafkaTemplateKafkaContainerSecurityContextWindowsOptions {
    /**
     * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContextWindowsOptions#gmsaCredentialSpec
     */
    readonly gmsaCredentialSpec?: string;

    /**
     * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
     */
    readonly gmsaCredentialSpecName?: string;

    /**
     * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContextWindowsOptions#hostProcess
     */
    readonly hostProcess?: boolean;

    /**
     * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContextWindowsOptions#runAsUserName
     */
    readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateKafkaContainerSecurityContextWindowsOptions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateKafkaContainerSecurityContextWindowsOptions(obj: KafkaSpecKafkaTemplateKafkaContainerSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'gmsaCredentialSpec': obj.gmsaCredentialSpec,
        'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
        'hostProcess': obj.hostProcess,
        'runAsUserName': obj.runAsUserName,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplateInitContainerSecurityContextCapabilities
 */
export interface KafkaSpecKafkaTemplateInitContainerSecurityContextCapabilities {
    /**
     * @schema KafkaSpecKafkaTemplateInitContainerSecurityContextCapabilities#add
     */
    readonly add?: string[];

    /**
     * @schema KafkaSpecKafkaTemplateInitContainerSecurityContextCapabilities#drop
     */
    readonly drop?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateInitContainerSecurityContextCapabilities' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateInitContainerSecurityContextCapabilities(obj: KafkaSpecKafkaTemplateInitContainerSecurityContextCapabilities | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'add': obj.add?.map(y => y),
        'drop': obj.drop?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplateInitContainerSecurityContextSeLinuxOptions
 */
export interface KafkaSpecKafkaTemplateInitContainerSecurityContextSeLinuxOptions {
    /**
     * @schema KafkaSpecKafkaTemplateInitContainerSecurityContextSeLinuxOptions#level
     */
    readonly level?: string;

    /**
     * @schema KafkaSpecKafkaTemplateInitContainerSecurityContextSeLinuxOptions#role
     */
    readonly role?: string;

    /**
     * @schema KafkaSpecKafkaTemplateInitContainerSecurityContextSeLinuxOptions#type
     */
    readonly type?: string;

    /**
     * @schema KafkaSpecKafkaTemplateInitContainerSecurityContextSeLinuxOptions#user
     */
    readonly user?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateInitContainerSecurityContextSeLinuxOptions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateInitContainerSecurityContextSeLinuxOptions(obj: KafkaSpecKafkaTemplateInitContainerSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'level': obj.level,
        'role': obj.role,
        'type': obj.type,
        'user': obj.user,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplateInitContainerSecurityContextSeccompProfile
 */
export interface KafkaSpecKafkaTemplateInitContainerSecurityContextSeccompProfile {
    /**
     * @schema KafkaSpecKafkaTemplateInitContainerSecurityContextSeccompProfile#localhostProfile
     */
    readonly localhostProfile?: string;

    /**
     * @schema KafkaSpecKafkaTemplateInitContainerSecurityContextSeccompProfile#type
     */
    readonly type?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateInitContainerSecurityContextSeccompProfile' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateInitContainerSecurityContextSeccompProfile(obj: KafkaSpecKafkaTemplateInitContainerSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'localhostProfile': obj.localhostProfile,
        'type': obj.type,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplateInitContainerSecurityContextWindowsOptions
 */
export interface KafkaSpecKafkaTemplateInitContainerSecurityContextWindowsOptions {
    /**
     * @schema KafkaSpecKafkaTemplateInitContainerSecurityContextWindowsOptions#gmsaCredentialSpec
     */
    readonly gmsaCredentialSpec?: string;

    /**
     * @schema KafkaSpecKafkaTemplateInitContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
     */
    readonly gmsaCredentialSpecName?: string;

    /**
     * @schema KafkaSpecKafkaTemplateInitContainerSecurityContextWindowsOptions#hostProcess
     */
    readonly hostProcess?: boolean;

    /**
     * @schema KafkaSpecKafkaTemplateInitContainerSecurityContextWindowsOptions#runAsUserName
     */
    readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplateInitContainerSecurityContextWindowsOptions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplateInitContainerSecurityContextWindowsOptions(obj: KafkaSpecKafkaTemplateInitContainerSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'gmsaCredentialSpec': obj.gmsaCredentialSpec,
        'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
        'hostProcess': obj.hostProcess,
        'runAsUserName': obj.runAsUserName,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodSecurityContextSeLinuxOptions
 */
export interface KafkaSpecZookeeperTemplatePodSecurityContextSeLinuxOptions {
    /**
     * @schema KafkaSpecZookeeperTemplatePodSecurityContextSeLinuxOptions#level
     */
    readonly level?: string;

    /**
     * @schema KafkaSpecZookeeperTemplatePodSecurityContextSeLinuxOptions#role
     */
    readonly role?: string;

    /**
     * @schema KafkaSpecZookeeperTemplatePodSecurityContextSeLinuxOptions#type
     */
    readonly type?: string;

    /**
     * @schema KafkaSpecZookeeperTemplatePodSecurityContextSeLinuxOptions#user
     */
    readonly user?: string;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodSecurityContextSeLinuxOptions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodSecurityContextSeLinuxOptions(obj: KafkaSpecZookeeperTemplatePodSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'level': obj.level,
        'role': obj.role,
        'type': obj.type,
        'user': obj.user,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodSecurityContextSeccompProfile
 */
export interface KafkaSpecZookeeperTemplatePodSecurityContextSeccompProfile {
    /**
     * @schema KafkaSpecZookeeperTemplatePodSecurityContextSeccompProfile#localhostProfile
     */
    readonly localhostProfile?: string;

    /**
     * @schema KafkaSpecZookeeperTemplatePodSecurityContextSeccompProfile#type
     */
    readonly type?: string;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodSecurityContextSeccompProfile' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodSecurityContextSeccompProfile(obj: KafkaSpecZookeeperTemplatePodSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'localhostProfile': obj.localhostProfile,
        'type': obj.type,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodSecurityContextSysctls
 */
export interface KafkaSpecZookeeperTemplatePodSecurityContextSysctls {
    /**
     * @schema KafkaSpecZookeeperTemplatePodSecurityContextSysctls#name
     */
    readonly name?: string;

    /**
     * @schema KafkaSpecZookeeperTemplatePodSecurityContextSysctls#value
     */
    readonly value?: string;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodSecurityContextSysctls' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodSecurityContextSysctls(obj: KafkaSpecZookeeperTemplatePodSecurityContextSysctls | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodSecurityContextWindowsOptions
 */
export interface KafkaSpecZookeeperTemplatePodSecurityContextWindowsOptions {
    /**
     * @schema KafkaSpecZookeeperTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpec
     */
    readonly gmsaCredentialSpec?: string;

    /**
     * @schema KafkaSpecZookeeperTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpecName
     */
    readonly gmsaCredentialSpecName?: string;

    /**
     * @schema KafkaSpecZookeeperTemplatePodSecurityContextWindowsOptions#hostProcess
     */
    readonly hostProcess?: boolean;

    /**
     * @schema KafkaSpecZookeeperTemplatePodSecurityContextWindowsOptions#runAsUserName
     */
    readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodSecurityContextWindowsOptions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodSecurityContextWindowsOptions(obj: KafkaSpecZookeeperTemplatePodSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'gmsaCredentialSpec': obj.gmsaCredentialSpec,
        'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
        'hostProcess': obj.hostProcess,
        'runAsUserName': obj.runAsUserName,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinity
 */
export interface KafkaSpecZookeeperTemplatePodAffinityNodeAffinity {
    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
     */
    readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
     */
    readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityNodeAffinity' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityNodeAffinity(obj: KafkaSpecZookeeperTemplatePodAffinityNodeAffinity | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
        'requiredDuringSchedulingIgnoredDuringExecution': toJson_KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj.requiredDuringSchedulingIgnoredDuringExecution),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinity
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAffinity {
    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
     */
    readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
     */
    readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityPodAffinity' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityPodAffinity(obj: KafkaSpecZookeeperTemplatePodAffinityPodAffinity | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
        'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinity
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinity {
    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
     */
    readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
     */
    readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinity' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinity(obj: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinity | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
        'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodTopologySpreadConstraintsLabelSelector
 */
export interface KafkaSpecZookeeperTemplatePodTopologySpreadConstraintsLabelSelector {
    /**
     * @schema KafkaSpecZookeeperTemplatePodTopologySpreadConstraintsLabelSelector#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecZookeeperTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions[];

    /**
     * @schema KafkaSpecZookeeperTemplatePodTopologySpreadConstraintsLabelSelector#matchLabels
     */
    readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodTopologySpreadConstraintsLabelSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodTopologySpreadConstraintsLabelSelector(obj: KafkaSpecZookeeperTemplatePodTopologySpreadConstraintsLabelSelector | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecZookeeperTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions(y)),
        'matchLabels': obj.matchLabels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextCapabilities
 */
export interface KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextCapabilities {
    /**
     * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextCapabilities#add
     */
    readonly add?: string[];

    /**
     * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextCapabilities#drop
     */
    readonly drop?: string[];

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextCapabilities' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextCapabilities(obj: KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextCapabilities | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'add': obj.add?.map(y => y),
        'drop': obj.drop?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeLinuxOptions
 */
export interface KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeLinuxOptions {
    /**
     * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeLinuxOptions#level
     */
    readonly level?: string;

    /**
     * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeLinuxOptions#role
     */
    readonly role?: string;

    /**
     * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeLinuxOptions#type
     */
    readonly type?: string;

    /**
     * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeLinuxOptions#user
     */
    readonly user?: string;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeLinuxOptions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeLinuxOptions(obj: KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'level': obj.level,
        'role': obj.role,
        'type': obj.type,
        'user': obj.user,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeccompProfile
 */
export interface KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeccompProfile {
    /**
     * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeccompProfile#localhostProfile
     */
    readonly localhostProfile?: string;

    /**
     * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeccompProfile#type
     */
    readonly type?: string;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeccompProfile' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeccompProfile(obj: KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'localhostProfile': obj.localhostProfile,
        'type': obj.type,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextWindowsOptions
 */
export interface KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextWindowsOptions {
    /**
     * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextWindowsOptions#gmsaCredentialSpec
     */
    readonly gmsaCredentialSpec?: string;

    /**
     * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
     */
    readonly gmsaCredentialSpecName?: string;

    /**
     * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextWindowsOptions#hostProcess
     */
    readonly hostProcess?: boolean;

    /**
     * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextWindowsOptions#runAsUserName
     */
    readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextWindowsOptions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextWindowsOptions(obj: KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'gmsaCredentialSpec': obj.gmsaCredentialSpec,
        'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
        'hostProcess': obj.hostProcess,
        'runAsUserName': obj.runAsUserName,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Reference to the key in the ConfigMap containing the configuration.
 *
 * @schema KafkaSpecEntityOperatorTopicOperatorLoggingValueFromConfigMapKeyRef
 */
export interface KafkaSpecEntityOperatorTopicOperatorLoggingValueFromConfigMapKeyRef {
    /**
     * @schema KafkaSpecEntityOperatorTopicOperatorLoggingValueFromConfigMapKeyRef#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecEntityOperatorTopicOperatorLoggingValueFromConfigMapKeyRef#name
     */
    readonly name?: string;

    /**
     * @schema KafkaSpecEntityOperatorTopicOperatorLoggingValueFromConfigMapKeyRef#optional
     */
    readonly optional?: boolean;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTopicOperatorLoggingValueFromConfigMapKeyRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTopicOperatorLoggingValueFromConfigMapKeyRef(obj: KafkaSpecEntityOperatorTopicOperatorLoggingValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'name': obj.name,
        'optional': obj.optional,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * Reference to the key in the ConfigMap containing the configuration.
 *
 * @schema KafkaSpecEntityOperatorUserOperatorLoggingValueFromConfigMapKeyRef
 */
export interface KafkaSpecEntityOperatorUserOperatorLoggingValueFromConfigMapKeyRef {
    /**
     * @schema KafkaSpecEntityOperatorUserOperatorLoggingValueFromConfigMapKeyRef#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecEntityOperatorUserOperatorLoggingValueFromConfigMapKeyRef#name
     */
    readonly name?: string;

    /**
     * @schema KafkaSpecEntityOperatorUserOperatorLoggingValueFromConfigMapKeyRef#optional
     */
    readonly optional?: boolean;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorUserOperatorLoggingValueFromConfigMapKeyRef' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorUserOperatorLoggingValueFromConfigMapKeyRef(obj: KafkaSpecEntityOperatorUserOperatorLoggingValueFromConfigMapKeyRef | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'name': obj.name,
        'optional': obj.optional,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodSecurityContextSeLinuxOptions
 */
export interface KafkaSpecEntityOperatorTemplatePodSecurityContextSeLinuxOptions {
    /**
     * @schema KafkaSpecEntityOperatorTemplatePodSecurityContextSeLinuxOptions#level
     */
    readonly level?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodSecurityContextSeLinuxOptions#role
     */
    readonly role?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodSecurityContextSeLinuxOptions#type
     */
    readonly type?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodSecurityContextSeLinuxOptions#user
     */
    readonly user?: string;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodSecurityContextSeLinuxOptions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodSecurityContextSeLinuxOptions(obj: KafkaSpecEntityOperatorTemplatePodSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'level': obj.level,
        'role': obj.role,
        'type': obj.type,
        'user': obj.user,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodSecurityContextSeccompProfile
 */
export interface KafkaSpecEntityOperatorTemplatePodSecurityContextSeccompProfile {
    /**
     * @schema KafkaSpecEntityOperatorTemplatePodSecurityContextSeccompProfile#localhostProfile
     */
    readonly localhostProfile?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodSecurityContextSeccompProfile#type
     */
    readonly type?: string;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodSecurityContextSeccompProfile' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodSecurityContextSeccompProfile(obj: KafkaSpecEntityOperatorTemplatePodSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'localhostProfile': obj.localhostProfile,
        'type': obj.type,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodSecurityContextSysctls
 */
export interface KafkaSpecEntityOperatorTemplatePodSecurityContextSysctls {
    /**
     * @schema KafkaSpecEntityOperatorTemplatePodSecurityContextSysctls#name
     */
    readonly name?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodSecurityContextSysctls#value
     */
    readonly value?: string;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodSecurityContextSysctls' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodSecurityContextSysctls(obj: KafkaSpecEntityOperatorTemplatePodSecurityContextSysctls | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodSecurityContextWindowsOptions
 */
export interface KafkaSpecEntityOperatorTemplatePodSecurityContextWindowsOptions {
    /**
     * @schema KafkaSpecEntityOperatorTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpec
     */
    readonly gmsaCredentialSpec?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpecName
     */
    readonly gmsaCredentialSpecName?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodSecurityContextWindowsOptions#hostProcess
     */
    readonly hostProcess?: boolean;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodSecurityContextWindowsOptions#runAsUserName
     */
    readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodSecurityContextWindowsOptions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodSecurityContextWindowsOptions(obj: KafkaSpecEntityOperatorTemplatePodSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'gmsaCredentialSpec': obj.gmsaCredentialSpec,
        'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
        'hostProcess': obj.hostProcess,
        'runAsUserName': obj.runAsUserName,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinity
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinity {
    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
     */
    readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
     */
    readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinity' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinity(obj: KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinity | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
        'requiredDuringSchedulingIgnoredDuringExecution': toJson_KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj.requiredDuringSchedulingIgnoredDuringExecution),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinity
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAffinity {
    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
     */
    readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
     */
    readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityPodAffinity' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAffinity(obj: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinity | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
        'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinity
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinity {
    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
     */
    readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
     */
    readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinity' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinity(obj: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinity | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
        'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraintsLabelSelector
 */
export interface KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraintsLabelSelector {
    /**
     * @schema KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraintsLabelSelector#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions[];

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraintsLabelSelector#matchLabels
     */
    readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraintsLabelSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraintsLabelSelector(obj: KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraintsLabelSelector | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions(y)),
        'matchLabels': obj.matchLabels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextCapabilities
 */
export interface KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextCapabilities {
    /**
     * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextCapabilities#add
     */
    readonly add?: string[];

    /**
     * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextCapabilities#drop
     */
    readonly drop?: string[];

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextCapabilities' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextCapabilities(obj: KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextCapabilities | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'add': obj.add?.map(y => y),
        'drop': obj.drop?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeLinuxOptions
 */
export interface KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeLinuxOptions {
    /**
     * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeLinuxOptions#level
     */
    readonly level?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeLinuxOptions#role
     */
    readonly role?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeLinuxOptions#type
     */
    readonly type?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeLinuxOptions#user
     */
    readonly user?: string;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeLinuxOptions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeLinuxOptions(obj: KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'level': obj.level,
        'role': obj.role,
        'type': obj.type,
        'user': obj.user,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeccompProfile
 */
export interface KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeccompProfile {
    /**
     * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeccompProfile#localhostProfile
     */
    readonly localhostProfile?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeccompProfile#type
     */
    readonly type?: string;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeccompProfile' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeccompProfile(obj: KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'localhostProfile': obj.localhostProfile,
        'type': obj.type,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextWindowsOptions
 */
export interface KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextWindowsOptions {
    /**
     * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextWindowsOptions#gmsaCredentialSpec
     */
    readonly gmsaCredentialSpec?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
     */
    readonly gmsaCredentialSpecName?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextWindowsOptions#hostProcess
     */
    readonly hostProcess?: boolean;

    /**
     * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextWindowsOptions#runAsUserName
     */
    readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextWindowsOptions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextWindowsOptions(obj: KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'gmsaCredentialSpec': obj.gmsaCredentialSpec,
        'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
        'hostProcess': obj.hostProcess,
        'runAsUserName': obj.runAsUserName,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextCapabilities
 */
export interface KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextCapabilities {
    /**
     * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextCapabilities#add
     */
    readonly add?: string[];

    /**
     * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextCapabilities#drop
     */
    readonly drop?: string[];

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextCapabilities' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextCapabilities(obj: KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextCapabilities | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'add': obj.add?.map(y => y),
        'drop': obj.drop?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeLinuxOptions
 */
export interface KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeLinuxOptions {
    /**
     * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeLinuxOptions#level
     */
    readonly level?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeLinuxOptions#role
     */
    readonly role?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeLinuxOptions#type
     */
    readonly type?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeLinuxOptions#user
     */
    readonly user?: string;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeLinuxOptions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeLinuxOptions(obj: KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'level': obj.level,
        'role': obj.role,
        'type': obj.type,
        'user': obj.user,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeccompProfile
 */
export interface KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeccompProfile {
    /**
     * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeccompProfile#localhostProfile
     */
    readonly localhostProfile?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeccompProfile#type
     */
    readonly type?: string;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeccompProfile' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeccompProfile(obj: KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'localhostProfile': obj.localhostProfile,
        'type': obj.type,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextWindowsOptions
 */
export interface KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextWindowsOptions {
    /**
     * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextWindowsOptions#gmsaCredentialSpec
     */
    readonly gmsaCredentialSpec?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
     */
    readonly gmsaCredentialSpecName?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextWindowsOptions#hostProcess
     */
    readonly hostProcess?: boolean;

    /**
     * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextWindowsOptions#runAsUserName
     */
    readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextWindowsOptions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextWindowsOptions(obj: KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'gmsaCredentialSpec': obj.gmsaCredentialSpec,
        'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
        'hostProcess': obj.hostProcess,
        'runAsUserName': obj.runAsUserName,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextCapabilities
 */
export interface KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextCapabilities {
    /**
     * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextCapabilities#add
     */
    readonly add?: string[];

    /**
     * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextCapabilities#drop
     */
    readonly drop?: string[];

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextCapabilities' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextCapabilities(obj: KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextCapabilities | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'add': obj.add?.map(y => y),
        'drop': obj.drop?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeLinuxOptions
 */
export interface KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeLinuxOptions {
    /**
     * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeLinuxOptions#level
     */
    readonly level?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeLinuxOptions#role
     */
    readonly role?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeLinuxOptions#type
     */
    readonly type?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeLinuxOptions#user
     */
    readonly user?: string;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeLinuxOptions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeLinuxOptions(obj: KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'level': obj.level,
        'role': obj.role,
        'type': obj.type,
        'user': obj.user,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeccompProfile
 */
export interface KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeccompProfile {
    /**
     * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeccompProfile#localhostProfile
     */
    readonly localhostProfile?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeccompProfile#type
     */
    readonly type?: string;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeccompProfile' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeccompProfile(obj: KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'localhostProfile': obj.localhostProfile,
        'type': obj.type,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextWindowsOptions
 */
export interface KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextWindowsOptions {
    /**
     * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextWindowsOptions#gmsaCredentialSpec
     */
    readonly gmsaCredentialSpec?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
     */
    readonly gmsaCredentialSpecName?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextWindowsOptions#hostProcess
     */
    readonly hostProcess?: boolean;

    /**
     * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextWindowsOptions#runAsUserName
     */
    readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextWindowsOptions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextWindowsOptions(obj: KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'gmsaCredentialSpec': obj.gmsaCredentialSpec,
        'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
        'hostProcess': obj.hostProcess,
        'runAsUserName': obj.runAsUserName,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodSecurityContextSeLinuxOptions
 */
export interface KafkaSpecCruiseControlTemplatePodSecurityContextSeLinuxOptions {
    /**
     * @schema KafkaSpecCruiseControlTemplatePodSecurityContextSeLinuxOptions#level
     */
    readonly level?: string;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodSecurityContextSeLinuxOptions#role
     */
    readonly role?: string;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodSecurityContextSeLinuxOptions#type
     */
    readonly type?: string;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodSecurityContextSeLinuxOptions#user
     */
    readonly user?: string;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodSecurityContextSeLinuxOptions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodSecurityContextSeLinuxOptions(obj: KafkaSpecCruiseControlTemplatePodSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'level': obj.level,
        'role': obj.role,
        'type': obj.type,
        'user': obj.user,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodSecurityContextSeccompProfile
 */
export interface KafkaSpecCruiseControlTemplatePodSecurityContextSeccompProfile {
    /**
     * @schema KafkaSpecCruiseControlTemplatePodSecurityContextSeccompProfile#localhostProfile
     */
    readonly localhostProfile?: string;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodSecurityContextSeccompProfile#type
     */
    readonly type?: string;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodSecurityContextSeccompProfile' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodSecurityContextSeccompProfile(obj: KafkaSpecCruiseControlTemplatePodSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'localhostProfile': obj.localhostProfile,
        'type': obj.type,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodSecurityContextSysctls
 */
export interface KafkaSpecCruiseControlTemplatePodSecurityContextSysctls {
    /**
     * @schema KafkaSpecCruiseControlTemplatePodSecurityContextSysctls#name
     */
    readonly name?: string;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodSecurityContextSysctls#value
     */
    readonly value?: string;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodSecurityContextSysctls' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodSecurityContextSysctls(obj: KafkaSpecCruiseControlTemplatePodSecurityContextSysctls | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodSecurityContextWindowsOptions
 */
export interface KafkaSpecCruiseControlTemplatePodSecurityContextWindowsOptions {
    /**
     * @schema KafkaSpecCruiseControlTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpec
     */
    readonly gmsaCredentialSpec?: string;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpecName
     */
    readonly gmsaCredentialSpecName?: string;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodSecurityContextWindowsOptions#hostProcess
     */
    readonly hostProcess?: boolean;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodSecurityContextWindowsOptions#runAsUserName
     */
    readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodSecurityContextWindowsOptions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodSecurityContextWindowsOptions(obj: KafkaSpecCruiseControlTemplatePodSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'gmsaCredentialSpec': obj.gmsaCredentialSpec,
        'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
        'hostProcess': obj.hostProcess,
        'runAsUserName': obj.runAsUserName,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinity
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityNodeAffinity {
    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
     */
    readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
     */
    readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityNodeAffinity' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityNodeAffinity(obj: KafkaSpecCruiseControlTemplatePodAffinityNodeAffinity | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
        'requiredDuringSchedulingIgnoredDuringExecution': toJson_KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj.requiredDuringSchedulingIgnoredDuringExecution),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinity
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAffinity {
    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
     */
    readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
     */
    readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityPodAffinity' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAffinity(obj: KafkaSpecCruiseControlTemplatePodAffinityPodAffinity | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
        'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinity
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinity {
    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
     */
    readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
     */
    readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinity' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinity(obj: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinity | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
        'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodTopologySpreadConstraintsLabelSelector
 */
export interface KafkaSpecCruiseControlTemplatePodTopologySpreadConstraintsLabelSelector {
    /**
     * @schema KafkaSpecCruiseControlTemplatePodTopologySpreadConstraintsLabelSelector#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecCruiseControlTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions[];

    /**
     * @schema KafkaSpecCruiseControlTemplatePodTopologySpreadConstraintsLabelSelector#matchLabels
     */
    readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodTopologySpreadConstraintsLabelSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodTopologySpreadConstraintsLabelSelector(obj: KafkaSpecCruiseControlTemplatePodTopologySpreadConstraintsLabelSelector | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecCruiseControlTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions(y)),
        'matchLabels': obj.matchLabels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextCapabilities
 */
export interface KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextCapabilities {
    /**
     * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextCapabilities#add
     */
    readonly add?: string[];

    /**
     * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextCapabilities#drop
     */
    readonly drop?: string[];

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextCapabilities' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextCapabilities(obj: KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextCapabilities | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'add': obj.add?.map(y => y),
        'drop': obj.drop?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeLinuxOptions
 */
export interface KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeLinuxOptions {
    /**
     * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeLinuxOptions#level
     */
    readonly level?: string;

    /**
     * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeLinuxOptions#role
     */
    readonly role?: string;

    /**
     * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeLinuxOptions#type
     */
    readonly type?: string;

    /**
     * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeLinuxOptions#user
     */
    readonly user?: string;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeLinuxOptions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeLinuxOptions(obj: KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'level': obj.level,
        'role': obj.role,
        'type': obj.type,
        'user': obj.user,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeccompProfile
 */
export interface KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeccompProfile {
    /**
     * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeccompProfile#localhostProfile
     */
    readonly localhostProfile?: string;

    /**
     * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeccompProfile#type
     */
    readonly type?: string;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeccompProfile' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeccompProfile(obj: KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'localhostProfile': obj.localhostProfile,
        'type': obj.type,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextWindowsOptions
 */
export interface KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextWindowsOptions {
    /**
     * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextWindowsOptions#gmsaCredentialSpec
     */
    readonly gmsaCredentialSpec?: string;

    /**
     * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
     */
    readonly gmsaCredentialSpecName?: string;

    /**
     * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextWindowsOptions#hostProcess
     */
    readonly hostProcess?: boolean;

    /**
     * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextWindowsOptions#runAsUserName
     */
    readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextWindowsOptions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextWindowsOptions(obj: KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'gmsaCredentialSpec': obj.gmsaCredentialSpec,
        'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
        'hostProcess': obj.hostProcess,
        'runAsUserName': obj.runAsUserName,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextCapabilities
 */
export interface KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextCapabilities {
    /**
     * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextCapabilities#add
     */
    readonly add?: string[];

    /**
     * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextCapabilities#drop
     */
    readonly drop?: string[];

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextCapabilities' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextCapabilities(obj: KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextCapabilities | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'add': obj.add?.map(y => y),
        'drop': obj.drop?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeLinuxOptions
 */
export interface KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeLinuxOptions {
    /**
     * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeLinuxOptions#level
     */
    readonly level?: string;

    /**
     * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeLinuxOptions#role
     */
    readonly role?: string;

    /**
     * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeLinuxOptions#type
     */
    readonly type?: string;

    /**
     * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeLinuxOptions#user
     */
    readonly user?: string;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeLinuxOptions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeLinuxOptions(obj: KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'level': obj.level,
        'role': obj.role,
        'type': obj.type,
        'user': obj.user,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeccompProfile
 */
export interface KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeccompProfile {
    /**
     * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeccompProfile#localhostProfile
     */
    readonly localhostProfile?: string;

    /**
     * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeccompProfile#type
     */
    readonly type?: string;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeccompProfile' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeccompProfile(obj: KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'localhostProfile': obj.localhostProfile,
        'type': obj.type,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextWindowsOptions
 */
export interface KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextWindowsOptions {
    /**
     * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextWindowsOptions#gmsaCredentialSpec
     */
    readonly gmsaCredentialSpec?: string;

    /**
     * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
     */
    readonly gmsaCredentialSpecName?: string;

    /**
     * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextWindowsOptions#hostProcess
     */
    readonly hostProcess?: boolean;

    /**
     * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextWindowsOptions#runAsUserName
     */
    readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextWindowsOptions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextWindowsOptions(obj: KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'gmsaCredentialSpec': obj.gmsaCredentialSpec,
        'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
        'hostProcess': obj.hostProcess,
        'runAsUserName': obj.runAsUserName,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodSecurityContextSeLinuxOptions
 */
export interface KafkaSpecJmxTransTemplatePodSecurityContextSeLinuxOptions {
    /**
     * @schema KafkaSpecJmxTransTemplatePodSecurityContextSeLinuxOptions#level
     */
    readonly level?: string;

    /**
     * @schema KafkaSpecJmxTransTemplatePodSecurityContextSeLinuxOptions#role
     */
    readonly role?: string;

    /**
     * @schema KafkaSpecJmxTransTemplatePodSecurityContextSeLinuxOptions#type
     */
    readonly type?: string;

    /**
     * @schema KafkaSpecJmxTransTemplatePodSecurityContextSeLinuxOptions#user
     */
    readonly user?: string;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodSecurityContextSeLinuxOptions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodSecurityContextSeLinuxOptions(obj: KafkaSpecJmxTransTemplatePodSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'level': obj.level,
        'role': obj.role,
        'type': obj.type,
        'user': obj.user,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodSecurityContextSeccompProfile
 */
export interface KafkaSpecJmxTransTemplatePodSecurityContextSeccompProfile {
    /**
     * @schema KafkaSpecJmxTransTemplatePodSecurityContextSeccompProfile#localhostProfile
     */
    readonly localhostProfile?: string;

    /**
     * @schema KafkaSpecJmxTransTemplatePodSecurityContextSeccompProfile#type
     */
    readonly type?: string;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodSecurityContextSeccompProfile' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodSecurityContextSeccompProfile(obj: KafkaSpecJmxTransTemplatePodSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'localhostProfile': obj.localhostProfile,
        'type': obj.type,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodSecurityContextSysctls
 */
export interface KafkaSpecJmxTransTemplatePodSecurityContextSysctls {
    /**
     * @schema KafkaSpecJmxTransTemplatePodSecurityContextSysctls#name
     */
    readonly name?: string;

    /**
     * @schema KafkaSpecJmxTransTemplatePodSecurityContextSysctls#value
     */
    readonly value?: string;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodSecurityContextSysctls' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodSecurityContextSysctls(obj: KafkaSpecJmxTransTemplatePodSecurityContextSysctls | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodSecurityContextWindowsOptions
 */
export interface KafkaSpecJmxTransTemplatePodSecurityContextWindowsOptions {
    /**
     * @schema KafkaSpecJmxTransTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpec
     */
    readonly gmsaCredentialSpec?: string;

    /**
     * @schema KafkaSpecJmxTransTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpecName
     */
    readonly gmsaCredentialSpecName?: string;

    /**
     * @schema KafkaSpecJmxTransTemplatePodSecurityContextWindowsOptions#hostProcess
     */
    readonly hostProcess?: boolean;

    /**
     * @schema KafkaSpecJmxTransTemplatePodSecurityContextWindowsOptions#runAsUserName
     */
    readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodSecurityContextWindowsOptions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodSecurityContextWindowsOptions(obj: KafkaSpecJmxTransTemplatePodSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'gmsaCredentialSpec': obj.gmsaCredentialSpec,
        'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
        'hostProcess': obj.hostProcess,
        'runAsUserName': obj.runAsUserName,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinity
 */
export interface KafkaSpecJmxTransTemplatePodAffinityNodeAffinity {
    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
     */
    readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
     */
    readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityNodeAffinity' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityNodeAffinity(obj: KafkaSpecJmxTransTemplatePodAffinityNodeAffinity | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
        'requiredDuringSchedulingIgnoredDuringExecution': toJson_KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj.requiredDuringSchedulingIgnoredDuringExecution),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinity
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAffinity {
    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
     */
    readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
     */
    readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityPodAffinity' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityPodAffinity(obj: KafkaSpecJmxTransTemplatePodAffinityPodAffinity | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
        'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinity
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinity {
    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
     */
    readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
     */
    readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinity' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinity(obj: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinity | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
        'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodTopologySpreadConstraintsLabelSelector
 */
export interface KafkaSpecJmxTransTemplatePodTopologySpreadConstraintsLabelSelector {
    /**
     * @schema KafkaSpecJmxTransTemplatePodTopologySpreadConstraintsLabelSelector#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecJmxTransTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions[];

    /**
     * @schema KafkaSpecJmxTransTemplatePodTopologySpreadConstraintsLabelSelector#matchLabels
     */
    readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodTopologySpreadConstraintsLabelSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodTopologySpreadConstraintsLabelSelector(obj: KafkaSpecJmxTransTemplatePodTopologySpreadConstraintsLabelSelector | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecJmxTransTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions(y)),
        'matchLabels': obj.matchLabels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplateContainerSecurityContextCapabilities
 */
export interface KafkaSpecJmxTransTemplateContainerSecurityContextCapabilities {
    /**
     * @schema KafkaSpecJmxTransTemplateContainerSecurityContextCapabilities#add
     */
    readonly add?: string[];

    /**
     * @schema KafkaSpecJmxTransTemplateContainerSecurityContextCapabilities#drop
     */
    readonly drop?: string[];

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplateContainerSecurityContextCapabilities' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplateContainerSecurityContextCapabilities(obj: KafkaSpecJmxTransTemplateContainerSecurityContextCapabilities | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'add': obj.add?.map(y => y),
        'drop': obj.drop?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplateContainerSecurityContextSeLinuxOptions
 */
export interface KafkaSpecJmxTransTemplateContainerSecurityContextSeLinuxOptions {
    /**
     * @schema KafkaSpecJmxTransTemplateContainerSecurityContextSeLinuxOptions#level
     */
    readonly level?: string;

    /**
     * @schema KafkaSpecJmxTransTemplateContainerSecurityContextSeLinuxOptions#role
     */
    readonly role?: string;

    /**
     * @schema KafkaSpecJmxTransTemplateContainerSecurityContextSeLinuxOptions#type
     */
    readonly type?: string;

    /**
     * @schema KafkaSpecJmxTransTemplateContainerSecurityContextSeLinuxOptions#user
     */
    readonly user?: string;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplateContainerSecurityContextSeLinuxOptions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplateContainerSecurityContextSeLinuxOptions(obj: KafkaSpecJmxTransTemplateContainerSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'level': obj.level,
        'role': obj.role,
        'type': obj.type,
        'user': obj.user,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplateContainerSecurityContextSeccompProfile
 */
export interface KafkaSpecJmxTransTemplateContainerSecurityContextSeccompProfile {
    /**
     * @schema KafkaSpecJmxTransTemplateContainerSecurityContextSeccompProfile#localhostProfile
     */
    readonly localhostProfile?: string;

    /**
     * @schema KafkaSpecJmxTransTemplateContainerSecurityContextSeccompProfile#type
     */
    readonly type?: string;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplateContainerSecurityContextSeccompProfile' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplateContainerSecurityContextSeccompProfile(obj: KafkaSpecJmxTransTemplateContainerSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'localhostProfile': obj.localhostProfile,
        'type': obj.type,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplateContainerSecurityContextWindowsOptions
 */
export interface KafkaSpecJmxTransTemplateContainerSecurityContextWindowsOptions {
    /**
     * @schema KafkaSpecJmxTransTemplateContainerSecurityContextWindowsOptions#gmsaCredentialSpec
     */
    readonly gmsaCredentialSpec?: string;

    /**
     * @schema KafkaSpecJmxTransTemplateContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
     */
    readonly gmsaCredentialSpecName?: string;

    /**
     * @schema KafkaSpecJmxTransTemplateContainerSecurityContextWindowsOptions#hostProcess
     */
    readonly hostProcess?: boolean;

    /**
     * @schema KafkaSpecJmxTransTemplateContainerSecurityContextWindowsOptions#runAsUserName
     */
    readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplateContainerSecurityContextWindowsOptions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplateContainerSecurityContextWindowsOptions(obj: KafkaSpecJmxTransTemplateContainerSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'gmsaCredentialSpec': obj.gmsaCredentialSpec,
        'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
        'hostProcess': obj.hostProcess,
        'runAsUserName': obj.runAsUserName,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodSecurityContextSeLinuxOptions
 */
export interface KafkaSpecKafkaExporterTemplatePodSecurityContextSeLinuxOptions {
    /**
     * @schema KafkaSpecKafkaExporterTemplatePodSecurityContextSeLinuxOptions#level
     */
    readonly level?: string;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodSecurityContextSeLinuxOptions#role
     */
    readonly role?: string;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodSecurityContextSeLinuxOptions#type
     */
    readonly type?: string;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodSecurityContextSeLinuxOptions#user
     */
    readonly user?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodSecurityContextSeLinuxOptions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodSecurityContextSeLinuxOptions(obj: KafkaSpecKafkaExporterTemplatePodSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'level': obj.level,
        'role': obj.role,
        'type': obj.type,
        'user': obj.user,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodSecurityContextSeccompProfile
 */
export interface KafkaSpecKafkaExporterTemplatePodSecurityContextSeccompProfile {
    /**
     * @schema KafkaSpecKafkaExporterTemplatePodSecurityContextSeccompProfile#localhostProfile
     */
    readonly localhostProfile?: string;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodSecurityContextSeccompProfile#type
     */
    readonly type?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodSecurityContextSeccompProfile' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodSecurityContextSeccompProfile(obj: KafkaSpecKafkaExporterTemplatePodSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'localhostProfile': obj.localhostProfile,
        'type': obj.type,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodSecurityContextSysctls
 */
export interface KafkaSpecKafkaExporterTemplatePodSecurityContextSysctls {
    /**
     * @schema KafkaSpecKafkaExporterTemplatePodSecurityContextSysctls#name
     */
    readonly name?: string;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodSecurityContextSysctls#value
     */
    readonly value?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodSecurityContextSysctls' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodSecurityContextSysctls(obj: KafkaSpecKafkaExporterTemplatePodSecurityContextSysctls | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'name': obj.name,
        'value': obj.value,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodSecurityContextWindowsOptions
 */
export interface KafkaSpecKafkaExporterTemplatePodSecurityContextWindowsOptions {
    /**
     * @schema KafkaSpecKafkaExporterTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpec
     */
    readonly gmsaCredentialSpec?: string;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpecName
     */
    readonly gmsaCredentialSpecName?: string;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodSecurityContextWindowsOptions#hostProcess
     */
    readonly hostProcess?: boolean;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodSecurityContextWindowsOptions#runAsUserName
     */
    readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodSecurityContextWindowsOptions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodSecurityContextWindowsOptions(obj: KafkaSpecKafkaExporterTemplatePodSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'gmsaCredentialSpec': obj.gmsaCredentialSpec,
        'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
        'hostProcess': obj.hostProcess,
        'runAsUserName': obj.runAsUserName,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinity
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinity {
    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
     */
    readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
     */
    readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinity' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinity(obj: KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinity | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
        'requiredDuringSchedulingIgnoredDuringExecution': toJson_KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj.requiredDuringSchedulingIgnoredDuringExecution),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinity
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAffinity {
    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
     */
    readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
     */
    readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityPodAffinity' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAffinity(obj: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinity | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
        'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinity
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinity {
    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
     */
    readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
     */
    readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinity' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinity(obj: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinity | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'preferredDuringSchedulingIgnoredDuringExecution': obj.preferredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(y)),
        'requiredDuringSchedulingIgnoredDuringExecution': obj.requiredDuringSchedulingIgnoredDuringExecution?.map(y => toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraintsLabelSelector
 */
export interface KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraintsLabelSelector {
    /**
     * @schema KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraintsLabelSelector#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions[];

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraintsLabelSelector#matchLabels
     */
    readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraintsLabelSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraintsLabelSelector(obj: KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraintsLabelSelector | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions(y)),
        'matchLabels': obj.matchLabels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContextCapabilities
 */
export interface KafkaSpecKafkaExporterTemplateContainerSecurityContextCapabilities {
    /**
     * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContextCapabilities#add
     */
    readonly add?: string[];

    /**
     * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContextCapabilities#drop
     */
    readonly drop?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplateContainerSecurityContextCapabilities' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplateContainerSecurityContextCapabilities(obj: KafkaSpecKafkaExporterTemplateContainerSecurityContextCapabilities | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'add': obj.add?.map(y => y),
        'drop': obj.drop?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContextSeLinuxOptions
 */
export interface KafkaSpecKafkaExporterTemplateContainerSecurityContextSeLinuxOptions {
    /**
     * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContextSeLinuxOptions#level
     */
    readonly level?: string;

    /**
     * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContextSeLinuxOptions#role
     */
    readonly role?: string;

    /**
     * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContextSeLinuxOptions#type
     */
    readonly type?: string;

    /**
     * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContextSeLinuxOptions#user
     */
    readonly user?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplateContainerSecurityContextSeLinuxOptions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplateContainerSecurityContextSeLinuxOptions(obj: KafkaSpecKafkaExporterTemplateContainerSecurityContextSeLinuxOptions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'level': obj.level,
        'role': obj.role,
        'type': obj.type,
        'user': obj.user,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContextSeccompProfile
 */
export interface KafkaSpecKafkaExporterTemplateContainerSecurityContextSeccompProfile {
    /**
     * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContextSeccompProfile#localhostProfile
     */
    readonly localhostProfile?: string;

    /**
     * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContextSeccompProfile#type
     */
    readonly type?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplateContainerSecurityContextSeccompProfile' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplateContainerSecurityContextSeccompProfile(obj: KafkaSpecKafkaExporterTemplateContainerSecurityContextSeccompProfile | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'localhostProfile': obj.localhostProfile,
        'type': obj.type,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContextWindowsOptions
 */
export interface KafkaSpecKafkaExporterTemplateContainerSecurityContextWindowsOptions {
    /**
     * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContextWindowsOptions#gmsaCredentialSpec
     */
    readonly gmsaCredentialSpec?: string;

    /**
     * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
     */
    readonly gmsaCredentialSpecName?: string;

    /**
     * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContextWindowsOptions#hostProcess
     */
    readonly hostProcess?: boolean;

    /**
     * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContextWindowsOptions#runAsUserName
     */
    readonly runAsUserName?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplateContainerSecurityContextWindowsOptions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplateContainerSecurityContextWindowsOptions(obj: KafkaSpecKafkaExporterTemplateContainerSecurityContextWindowsOptions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'gmsaCredentialSpec': obj.gmsaCredentialSpec,
        'gmsaCredentialSpecName': obj.gmsaCredentialSpecName,
        'hostProcess': obj.hostProcess,
        'runAsUserName': obj.runAsUserName,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
     */
    readonly preference?: KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
     */
    readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'preference': toJson_KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj.preference),
        'weight': obj.weight,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
     */
    readonly nodeSelectorTerms?: KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'nodeSelectorTerms': obj.nodeSelectorTerms?.map(y => toJson_KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
     */
    readonly podAffinityTerm?: KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
     */
    readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'podAffinityTerm': toJson_KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
        'weight': obj.weight,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
     */
    readonly labelSelector?: KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
     */
    readonly namespaceSelector?: KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
     */
    readonly namespaces?: string[];

    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
     */
    readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labelSelector': toJson_KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
        'namespaceSelector': toJson_KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
        'namespaces': obj.namespaces?.map(y => y),
        'topologyKey': obj.topologyKey,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
     */
    readonly podAffinityTerm?: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
     */
    readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'podAffinityTerm': toJson_KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
        'weight': obj.weight,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
     */
    readonly labelSelector?: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
     */
    readonly namespaceSelector?: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
     */
    readonly namespaces?: string[];

    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
     */
    readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labelSelector': toJson_KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
        'namespaceSelector': toJson_KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
        'namespaces': obj.namespaces?.map(y => y),
        'topologyKey': obj.topologyKey,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions
 */
export interface KafkaSpecKafkaTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions {
    /**
     * @schema KafkaSpecKafkaTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecKafkaTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecKafkaTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions(obj: KafkaSpecKafkaTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
     */
    readonly preference?: KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
     */
    readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'preference': toJson_KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj.preference),
        'weight': obj.weight,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
     */
    readonly nodeSelectorTerms?: KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'nodeSelectorTerms': obj.nodeSelectorTerms?.map(y => toJson_KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
     */
    readonly podAffinityTerm?: KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
     */
    readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'podAffinityTerm': toJson_KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
        'weight': obj.weight,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
     */
    readonly labelSelector?: KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
     */
    readonly namespaceSelector?: KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
     */
    readonly namespaces?: string[];

    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
     */
    readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labelSelector': toJson_KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
        'namespaceSelector': toJson_KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
        'namespaces': obj.namespaces?.map(y => y),
        'topologyKey': obj.topologyKey,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
     */
    readonly podAffinityTerm?: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
     */
    readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'podAffinityTerm': toJson_KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
        'weight': obj.weight,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
     */
    readonly labelSelector?: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
     */
    readonly namespaceSelector?: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
     */
    readonly namespaces?: string[];

    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
     */
    readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labelSelector': toJson_KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
        'namespaceSelector': toJson_KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
        'namespaces': obj.namespaces?.map(y => y),
        'topologyKey': obj.topologyKey,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions
 */
export interface KafkaSpecZookeeperTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions {
    /**
     * @schema KafkaSpecZookeeperTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecZookeeperTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecZookeeperTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions(obj: KafkaSpecZookeeperTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
     */
    readonly preference?: KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
     */
    readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'preference': toJson_KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj.preference),
        'weight': obj.weight,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
     */
    readonly nodeSelectorTerms?: KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'nodeSelectorTerms': obj.nodeSelectorTerms?.map(y => toJson_KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
     */
    readonly podAffinityTerm?: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
     */
    readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'podAffinityTerm': toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
        'weight': obj.weight,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
     */
    readonly labelSelector?: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
     */
    readonly namespaceSelector?: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
     */
    readonly namespaces?: string[];

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
     */
    readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labelSelector': toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
        'namespaceSelector': toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
        'namespaces': obj.namespaces?.map(y => y),
        'topologyKey': obj.topologyKey,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
     */
    readonly podAffinityTerm?: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
     */
    readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'podAffinityTerm': toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
        'weight': obj.weight,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
     */
    readonly labelSelector?: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
     */
    readonly namespaceSelector?: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
     */
    readonly namespaces?: string[];

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
     */
    readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labelSelector': toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
        'namespaceSelector': toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
        'namespaces': obj.namespaces?.map(y => y),
        'topologyKey': obj.topologyKey,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions
 */
export interface KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions {
    /**
     * @schema KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions(obj: KafkaSpecEntityOperatorTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
     */
    readonly preference?: KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
     */
    readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'preference': toJson_KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj.preference),
        'weight': obj.weight,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
     */
    readonly nodeSelectorTerms?: KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'nodeSelectorTerms': obj.nodeSelectorTerms?.map(y => toJson_KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
     */
    readonly podAffinityTerm?: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
     */
    readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'podAffinityTerm': toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
        'weight': obj.weight,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
     */
    readonly labelSelector?: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
     */
    readonly namespaceSelector?: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
     */
    readonly namespaces?: string[];

    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
     */
    readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labelSelector': toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
        'namespaceSelector': toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
        'namespaces': obj.namespaces?.map(y => y),
        'topologyKey': obj.topologyKey,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
     */
    readonly podAffinityTerm?: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
     */
    readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'podAffinityTerm': toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
        'weight': obj.weight,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
     */
    readonly labelSelector?: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
     */
    readonly namespaceSelector?: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
     */
    readonly namespaces?: string[];

    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
     */
    readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labelSelector': toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
        'namespaceSelector': toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
        'namespaces': obj.namespaces?.map(y => y),
        'topologyKey': obj.topologyKey,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions
 */
export interface KafkaSpecCruiseControlTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions {
    /**
     * @schema KafkaSpecCruiseControlTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions(obj: KafkaSpecCruiseControlTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
     */
    readonly preference?: KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
     */
    readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'preference': toJson_KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj.preference),
        'weight': obj.weight,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
     */
    readonly nodeSelectorTerms?: KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'nodeSelectorTerms': obj.nodeSelectorTerms?.map(y => toJson_KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
     */
    readonly podAffinityTerm?: KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
     */
    readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'podAffinityTerm': toJson_KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
        'weight': obj.weight,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
     */
    readonly labelSelector?: KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
     */
    readonly namespaceSelector?: KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
     */
    readonly namespaces?: string[];

    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
     */
    readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labelSelector': toJson_KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
        'namespaceSelector': toJson_KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
        'namespaces': obj.namespaces?.map(y => y),
        'topologyKey': obj.topologyKey,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
     */
    readonly podAffinityTerm?: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
     */
    readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'podAffinityTerm': toJson_KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
        'weight': obj.weight,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
     */
    readonly labelSelector?: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
     */
    readonly namespaceSelector?: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
     */
    readonly namespaces?: string[];

    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
     */
    readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labelSelector': toJson_KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
        'namespaceSelector': toJson_KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
        'namespaces': obj.namespaces?.map(y => y),
        'topologyKey': obj.topologyKey,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions
 */
export interface KafkaSpecJmxTransTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions {
    /**
     * @schema KafkaSpecJmxTransTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecJmxTransTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecJmxTransTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions(obj: KafkaSpecJmxTransTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
     */
    readonly preference?: KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
     */
    readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'preference': toJson_KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj.preference),
        'weight': obj.weight,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
     */
    readonly nodeSelectorTerms?: KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'nodeSelectorTerms': obj.nodeSelectorTerms?.map(y => toJson_KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
     */
    readonly podAffinityTerm?: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
     */
    readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'podAffinityTerm': toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
        'weight': obj.weight,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
     */
    readonly labelSelector?: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
     */
    readonly namespaceSelector?: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
     */
    readonly namespaces?: string[];

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
     */
    readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labelSelector': toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
        'namespaceSelector': toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
        'namespaces': obj.namespaces?.map(y => y),
        'topologyKey': obj.topologyKey,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
     */
    readonly podAffinityTerm?: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
     */
    readonly weight?: number;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'podAffinityTerm': toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj.podAffinityTerm),
        'weight': obj.weight,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
     */
    readonly labelSelector?: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaceSelector
     */
    readonly namespaceSelector?: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
     */
    readonly namespaces?: string[];

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
     */
    readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution(obj: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labelSelector': toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj.labelSelector),
        'namespaceSelector': toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj.namespaceSelector),
        'namespaces': obj.namespaces?.map(y => y),
        'topologyKey': obj.topologyKey,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions
 */
export interface KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions {
    /**
     * @schema KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions(obj: KafkaSpecKafkaExporterTemplatePodTopologySpreadConstraintsLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
     */
    readonly matchFields?: KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj: KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(y)),
        'matchFields': obj.matchFields?.map(y => toJson_KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
     */
    readonly matchFields?: KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(obj: KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(y)),
        'matchFields': obj.matchFields?.map(y => toJson_KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
     */
    readonly labelSelector?: KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
     */
    readonly namespaceSelector?: KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
     */
    readonly namespaces?: string[];

    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
     */
    readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labelSelector': toJson_KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
        'namespaceSelector': toJson_KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
        'namespaces': obj.namespaces?.map(y => y),
        'topologyKey': obj.topologyKey,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
     */
    readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
        'matchLabels': obj.matchLabels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
     */
    readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
        'matchLabels': obj.matchLabels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
     */
    readonly labelSelector?: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
     */
    readonly namespaceSelector?: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
     */
    readonly namespaces?: string[];

    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
     */
    readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labelSelector': toJson_KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
        'namespaceSelector': toJson_KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
        'namespaces': obj.namespaces?.map(y => y),
        'topologyKey': obj.topologyKey,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
     */
    readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
        'matchLabels': obj.matchLabels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
     */
    readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
        'matchLabels': obj.matchLabels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
     */
    readonly matchFields?: KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj: KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(y)),
        'matchFields': obj.matchFields?.map(y => toJson_KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
     */
    readonly matchFields?: KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(obj: KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(y)),
        'matchFields': obj.matchFields?.map(y => toJson_KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
     */
    readonly labelSelector?: KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
     */
    readonly namespaceSelector?: KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
     */
    readonly namespaces?: string[];

    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
     */
    readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labelSelector': toJson_KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
        'namespaceSelector': toJson_KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
        'namespaces': obj.namespaces?.map(y => y),
        'topologyKey': obj.topologyKey,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
     */
    readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
        'matchLabels': obj.matchLabels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
     */
    readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
        'matchLabels': obj.matchLabels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
     */
    readonly labelSelector?: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
     */
    readonly namespaceSelector?: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
     */
    readonly namespaces?: string[];

    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
     */
    readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labelSelector': toJson_KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
        'namespaceSelector': toJson_KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
        'namespaces': obj.namespaces?.map(y => y),
        'topologyKey': obj.topologyKey,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
     */
    readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
        'matchLabels': obj.matchLabels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
     */
    readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
        'matchLabels': obj.matchLabels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
     */
    readonly matchFields?: KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj: KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(y)),
        'matchFields': obj.matchFields?.map(y => toJson_KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
     */
    readonly matchFields?: KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(obj: KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(y)),
        'matchFields': obj.matchFields?.map(y => toJson_KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
     */
    readonly labelSelector?: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
     */
    readonly namespaceSelector?: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
     */
    readonly namespaces?: string[];

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
     */
    readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labelSelector': toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
        'namespaceSelector': toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
        'namespaces': obj.namespaces?.map(y => y),
        'topologyKey': obj.topologyKey,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
     */
    readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
        'matchLabels': obj.matchLabels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
     */
    readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
        'matchLabels': obj.matchLabels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
     */
    readonly labelSelector?: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
     */
    readonly namespaceSelector?: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
     */
    readonly namespaces?: string[];

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
     */
    readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labelSelector': toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
        'namespaceSelector': toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
        'namespaces': obj.namespaces?.map(y => y),
        'topologyKey': obj.topologyKey,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
     */
    readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
        'matchLabels': obj.matchLabels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
     */
    readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
        'matchLabels': obj.matchLabels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
     */
    readonly matchFields?: KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj: KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(y)),
        'matchFields': obj.matchFields?.map(y => toJson_KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
     */
    readonly matchFields?: KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(obj: KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(y)),
        'matchFields': obj.matchFields?.map(y => toJson_KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
     */
    readonly labelSelector?: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
     */
    readonly namespaceSelector?: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
     */
    readonly namespaces?: string[];

    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
     */
    readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labelSelector': toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
        'namespaceSelector': toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
        'namespaces': obj.namespaces?.map(y => y),
        'topologyKey': obj.topologyKey,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
     */
    readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
        'matchLabels': obj.matchLabels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
     */
    readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
        'matchLabels': obj.matchLabels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
     */
    readonly labelSelector?: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
     */
    readonly namespaceSelector?: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
     */
    readonly namespaces?: string[];

    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
     */
    readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labelSelector': toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
        'namespaceSelector': toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
        'namespaces': obj.namespaces?.map(y => y),
        'topologyKey': obj.topologyKey,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
     */
    readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
        'matchLabels': obj.matchLabels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
     */
    readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
        'matchLabels': obj.matchLabels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
     */
    readonly matchFields?: KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj: KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(y)),
        'matchFields': obj.matchFields?.map(y => toJson_KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
     */
    readonly matchFields?: KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(obj: KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(y)),
        'matchFields': obj.matchFields?.map(y => toJson_KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
     */
    readonly labelSelector?: KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
     */
    readonly namespaceSelector?: KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
     */
    readonly namespaces?: string[];

    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
     */
    readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labelSelector': toJson_KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
        'namespaceSelector': toJson_KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
        'namespaces': obj.namespaces?.map(y => y),
        'topologyKey': obj.topologyKey,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
     */
    readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
        'matchLabels': obj.matchLabels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
     */
    readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
        'matchLabels': obj.matchLabels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
     */
    readonly labelSelector?: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
     */
    readonly namespaceSelector?: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
     */
    readonly namespaces?: string[];

    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
     */
    readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labelSelector': toJson_KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
        'namespaceSelector': toJson_KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
        'namespaces': obj.namespaces?.map(y => y),
        'topologyKey': obj.topologyKey,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
     */
    readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
        'matchLabels': obj.matchLabels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
     */
    readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
        'matchLabels': obj.matchLabels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
     */
    readonly matchFields?: KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference(obj: KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(y)),
        'matchFields': obj.matchFields?.map(y => toJson_KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
     */
    readonly matchFields?: KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms(obj: KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(y)),
        'matchFields': obj.matchFields?.map(y => toJson_KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(y)),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
     */
    readonly labelSelector?: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
     */
    readonly namespaceSelector?: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
     */
    readonly namespaces?: string[];

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
     */
    readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labelSelector': toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
        'namespaceSelector': toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
        'namespaces': obj.namespaces?.map(y => y),
        'topologyKey': obj.topologyKey,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
     */
    readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
        'matchLabels': obj.matchLabels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
     */
    readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
        'matchLabels': obj.matchLabels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
     */
    readonly labelSelector?: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaceSelector
     */
    readonly namespaceSelector?: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
     */
    readonly namespaces?: string[];

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
     */
    readonly topologyKey?: string;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm(obj: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'labelSelector': toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj.labelSelector),
        'namespaceSelector': toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj.namespaceSelector),
        'namespaces': obj.namespaces?.map(y => y),
        'topologyKey': obj.topologyKey,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
     */
    readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector(obj: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(y)),
        'matchLabels': obj.matchLabels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[];

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector#matchLabels
     */
    readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector(obj: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(y)),
        'matchLabels': obj.matchLabels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(obj: KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(obj: KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(obj: KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(obj: KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
     */
    readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
        'matchLabels': obj.matchLabels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
     */
    readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
        'matchLabels': obj.matchLabels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
     */
    readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
        'matchLabels': obj.matchLabels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
     */
    readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
        'matchLabels': obj.matchLabels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(obj: KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(obj: KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(obj: KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(obj: KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
     */
    readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
        'matchLabels': obj.matchLabels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
     */
    readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
        'matchLabels': obj.matchLabels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
     */
    readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
        'matchLabels': obj.matchLabels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
     */
    readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
        'matchLabels': obj.matchLabels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(obj: KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(obj: KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(obj: KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(obj: KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
     */
    readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
        'matchLabels': obj.matchLabels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
     */
    readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
        'matchLabels': obj.matchLabels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
     */
    readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
        'matchLabels': obj.matchLabels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
     */
    readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
        'matchLabels': obj.matchLabels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(obj: KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(obj: KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(obj: KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(obj: KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
     */
    readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
        'matchLabels': obj.matchLabels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
     */
    readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
        'matchLabels': obj.matchLabels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
     */
    readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
        'matchLabels': obj.matchLabels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
     */
    readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
        'matchLabels': obj.matchLabels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(obj: KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(obj: KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(obj: KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(obj: KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
     */
    readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
        'matchLabels': obj.matchLabels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
     */
    readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
        'matchLabels': obj.matchLabels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
     */
    readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
        'matchLabels': obj.matchLabels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
     */
    readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
        'matchLabels': obj.matchLabels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions(obj: KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields(obj: KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions(obj: KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields(obj: KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
     */
    readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
        'matchLabels': obj.matchLabels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
     */
    readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
        'matchLabels': obj.matchLabels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
     */
    readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector(obj: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(y)),
        'matchLabels': obj.matchLabels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchExpressions
     */
    readonly matchExpressions?: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[];

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector#matchLabels
     */
    readonly matchLabels?: any;

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector(obj: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'matchExpressions': obj.matchExpressions?.map(y => toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(y)),
        'matchLabels': obj.matchLabels,
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions(obj: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions(obj: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions(obj: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#key
     */
    readonly key?: string;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#operator
     */
    readonly operator?: string;

    /**
     * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions#values
     */
    readonly values?: string[];

}

/**
 * Converts an object of type 'KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions' to JSON representation.
 */

/* eslint-disable max-len, quote-props */
export function toJson_KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions(obj: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
    if (obj === undefined) {
        return undefined;
    }
    const result = {
        'key': obj.key,
        'operator': obj.operator,
        'values': obj.values?.map(y => y),
    };
    // filter undefined values
    return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({...r, [i[0]]: i[1]}), {});
}

/* eslint-enable max-len, quote-props */

